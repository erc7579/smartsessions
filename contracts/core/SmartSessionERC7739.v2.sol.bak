// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import { EIP712 } from "solady/utils/EIP712.sol";
import { IERC7579Account } from "erc7579/interfaces/IERC7579Account.sol";
import { ISmartSession } from "../ISmartSession.sol";
import { AccountIdLib } from "../lib/AccountIdLib.sol";
import { ERC7739UtilsLib } from "../lib/ERC7739UtilsLib.sol";

/// @notice ERC1271 mixin with nested EIP-712 approach.
/// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC1271.sol)

abstract contract SmartSessionERC7739 is ISmartSession {
    using AccountIdLib for string;
    using ERC7739UtilsLib for *;

    // TODO: can we get this from somewhere else to keep the bytecode smaller?
    string internal constant EIP712DOMAIN_TYPE =
        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)";

    bytes32 internal constant EIP712DOMAIN_TYPE_HASH =
        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
    /// @dev Returns whether the `hash` and `signature` are valid.
    /// Override if you need non-ECDSA logic.

    function _erc1271IsValidSignatureNowCalldata(
        address sender,
        bytes32 hash,
        bytes calldata signature,
        bytes calldata contents
    )
        internal
        view
        virtual
        returns (bool);

    /// @dev ERC1271 signature validation (Nested EIP-712 workflow).
    ///
    /// This uses ECDSA recovery by default (see: `_erc1271IsValidSignatureNowCalldata`).
    /// It also uses a nested EIP-712 approach to prevent signature replays when a single EOA
    /// owns multiple smart contract accounts,
    /// while still enabling wallet UIs (e.g. Metamask) to show the EIP-712 values.
    ///
    /// Crafted for phishing resistance, efficiency, flexibility.
    /// __________________________________________________________________________________________
    ///
    /// Glossary:
    ///
    /// - `APP_DOMAIN_SEPARATOR`: The domain separator of the `hash` passed in by the application.
    ///   Provided by the front end. Intended to be the domain separator of the contract
    ///   that will call `isValidSignature` on this account.
    ///
    /// - `ACCOUNT_DOMAIN_SEPARATOR`: The domain separator of this account.
    ///   See: `EIP712._domainSeparator()`.
    /// __________________________________________________________________________________________
    ///
    /// For the `TypedDataSign` workflow, the final hash will be:
    /// ```
    ///     keccak256(\x19\x01 ‖ APP_DOMAIN_SEPARATOR ‖
    ///         hashStruct(TypedDataSign({
    ///             contents: hashStruct(originalStruct),
    ///             name: keccak256(bytes(eip712Domain().name)),
    ///             version: keccak256(bytes(eip712Domain().version)),
    ///             chainId: eip712Domain().chainId,
    ///             verifyingContract: eip712Domain().verifyingContract,
    ///             salt: eip712Domain().salt
    ///         }))
    ///     )
    /// ```
    /// where `‖` denotes the concatenation operator for bytes.
    /// The order of the fields is important: `contents` comes before `name`.
    ///
    /// The signature will be `r ‖ s ‖ v ‖ APP_DOMAIN_SEPARATOR ‖
    ///     contents ‖ contentsDescription ‖ uint16(contentsDescription.length)`,
    /// where:
    /// - `contents` is the bytes32 struct hash of the original struct.
    /// - `contentsDescription` can be either:
    ///     a) `contentsType` (implicit mode)
    ///         where `contentsType` starts with `contentsName`.
    ///     b) `contentsType ‖ contentsName` (explicit mode)
    ///         where `contentsType` may not necessarily start with `contentsName`.
    ///
    /// The `APP_DOMAIN_SEPARATOR` and `contents` will be used to verify if `hash` is indeed correct.
    /// __________________________________________________________________________________________
    ///
    /// For the `PersonalSign` workflow, the final hash will be:
    /// ```
    ///     keccak256(\x19\x01 ‖ ACCOUNT_DOMAIN_SEPARATOR ‖
    ///         hashStruct(PersonalSign({
    ///             prefixed: keccak256(bytes(\x19Ethereum Signed Message:\n ‖
    ///                 base10(bytes(someString).length) ‖ someString))
    ///         }))
    ///     )
    /// ```
    /// where `‖` denotes the concatenation operator for bytes.
    ///
    /// The `PersonalSign` type hash will be `keccak256("PersonalSign(bytes prefixed)")`.
    /// The signature will be `r ‖ s ‖ v`.
    /// __________________________________________________________________________________________
    ///
    /// For demo and typescript code, see:
    /// - https://github.com/junomonster/nested-eip-712
    /// - https://github.com/frangio/eip712-wrapper-for-eip1271
    ///
    /// Their nomenclature may differ from ours, although the high-level idea is similar.
    ///
    /// Of course, if you have control over the codebase of the wallet client(s) too,
    /// you can choose a more minimalistic signature scheme like
    /// `keccak256(abi.encode(address(this), hash))` instead of all these acrobatics.
    /// All these are just for widespread out-of-the-box compatibility with other wallet clients.
    /// We want to create bazaars, not walled castles.
    /// And we'll use push the Turing Completeness of the EVM to the limits to do so.
    function _erc1271IsValidSignatureViaNestedEIP712(
        address sender,
        bytes32 hash,
        bytes calldata encodedSignature
    )
        internal
        view
        virtual
        returns (bool result)
    {
        bytes32 appSeparator;
        string calldata contentsTypeName;
        bytes32 contentsHash;
        bytes32 _hash;

        {
            string calldata contentsType;
            string calldata contentsDescr;
            uint16 domainOffset;
            (encodedSignature, appSeparator, contentsHash, contentsDescr, domainOffset) = encodedSignature.decodeTypedDataSig();

            // decode contents type descriptor
            (contentsTypeName, contentsType) = contentsDescr.decodeContentsDescr();

            _hash = appSeparator.toTypedDataHash(
                ERC7739UtilsLib.typedDataSignStructHash(
                    contentsTypeName,
                    string.concat(contentsType[:domainOffset], EIP712DOMAIN_TYPE, contentsType[domainOffset:]),
                    contentsHash,
                    _accountDomainSeparator()
                )
            );
        }

        result = _erc1271IsValidSignatureNowCalldata({
            sender: sender,
            hash: _hash,
            signature: encodedSignature,
            contents: bytes(contentsTypeName)
        });

        // data was parsed correctly
        // ... and contentHash and separator math the requested hash
        // ... and signature of the TypedDataSign object is correct
        return bytes(contentsTypeName).length != 0 && hash == appSeparator.toTypedDataHash(contentsHash) && result;
    }
    /// @dev Unwraps and returns the signature.

    function _erc1271UnwrapSignature(bytes calldata signature) internal view virtual returns (bytes calldata result) {
        result = signature;
        /// @solidity memory-safe-assembly
        assembly {
            // Unwraps the ERC6492 wrapper if it exists.
            // See: https://eips.ethereum.org/EIPS/eip-6492
            if eq(
                calldataload(add(result.offset, sub(result.length, 0x20))),
                mul(0x6492, div(not(shr(address(), address())), 0xffff)) // `0x6492...6492`.
            ) {
                let o := add(result.offset, calldataload(add(result.offset, 0x40)))
                result.length := calldataload(o)
                result.offset := add(o, 0x20)
            }
        }
    }

    function eip712Domain()
        public
        view
        returns (
            bytes1 fields,
            string memory name,
            string memory version,
            uint256 chainId,
            address verifyingContract,
            bytes32 salt,
            uint256[] memory extensions
        )
    {
        fields = hex"0f"; // 01111
        verifyingContract = msg.sender;

        // follows "vendorname.accountname.semver" structure as per ERC-7579
        string memory accountId = IERC7579Account(msg.sender).accountId();

        //parse name from accountId
        (name, version) = accountId.parseAccountId();

        chainId = block.chainid;
    }

    function _accountDomainSeparator() private view returns (bytes32) {
        (, string memory name, string memory version, uint256 chainId, address verifyingContract,,) = eip712Domain();
        return keccak256(
            abi.encode(
                EIP712DOMAIN_TYPE_HASH, keccak256(bytes(name)), keccak256(bytes(version)), chainId, verifyingContract
            )
        );
    }
}
