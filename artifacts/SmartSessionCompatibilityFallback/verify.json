{"language":"Solidity","sources":{"contracts/SmartSessionCompatibilityFallback.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.25;\n\nimport \"./DataTypes.sol\";\nimport { ERC7579FallbackBase } from \"@rhinestone/module-bases/src/ERC7579FallbackBase.sol\";\nimport { IERC7579Account } from \"erc7579/interfaces/IERC7579Account.sol\";\nimport { AccountIdLib } from \"./lib/AccountIdLib.sol\";\n\ncontract SmartSessionCompatibilityFallback is ERC7579FallbackBase {\n    using AccountIdLib for string;\n\n    mapping(address smartAccount => bool isInitialized) public isInitialized;\n\n    function onInstall(bytes calldata /*data*/ ) external override {\n        isInitialized[msg.sender] = true;\n    }\n\n    function onUninstall(bytes calldata /*data*/ ) external override {\n        isInitialized[msg.sender] = false;\n    }\n\n    function isModuleType(uint256 typeID) external pure override returns (bool) {\n        // if SmartSessions is to be used as a ERC1271/ERC7739 validator module, the account has to implement  function\n        // supportsNestedTypedDataSign() public view virtual returns (bytes32 result)\n        // this can be achieved by adding this function selector in your 7579 account as a fallback handler\n        // YOU MUST NOT add any of the write functions via 7579 fallback selector\n        if (typeID == ERC7579_MODULE_TYPE_FALLBACK) return true;\n    }\n\n    /// @dev For automatic detection that the smart account supports the nested EIP-712 workflow.\n    /// By default, it returns `bytes32(bytes4(keccak256(\"supportsNestedTypedDataSign()\")))`,\n    /// denoting support for the default behavior, as implemented in\n    /// `_erc1271IsValidSignatureViaNestedEIP712`, which is called in `isValidSignature`.\n    /// Future extensions should return a different non-zero `result` to denote different behavior.\n    /// This method intentionally returns bytes32 to allow freedom for future extensions.\n    function supportsNestedTypedDataSign() public view virtual returns (bytes32 result) {\n        result = bytes4(0xd620c85a);\n    }\n\n    function eip712Domain()\n        public\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        fields = hex\"0f\"; // 01111\n        verifyingContract = msg.sender;\n\n        // follows \"vendorname.accountname.semver\" structure as per ERC-7579\n        string memory accountId = IERC7579Account(msg.sender).accountId();\n\n        //parse name from accountId\n        (name, version) = accountId.parseAccountId();\n\n        chainId = block.chainid;\n    }\n}\n"},"contracts/DataTypes.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.25;\n\nimport \"./utils/AssociatedArrayLib.sol\";\nimport { IRegistry, ModuleType } from \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/ISessionValidator.sol\";\nimport { EnumerableSet } from \"./utils/EnumerableSet4337.sol\";\nimport { EnumerableMap } from \"./utils/EnumerableMap4337.sol\";\nimport { FlatBytesLib } from \"flatbytes/BytesLib.sol\";\n\n/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n/*                       Parameters                           */\n/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\nstruct EnableSession {\n    uint8 chainDigestIndex;\n    ChainDigest[] hashesAndChainIds;\n    Session sessionToEnable;\n    // in order to enable a session, the smart account has to sign a digest. The signature for this is stored here.\n    bytes permissionEnableSig;\n}\n\nstruct ChainDigest {\n    uint64 chainId;\n    bytes32 sessionDigest;\n}\n\n/**\n *\n * Represents a Session structure with various attributes for managing user operations and policies.\n *\n * Attributes:\n *     sessionValidator (ISessionValidator): The validator contract for signing user operations.\n *         Every userOp must be signed by the session key \"owner\". The signature is validated\n *         via a stateless external contract (ISessionValidator) that can implement different\n *         means of validation.\n *\n *     sessionValidatorInitData (bytes): Initialization data for the ISessionValidator contract.\n *         The ISessionValidator contract can be configured with different parameters that are\n *         passed in this field.\n *\n *     salt (bytes32): A unique identifier to prevent collision between sessions.\n *         A session key owner can have multiple sessions with the same parameters. To facilitate\n *         this, a salt is necessary to avoid collision.\n *\n *     userOpPolicies (PolicyData[]): An array of policy data for user operations.\n *         When every session can have multiple policies set.\n *\n *     erc7739Policies (ERC7739Data): ERC1271 Policies specific to the ERC7739 standard.\n *\n *     actions (ActionData[]): An array of action data for specifying function-specific policies.\n *         A common use case of session keys is to scope access to a specific target and function\n *         selector. SmartSession calls this \"Action\". With ActionData, we can specify policies\n *         that are only run if a 7579 execution contains a specific action.\n */\nstruct Session {\n    ISessionValidator sessionValidator;\n    bytes sessionValidatorInitData;\n    bytes32 salt;\n    PolicyData[] userOpPolicies;\n    ERC7739Data erc7739Policies;\n    ActionData[] actions;\n    bool permitERC4337Paymaster;\n}\n\nstruct MultiChainSession {\n    ChainSession[] sessionsAndChainIds;\n}\n\nstruct ChainSession {\n    uint64 chainId;\n    Session session;\n}\n\n// Policy data is a struct that contains the policy address and the initialization data for the policy.\nstruct PolicyData {\n    address policy;\n    bytes initData;\n}\n\n// Action data is a struct that contains the actionId and the policies that are associated with this action.\nstruct ActionData {\n    bytes4 actionTargetSelector;\n    address actionTarget;\n    PolicyData[] actionPolicies;\n}\n\nstruct ERC7739Context {\n    // we can not use a detailed EIP712Domain struct here.\n    // EIP712 specifies: Protocol designers only need to include the fields that make sense for their signing domain.\n    // Unused fields are left out of the struct type.\n    bytes32 appDomainSeparator;\n    string[] contentNames;\n}\n\nstruct EIP712Domain {\n    string name;\n    string version;\n    uint256 chainId;\n    address verifyingContract;\n}\n\nstruct ERC7739Data {\n    ERC7739Context[] allowedERC7739Content;\n    PolicyData[] erc1271Policies;\n}\n\nenum SmartSessionMode {\n    USE,\n    ENABLE,\n    UNSAFE_ENABLE\n}\n\nstruct ERC7739ContextHashes {\n    bytes32 appDomainSeparator;\n    bytes32[] contentNameHashes;\n}\n\n/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n/*                         Storage                            */\n/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\nstruct SignerConf {\n    ISessionValidator sessionValidator;\n    FlatBytesLib.Bytes config; // using FlatBytes to get around storage slot limitations\n}\n\nstruct Policy {\n    mapping(PermissionId => EnumerableSet.AddressSet) policyList;\n}\n\nstruct EnumerableActionPolicy {\n    mapping(ActionId => Policy) actionPolicies;\n    mapping(PermissionId => EnumerableSet.Bytes32Set) enabledActionIds;\n}\n\nstruct EnumerableERC7739Config {\n    mapping(PermissionId => mapping(bytes32 appDomainSeparator => EnumerableSet.Bytes32Set)) enabledContentNames;\n    mapping(PermissionId => EnumerableSet.Bytes32Set) enabledDomainSeparators;\n}\n\n// struct EnumerableERC7739Config {\n//     mapping(PermissionId => EnumerableMap.Bytes32ToBytes32Map) erc1271Policies;\n// }\n// mapping(PermissionId => EnumerableSet.Bytes32Set) enabledDomainSeparators;\n\n/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n/*                 Custom Types & Constants                   */\n/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\ntype PermissionId is bytes32;\n\ntype ActionId is bytes32;\n\ntype ActionPolicyId is bytes32;\n\ntype UserOpPolicyId is bytes32;\n\ntype Erc1271PolicyId is bytes32;\n\ntype ConfigId is bytes32;\n\ntype ValidationData is uint256;\n\nActionId constant EMPTY_ACTIONID = ActionId.wrap(bytes32(0));\nPermissionId constant EMPTY_PERMISSIONID = PermissionId.wrap(bytes32(0));\nUserOpPolicyId constant EMPTY_USEROPPOLICYID = UserOpPolicyId.wrap(bytes32(0));\nActionPolicyId constant EMPTY_ACTIONPOLICYID = ActionPolicyId.wrap(bytes32(0));\nErc1271PolicyId constant EMPTY_ERC1271POLICYID = Erc1271PolicyId.wrap(bytes32(0));\nConfigId constant EMPTY_CONFIGID = ConfigId.wrap(bytes32(0));\n\nValidationData constant ERC4337_VALIDATION_SUCCESS = ValidationData.wrap(0);\nValidationData constant ERC4337_VALIDATION_FAILED = ValidationData.wrap(1);\nbytes4 constant EIP1271_SUCCESS = 0x1626ba7e;\nbytes4 constant EIP1271_FAILED = 0xFFFFFFFF;\n\nuint256 constant ERC7579_MODULE_TYPE_VALIDATOR = 1;\nuint256 constant ERC7579_MODULE_TYPE_EXECUTOR = 2;\nuint256 constant ERC7579_MODULE_TYPE_FALLBACK = 3;\nuint256 constant ERC7579_MODULE_TYPE_HOOK = 4;\nuint256 constant ERC7579_MODULE_TYPE_STATELESS_VALIDATOR = 7;\n\nenum PolicyType {\n    NA,\n    USER_OP,\n    ACTION,\n    ERC1271\n}\n\nIRegistry constant registry = IRegistry(address(0));\nModuleType constant VALIDATOR_MODULE_TYPE = ModuleType.wrap(ERC7579_MODULE_TYPE_VALIDATOR);\n\n// ActionId for a fallback action policy. This id will be used if both action\n// target and selector are set to 1. During validation if the current target and\n// selector does not have a set action policy, then the fallback will be used if\n// enabled.\naddress constant FALLBACK_TARGET_FLAG = address(1);\nbytes4 constant FALLBACK_TARGET_SELECTOR_FLAG = 0x00000001;\nbytes4 constant FALLBACK_TARGET_SELECTOR_FLAG_PERMITTED_TO_CALL_SMARTSESSION = 0x00000002;\n// keccak256(abi.encodePacked(FALLBACK_TARGET_FLAG, FALLBACK_TARGET_SELECTOR_FLAG))\nActionId constant FALLBACK_ACTIONID = ActionId.wrap(0xd884b6afa19f8ace90a388daca691e4e28f20cdac5aeefd46ad8bd1c074d28cf);\n\n// keccak256(abi.encodePacked(FALLBACK_TARGET_FLAG, FALLBACK_TARGET_SELECTOR_FLAG_PERMITTED_TO_CALL_SMARTSESSION))\nActionId constant FALLBACK_ACTIONID_SMARTSESSION_CALL =\n    ActionId.wrap(0x986126569d6396d837d7adeb3ca726199afaf83546f38726e6f331bb92d8e9d6);\n\n// A unique ValidationData value to retry a policy check with the FALLBACK_ACTIONID.\nValidationData constant RETRY_WITH_FALLBACK = ValidationData.wrap(uint256(0x50FFBAAD));\n\nusing { validationDataEq as == } for ValidationData global;\nusing { validationDataNeq as != } for ValidationData global;\n\nfunction validationDataEq(ValidationData uid1, ValidationData uid2) pure returns (bool) {\n    return ValidationData.unwrap(uid1) == ValidationData.unwrap(uid2);\n}\n\nfunction validationDataNeq(ValidationData uid1, ValidationData uid2) pure returns (bool) {\n    return ValidationData.unwrap(uid1) != ValidationData.unwrap(uid2);\n}\n\nusing { permissionIdEq as == } for PermissionId global;\nusing { permissionIdNeq as != } for PermissionId global;\n\nfunction permissionIdEq(PermissionId uid1, PermissionId uid2) pure returns (bool) {\n    return PermissionId.unwrap(uid1) == PermissionId.unwrap(uid2);\n}\n\nfunction permissionIdNeq(PermissionId uid1, PermissionId uid2) pure returns (bool) {\n    return PermissionId.unwrap(uid1) != PermissionId.unwrap(uid2);\n}\n\n// ActionId\nusing { actionIdEq as == } for ActionId global;\nusing { actionIdNeq as != } for ActionId global;\n\nfunction actionIdEq(ActionId id1, ActionId id2) pure returns (bool) {\n    return ActionId.unwrap(id1) == ActionId.unwrap(id2);\n}\n\nfunction actionIdNeq(ActionId id1, ActionId id2) pure returns (bool) {\n    return ActionId.unwrap(id1) != ActionId.unwrap(id2);\n}\n\n// UserOpPolicyId\nusing { userOpPolicyIdEq as == } for UserOpPolicyId global;\nusing { userOpPolicyIdNeq as != } for UserOpPolicyId global;\n\nfunction userOpPolicyIdEq(UserOpPolicyId id1, UserOpPolicyId id2) pure returns (bool) {\n    return UserOpPolicyId.unwrap(id1) == UserOpPolicyId.unwrap(id2);\n}\n\nfunction userOpPolicyIdNeq(UserOpPolicyId id1, UserOpPolicyId id2) pure returns (bool) {\n    return UserOpPolicyId.unwrap(id1) != UserOpPolicyId.unwrap(id2);\n}\n\n// ActionPolicyId\nusing { actionPolicyIdEq as == } for ActionPolicyId global;\nusing { actionPolicyIdNeq as != } for ActionPolicyId global;\n\nfunction actionPolicyIdEq(ActionPolicyId id1, ActionPolicyId id2) pure returns (bool) {\n    return ActionPolicyId.unwrap(id1) == ActionPolicyId.unwrap(id2);\n}\n\nfunction actionPolicyIdNeq(ActionPolicyId id1, ActionPolicyId id2) pure returns (bool) {\n    return ActionPolicyId.unwrap(id1) != ActionPolicyId.unwrap(id2);\n}\n\n// Erc1271PolicyId\nusing { erc1271PolicyIdEq as == } for Erc1271PolicyId global;\nusing { erc1271PolicyIdNeq as != } for Erc1271PolicyId global;\n\nfunction erc1271PolicyIdEq(Erc1271PolicyId id1, Erc1271PolicyId id2) pure returns (bool) {\n    return Erc1271PolicyId.unwrap(id1) == Erc1271PolicyId.unwrap(id2);\n}\n\nfunction erc1271PolicyIdNeq(Erc1271PolicyId id1, Erc1271PolicyId id2) pure returns (bool) {\n    return Erc1271PolicyId.unwrap(id1) != Erc1271PolicyId.unwrap(id2);\n}\n\n// ConfigId\nusing { configIdEq as == } for ConfigId global;\nusing { configIdNeq as != } for ConfigId global;\n\nfunction configIdEq(ConfigId id1, ConfigId id2) pure returns (bool) {\n    return ConfigId.unwrap(id1) == ConfigId.unwrap(id2);\n}\n\nfunction configIdNeq(ConfigId id1, ConfigId id2) pure returns (bool) {\n    return ConfigId.unwrap(id1) != ConfigId.unwrap(id2);\n}\n"},"node_modules/@rhinestone/module-bases/src/ERC7579FallbackBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.25;\n\nimport { IERC7579Fallback } from \"./external/ERC7579.sol\";\nimport { ERC7579ModuleBase } from \"./ERC7579ModuleBase.sol\";\n\nabstract contract ERC7579FallbackBase is IERC7579Fallback, ERC7579ModuleBase {\n    /**\n     * @notice Allows fetching the original caller address.\n     * @dev This is only reliable in combination with a FallbackManager that supports this (e.g. Safe\n     * contract >=1.3.0).\n     *      When using this functionality make sure that the linked _manager (aka msg.sender)\n     * supports this.\n     *      This function does not rely on a trusted forwarder. Use the returned value only to\n     *      check information against the calling manager.\n     * @return sender Original caller address.\n     */\n    function _msgSender() internal pure returns (address sender) {\n        // The assembly code is more direct than the Solidity version using `abi.decode`.\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n}\n"},"node_modules/erc7579/src/interfaces/IERC7579Account.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport { CallType, ExecType, ModeCode } from \"../lib/ModeLib.sol\";\n\nstruct Execution {\n    address target;\n    uint256 value;\n    bytes callData;\n}\n\ninterface IERC7579Account {\n    event ModuleInstalled(uint256 moduleTypeId, address module);\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by Executor Modules\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function executeFromExecutor(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        payable\n        returns (bytes[] memory returnData);\n\n    /**\n     * @dev ERC-1271 isValidSignature\n     *         This function is intended to be used to validate a smart account signature\n     * and may forward the call to a validator module\n     *\n     * @param hash The hash of the data that is signed\n     * @param data The data that is signed\n     */\n    function isValidSignature(bytes32 hash, bytes calldata data) external view returns (bytes4);\n\n    /**\n     * @dev installs a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param initData arbitrary data that may be required on the module during `onInstall`\n     * initialization.\n     */\n    function installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    )\n        external\n        payable;\n\n    /**\n     * @dev uninstalls a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization.\n     */\n    function uninstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata deInitData\n    )\n        external\n        payable;\n\n    /**\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\n     * @param encodedMode the encoded mode\n     */\n    function supportsExecutionMode(ModeCode encodedMode) external view returns (bool);\n\n    /**\n     * Function to check if the account supports installation of a certain module type Id\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     */\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\n\n    /**\n     * Function to check if the account has a certain module installed\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\n     *            thus may be necessary to query multiple module types\n     * @param module the module address\n     * @param additionalContext additional context data that the smart account may interpret to\n     *                          identifiy conditions under which the module is installed.\n     *                          usually this is not necessary, but for some special hooks that\n     *                          are stored in mappings, this param might be needed\n     */\n    function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    )\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Returns the account id of the smart account\n     * @return accountImplementationId the account id of the smart account\n     * the accountId should be structured like so:\n     *        \"vendorname.accountname.semver\"\n     */\n    function accountId() external view returns (string memory accountImplementationId);\n}\n"},"contracts/lib/AccountIdLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.25;\n\nimport { strings } from \"stringutils/strings.sol\";\n\nlibrary AccountIdLib {\n    using strings for *;\n\n    // id follows \"vendorname.accountname.semver\" structure as per ERC-7579\n    // use this for parsing the full account name and version as strings\n    function parseAccountId(string memory id) internal pure returns (string memory name, string memory version) {\n        strings.slice memory id = id.toSlice();\n        strings.slice memory delim = \".\".toSlice();\n        name = string(abi.encodePacked(id.split(delim).toString(), \" \", id.split(delim).toString()));\n        version = id.toString();\n    }\n}\n"},"contracts/utils/AssociatedArrayLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * ERC-4337 / ERC-7562 Compatible array lib.\n *   This array can be used as mapping value in mappings such as (address account => Bytes32Array array)\n *   Array size should not exceed 128.\n */\nlibrary AssociatedArrayLib {\n    using AssociatedArrayLib for *;\n\n    error AssociatedArray_OutOfBounds(uint256 index);\n\n    struct Array {\n        uint256 _spacer;\n    }\n\n    function _slot(Array storage s, address account) private pure returns (bytes32 __slot) {\n        assembly {\n            mstore(0x00, account)\n            mstore(0x20, s.slot)\n            __slot := keccak256(0x00, 0x40)\n        }\n    }\n\n    function _length(Array storage s, address account) private view returns (uint256 __length) {\n        bytes32 slot = _slot(s, account);\n        assembly {\n            __length := sload(slot)\n        }\n    }\n\n    function _get(Array storage s, address account, uint256 index) private view returns (bytes32 value) {\n        return _get(_slot(s, account), index);\n    }\n\n    function _get(bytes32 slot, uint256 index) private view returns (bytes32 value) {\n        assembly {\n            //if (index >= _length(s, account)) revert AssociatedArray_OutOfBounds(index);\n            if iszero(lt(index, sload(slot))) {\n                mstore(0, 0x8277484f) // `AssociatedArray_OutOfBounds(uint256)`\n                mstore(0x20, index)\n                revert(0x1c, 0x24)\n            }\n            value := sload(add(slot, add(index, 1)))\n        }\n    }\n\n    function _getAll(Array storage s, address account) private view returns (bytes32[] memory values) {\n        bytes32 slot = _slot(s, account);\n        uint256 __length;\n        assembly {\n            __length := sload(slot)\n        }\n        values = new bytes32[](__length);\n        for (uint256 i; i < __length; i++) {\n            values[i] = _get(slot, i);\n        }\n    }\n\n    // inefficient. complexity = O(n)\n    // use with caution\n    // in case of large arrays, consider using EnumerableSet4337 instead\n    function _contains(Array storage s, address account, bytes32 value) private view returns (bool) {\n        bytes32 slot = _slot(s, account);\n        uint256 __length;\n        assembly {\n            __length := sload(slot)\n        }\n        for (uint256 i; i < __length; i++) {\n            if (_get(slot, i) == value) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _set(Array storage s, address account, uint256 index, bytes32 value) private {\n        _set(_slot(s, account), index, value);\n    }\n\n    function _set(bytes32 slot, uint256 index, bytes32 value) private {\n        assembly {\n            //if (index >= _length(s, account)) revert AssociatedArray_OutOfBounds(index);\n            if iszero(lt(index, sload(slot))) {\n                mstore(0, 0x8277484f) // `AssociatedArray_OutOfBounds(uint256)`\n                mstore(0x20, index)\n                revert(0x1c, 0x24)\n            }\n            sstore(add(slot, add(index, 1)), value)\n        }\n    }\n\n    function _push(Array storage s, address account, bytes32 value) private {\n        bytes32 slot = _slot(s, account);\n        assembly {\n            // load length (stored @ slot) => this would be the index of a new element\n            let index := sload(slot)\n            sstore(add(slot, add(index, 1)), value) // store at (slot+index+1) => 0th element is stored at slot+1\n            sstore(slot, add(index, 1)) // increment length by 1\n        }\n    }\n\n    function _pop(Array storage s, address account) private {\n        bytes32 slot = _slot(s, account);\n        uint256 __length;\n        assembly {\n            __length := sload(slot)\n        }\n        if (__length == 0) return;\n        _set(slot, __length - 1, 0);\n        assembly {\n            sstore(slot, sub(__length, 1))\n        }\n    }\n\n    function _remove(Array storage s, address account, uint256 index) private {\n        bytes32 slot = _slot(s, account);\n        uint256 __length;\n        assembly {\n            __length := sload(slot)\n            if iszero(lt(index, __length)) {\n                mstore(0, 0x8277484f) // `AssociatedArray_OutOfBounds(uint256)`\n                mstore(0x20, index)\n                revert(0x1c, 0x24)\n            }\n        }\n        _set(slot, index, _get(s, account, __length - 1));\n\n        assembly {\n            // clear the last slot\n            // this is the 'unchecked' version of _set(slot, __length - 1, 0)\n            // as we use length-1 as index, so the check is excessive.\n            // also removes extra -1 and +1 operations\n            sstore(add(slot, __length), 0)\n            // store new length\n            sstore(slot, sub(__length, 1))\n        }\n    }\n\n    struct Bytes32Array {\n        Array _inner;\n    }\n\n    function length(Bytes32Array storage s, address account) internal view returns (uint256) {\n        return _length(s._inner, account);\n    }\n\n    function get(Bytes32Array storage s, address account, uint256 index) internal view returns (bytes32) {\n        return _get(s._inner, account, index);\n    }\n\n    function getAll(Bytes32Array storage s, address account) internal view returns (bytes32[] memory) {\n        return _getAll(s._inner, account);\n    }\n\n    function contains(Bytes32Array storage s, address account, bytes32 value) internal view returns (bool) {\n        return _contains(s._inner, account, value);\n    }\n\n    function add(Bytes32Array storage s, address account, bytes32 value) internal {\n        if (!_contains(s._inner, account, value)) {\n            _push(s._inner, account, value);\n        }\n    }\n\n    function set(Bytes32Array storage s, address account, uint256 index, bytes32 value) internal {\n        _set(s._inner, account, index, value);\n    }\n\n    function push(Bytes32Array storage s, address account, bytes32 value) internal {\n        _push(s._inner, account, value);\n    }\n\n    function pop(Bytes32Array storage s, address account) internal {\n        _pop(s._inner, account);\n    }\n\n    function remove(Bytes32Array storage s, address account, uint256 index) internal {\n        _remove(s._inner, account, index);\n    }\n\n    struct AddressArray {\n        Array _inner;\n    }\n\n    function length(AddressArray storage s, address account) internal view returns (uint256) {\n        return _length(s._inner, account);\n    }\n\n    function get(AddressArray storage s, address account, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_get(s._inner, account, index))));\n    }\n\n    function getAll(AddressArray storage s, address account) internal view returns (address[] memory) {\n        bytes32[] memory bytes32Array = _getAll(s._inner, account);\n        address[] memory addressArray;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            addressArray := bytes32Array\n        }\n        return addressArray;\n    }\n\n    function contains(AddressArray storage s, address account, address value) internal view returns (bool) {\n        return _contains(s._inner, account, bytes32(uint256(uint160(value))));\n    }\n\n    function add(AddressArray storage s, address account, address value) internal {\n        if (!_contains(s._inner, account, bytes32(uint256(uint160(value))))) {\n            _push(s._inner, account, bytes32(uint256(uint160(value))));\n        }\n    }\n\n    function set(AddressArray storage s, address account, uint256 index, address value) internal {\n        _set(s._inner, account, index, bytes32(uint256(uint160(value))));\n    }\n\n    function push(AddressArray storage s, address account, address value) internal {\n        _push(s._inner, account, bytes32(uint256(uint160(value))));\n    }\n\n    function pop(AddressArray storage s, address account) internal {\n        _pop(s._inner, account);\n    }\n\n    function remove(AddressArray storage s, address account, uint256 index) internal {\n        _remove(s._inner, account, index);\n    }\n\n    struct UintArray {\n        Array _inner;\n    }\n\n    function length(UintArray storage s, address account) internal view returns (uint256) {\n        return _length(s._inner, account);\n    }\n\n    function get(UintArray storage s, address account, uint256 index) internal view returns (uint256) {\n        return uint256(_get(s._inner, account, index));\n    }\n\n    function getAll(UintArray storage s, address account) internal view returns (uint256[] memory) {\n        bytes32[] memory bytes32Array = _getAll(s._inner, account);\n        uint256[] memory uintArray;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            uintArray := bytes32Array\n        }\n        return uintArray;\n    }\n\n    function contains(UintArray storage s, address account, uint256 value) internal view returns (bool) {\n        return _contains(s._inner, account, bytes32(value));\n    }\n\n    function add(UintArray storage s, address account, uint256 value) internal {\n        if (!_contains(s._inner, account, bytes32(value))) {\n            _push(s._inner, account, bytes32(value));\n        }\n    }\n\n    function set(UintArray storage s, address account, uint256 index, uint256 value) internal {\n        _set(s._inner, account, index, bytes32(value));\n    }\n\n    function push(UintArray storage s, address account, uint256 value) internal {\n        _push(s._inner, account, bytes32(value));\n    }\n\n    function pop(UintArray storage s, address account) internal {\n        _pop(s._inner, account);\n    }\n\n    function remove(UintArray storage s, address account, uint256 index) internal {\n        _remove(s._inner, account, index);\n    }\n}\n"},"contracts/interfaces/IRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ntype ModuleType is uint256;\n\ninterface IRegistry {\n    event NewTrustedAttesters(address indexed smartAccount);\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          Check with Registry internal attesters            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module) external view;\n\n    function checkForAccount(address smartAccount, address module) external view;\n\n    function check(address module, ModuleType moduleType) external view;\n\n    function checkForAccount(address smartAccount, address module, ModuleType moduleType) external view;\n\n    /**\n     * Allows Smart Accounts - the end users of the registry - to appoint\n     * one or many attesters as trusted.\n     * @dev this function reverts, if address(0), or duplicates are provided in attesters[]\n     *\n     * @param threshold The minimum number of attestations required for a module\n     *                  to be considered secure.\n     * @param attesters The addresses of the attesters to be trusted.\n     */\n    function trustAttesters(uint8 threshold, address[] calldata attesters) external;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              Check with external attester(s)               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module, address[] calldata attesters, uint256 threshold) external view;\n\n    function check(\n        address module,\n        ModuleType moduleType,\n        address[] calldata attesters,\n        uint256 threshold\n    )\n        external\n        view;\n}\n"},"contracts/interfaces/ISessionValidator.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.23;\n\nimport { IModule } from \"erc7579/interfaces/IERC7579Module.sol\";\n\n/**\n * ISessionValidator is a contract that validates signatures for a given session.\n * this interface expects to validate the signature in a stateless way.\n * all parameters required to validate the signature are passed in the function call.\n * Only one ISessionValidator is responsible to validate a userOp.\n * if you want to use multiple validators, you can create a ISessionValidator that aggregates multiple signatures that\n * are packed into userOp.signature\n * It is used to validate the signature of a session.\n *  hash The userOp hash\n *  sig The signature of userOp\n *  data the config data that is used to validate the signature\n */\ninterface ISessionValidator is IModule {\n    function validateSignatureWithData(\n        bytes32 hash,\n        bytes calldata sig,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bool validSig);\n}\n"},"contracts/utils/EnumerableSet4337.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport \"./AssociatedArrayLib.sol\";\n\n/**\n * Fork of OZ's EnumerableSet that makes all storage access ERC-4337 compliant via associated storage\n * @author zeroknots.eth (rhinestone)\n */\nlibrary EnumerableSet {\n    using AssociatedArrayLib for AssociatedArrayLib.Bytes32Array;\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        AssociatedArrayLib.Bytes32Array _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => mapping(address account => uint256)) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, address account, bytes32 value) private returns (bool) {\n        if (!_contains(set, account, value)) {\n            set._values.push(account, value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value][account] = set._values.length(account);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, address account, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value][account];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length(account) - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values.get(account, lastIndex);\n\n                // Move the lastValue to the index where the value to delete is\n                set._values.set(account, valueIndex, lastValue);\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue][account] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop(account);\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value][account];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _removeAll(Set storage set, address account) internal {\n        // get length of the array\n        uint256 len = _length(set, account);\n        for (uint256 i = 1; i <= len; i++) {\n            // get last value\n            bytes32 value = _at(set, account, len - i);\n            _remove(set, account, value);\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, address account, bytes32 value) private view returns (bool) {\n        return set._positions[value][account] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set, address account) private view returns (uint256) {\n        return set._values.length(account);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, address account, uint256 index) private view returns (bytes32) {\n        return set._values.get(account, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set, address account) private view returns (bytes32[] memory) {\n        return set._values.getAll(account);\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, address account, bytes32 value) internal returns (bool) {\n        return _add(set._inner, account, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, address account, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, account, value);\n    }\n\n    function removeAll(Bytes32Set storage set, address account) internal {\n        return _removeAll(set._inner, account);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, address account, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, account, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set, address account) internal view returns (uint256) {\n        return _length(set._inner, account);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, address account, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, account, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set, address account) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner, account);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address account, address value) internal returns (bool) {\n        return _add(set._inner, account, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address account, address value) internal returns (bool) {\n        return _remove(set._inner, account, bytes32(uint256(uint160(value))));\n    }\n\n    function removeAll(AddressSet storage set, address account) internal {\n        return _removeAll(set._inner, account);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address account, address value) internal view returns (bool) {\n        return _contains(set._inner, account, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set, address account) internal view returns (uint256) {\n        return _length(set._inner, account);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, address account, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, account, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set, address account) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner, account);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, address account, uint256 value) internal returns (bool) {\n        return _add(set._inner, account, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, address account, uint256 value) internal returns (bool) {\n        return _remove(set._inner, account, bytes32(value));\n    }\n\n    function removeAll(UintSet storage set, address account) internal {\n        return _removeAll(set._inner, account);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, address account, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, account, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set, address account) internal view returns (uint256) {\n        return _length(set._inner, account);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, address account, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, account, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set, address account) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner, account);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"},"contracts/utils/EnumerableMap4337.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity ^0.8.20;\n\nimport { EnumerableSet } from \"./EnumerableSet4337.sol\";\n\n/**\n * Fork of OZ's EnumerableSet that makes all storage access ERC-4337 compliant via associated storage\n * @author zeroknots.eth (rhinestone)\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code repetition as possible, we write it in\n    // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\n    // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit in bytes32.\n\n    /**\n     * @dev Query for a nonexistent map key.\n     */\n    error EnumerableMapNonexistentKey(bytes32 key);\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 key => mapping(address account => bytes32)) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToBytes32Map storage map,\n        address account,\n        bytes32 key,\n        bytes32 value\n    )\n        internal\n        returns (bool)\n    {\n        map._values[key][account] = value;\n        return map._keys.add(account, key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, address account, bytes32 key) internal returns (bool) {\n        delete map._values[key][account];\n        return map._keys.remove(account, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, address account, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(account, key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map, address account) internal view returns (uint256) {\n        return map._keys.length(account);\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(\n        Bytes32ToBytes32Map storage map,\n        address account,\n        uint256 index\n    )\n        internal\n        view\n        returns (bytes32, bytes32)\n    {\n        bytes32 key = map._keys.at(account, index);\n        return (key, map._values[key][account]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(\n        Bytes32ToBytes32Map storage map,\n        address account,\n        bytes32 key\n    )\n        internal\n        view\n        returns (bool, bytes32)\n    {\n        bytes32 value = map._values[key][account];\n        if (value == bytes32(0)) {\n            return (contains(map, account, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, address account, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key][account];\n        if (value == 0 && !contains(map, account, key)) {\n            revert EnumerableMapNonexistentKey(key);\n        }\n        return value;\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToBytes32Map storage map, address account) internal view returns (bytes32[] memory) {\n        return map._keys.values(account);\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToUintMap storage map, address account, uint256 key, uint256 value) internal returns (bool) {\n        return set(map._inner, account, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, address account, uint256 key) internal returns (bool) {\n        return remove(map._inner, account, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, address account, uint256 key) internal view returns (bool) {\n        return contains(map._inner, account, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map, address account) internal view returns (uint256) {\n        return length(map._inner, account);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, address account, uint256 index) internal view returns (uint256, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, account, index);\n        return (uint256(key), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, address account, uint256 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, account, bytes32(key));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, address account, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, account, bytes32(key)));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToUintMap storage map, address account) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner, account);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, address account, uint256 key, address value) internal returns (bool) {\n        return set(map._inner, account, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, address account, uint256 key) internal returns (bool) {\n        return remove(map._inner, account, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, address account, uint256 key) internal view returns (bool) {\n        return contains(map._inner, account, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map, address account) internal view returns (uint256) {\n        return length(map._inner, account);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(\n        UintToAddressMap storage map,\n        address account,\n        uint256 index\n    )\n        internal\n        view\n        returns (uint256, address)\n    {\n        (bytes32 key, bytes32 value) = at(map._inner, account, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToAddressMap storage map, address account, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, account, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, address account, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, account, bytes32(key)))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToAddressMap storage map, address account) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner, account);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToUintMap storage map, address account, address key, uint256 value) internal returns (bool) {\n        return set(map._inner, account, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address account, address key) internal returns (bool) {\n        return remove(map._inner, account, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address account, address key) internal view returns (bool) {\n        return contains(map._inner, account, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map, address account) internal view returns (uint256) {\n        return length(map._inner, account);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(\n        AddressToUintMap storage map,\n        address account,\n        uint256 index\n    )\n        internal\n        view\n        returns (address, uint256)\n    {\n        (bytes32 key, bytes32 value) = at(map._inner, account, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address account, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, account, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address account, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, account, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToUintMap storage map, address account) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner, account);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToUintMap storage map, address account, bytes32 key, uint256 value) internal returns (bool) {\n        return set(map._inner, account, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, address account, bytes32 key) internal returns (bool) {\n        return remove(map._inner, account, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, address account, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, account, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map, address account) internal view returns (uint256) {\n        return length(map._inner, account);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(\n        Bytes32ToUintMap storage map,\n        address account,\n        uint256 index\n    )\n        internal\n        view\n        returns (bytes32, uint256)\n    {\n        (bytes32 key, bytes32 value) = at(map._inner, account, index);\n        return (key, uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, address account, bytes32 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, account, key);\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, address account, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, account, key));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToUintMap storage map, address account) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner, account);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"},"node_modules/@rhinestone/flatbytes/src/BytesLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\n/**\n * @title FlatBytesLib\n * @dev Library for storing bytes data in consecutive storage slots\n * @dev This is useful in the context of the ERC-4337 validation rules\n * @dev Be careful that this does not override existing data in the next slots and ideally use this\n * data as the value of a struct\n * @author Rhinestone\n */\nlibrary FlatBytesLib {\n    using FlatBytesLib for *;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    DATA STRUCTURES\n    //////////////////////////////////////////////////////////////////////////*/\n\n    // Data structure to store bytes in consecutive slots using an array\n    struct Data {\n        bytes32[10] slot1;\n    }\n\n    // Store the length of the data and the data itself in consecutive slots\n    struct Bytes {\n        uint256 totalLength;\n        Data data;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /**\n     * Store the data in storage\n     *\n     * @param self The storage to store the data in\n     * @param data The data to store\n     */\n    function store(Bytes storage self, bytes memory data) internal {\n        if (data.length > 32 * 10) revert();\n        bytes32[] memory entries;\n        (self.totalLength, entries) = data.toArray();\n\n        uint256 length = entries.length;\n\n        Data storage _data = self.data;\n\n        for (uint256 i; i < length; i++) {\n            bytes32 value = entries[i];\n            assembly {\n                sstore(add(_data.slot, i), value)\n            }\n        }\n    }\n\n    /**\n     * Clear the data in storage\n     *\n     * @param self The storage to clear the data in\n     */\n    function clear(Bytes storage self) internal {\n        self.totalLength = 0;\n        Data storage _data = self.data;\n        for (uint256 i; i < 10; i++) {\n            assembly {\n                sstore(add(_data.slot, i), 0)\n            }\n        }\n    }\n\n    /**\n     * Load the data from storage\n     *\n     * @param self The storage to load the data from\n     *\n     * @return data The data loaded from storage\n     */\n    function load(Bytes storage self) internal view returns (bytes memory data) {\n        return self.toBytes();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    INTERNAL\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /**\n     * Convert bytes to an array of bytes32\n     *\n     * @param data The data to convert\n     * @return totalLength The total length of the data\n     *\n     * @return dataList The data as an array of bytes32\n     */\n    function toArray(bytes memory data)\n        internal\n        pure\n        returns (uint256 totalLength, bytes32[] memory dataList)\n    {\n        // Find 32 bytes segments nb\n        totalLength = data.length;\n        if (totalLength > 32 * 10) revert();\n        uint256 dataNb = totalLength / 32 + 1;\n\n        // Create an array of dataNb elements\n        dataList = new bytes32[](dataNb);\n\n        // Loop all 32 bytes segments\n        for (uint256 i = 0; i < dataNb; i++) {\n            bytes32 temp;\n            // Get 32 bytes from data\n            assembly {\n                temp := mload(add(data, mul(add(i, 1), 32)))\n            }\n            // Add extracted 32 bytes to list\n            dataList[i] = temp;\n        }\n    }\n\n    /**\n     * Convert an array of bytes32 to bytes\n     *\n     * @param self The array of bytes32 to convert\n     *\n     * @return data The data as bytes\n     */\n    function toBytes(Bytes storage self) internal view returns (bytes memory data) {\n        uint256 totalLength = self.totalLength;\n        uint256 slotsCnt = totalLength / 32 + 1;\n\n        Data storage _data = self.data;\n\n        bytes32[] memory entries = new bytes32[](slotsCnt);\n        for (uint256 i; i < slotsCnt; i++) {\n            bytes32 tmp;\n            assembly {\n                tmp := sload(add(_data.slot, i))\n            }\n            entries[i] = tmp;\n        }\n\n        data = abi.encodePacked(entries);\n        assembly {\n            mstore(data, totalLength)\n        }\n    }\n}\n"},"node_modules/@rhinestone/module-bases/src/external/ERC7579.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/* solhint-disable no-unused-import */\nimport { MSAFactory as ERC7579AccountFactory } from \"erc7579/MSAFactory.sol\";\nimport { MSAAdvanced as ERC7579Account } from \"erc7579/MSAAdvanced.sol\";\nimport { Execution, IERC7579Account } from \"erc7579/interfaces/IERC7579Account.sol\";\nimport {\n    IModule as IERC7579Module,\n    IValidator as IERC7579Validator,\n    IExecutor as IERC7579Executor,\n    IHook as IERC7579Hook,\n    IFallback as IERC7579Fallback,\n    MODULE_TYPE_VALIDATOR,\n    MODULE_TYPE_EXECUTOR,\n    MODULE_TYPE_HOOK,\n    MODULE_TYPE_FALLBACK\n} from \"erc7579/interfaces/IERC7579Module.sol\";\n\nimport {\n    ModeLib as ERC7579ModeLib,\n    ModeCode,\n    CallType,\n    ExecType,\n    ModePayload,\n    CALLTYPE_SINGLE,\n    CALLTYPE_BATCH,\n    CALLTYPE_DELEGATECALL,\n    EXECTYPE_DEFAULT,\n    MODE_DEFAULT\n} from \"erc7579/lib/ModeLib.sol\";\nimport { Execution, ExecutionLib as ERC7579ExecutionLib } from \"erc7579/lib/ExecutionLib.sol\";\n\nimport {\n    Bootstrap as ERC7579Bootstrap,\n    BootstrapConfig as ERC7579BootstrapConfig\n} from \"erc7579/utils/Bootstrap.sol\";\n/* solhint-enable no-unused-import */\n"},"node_modules/@rhinestone/module-bases/src/ERC7579ModuleBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.25;\n\nimport { IERC7579Module } from \"./external/ERC7579.sol\";\n\nabstract contract ERC7579ModuleBase is IERC7579Module {\n    uint256 constant TYPE_VALIDATOR = 1;\n    uint256 constant TYPE_EXECUTOR = 2;\n    uint256 constant TYPE_FALLBACK = 3;\n    uint256 constant TYPE_HOOK = 4;\n}\n"},"node_modules/erc7579/src/lib/ModeLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title ModeLib\n * To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\n * encoding is used.\n *    Function Signature of execute function:\n *           function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\n * This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\n * context.\n * NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\n * implement\n * more complex execution modes may use the entire bytes32.\n *\n * |--------------------------------------------------------------------|\n * | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\n * |--------------------------------------------------------------------|\n * | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\n * |--------------------------------------------------------------------|\n *\n * CALLTYPE: 1 byte\n * CallType is used to determine how the executeCalldata paramter of the execute function has to be\n * decoded.\n * It can be either single, batch or delegatecall. In the future different calls could be added.\n * CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\n *\n * EXECTYPE: 1 byte\n * ExecType is used to determine how the account should handle the execution.\n * It can indicate if the execution should revert on failure or continue execution.\n * In the future more execution modes may be added.\n * Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\n * a batch fails, the entire batch is reverted\n *\n * UNUSED: 4 bytes\n * Unused bytes are reserved for future use.\n *\n * ModeSelector: bytes4\n * The \"optional\" mode selector can be used by account vendors, to implement custom behavior in\n * their accounts.\n * the way a ModeSelector is to be calculated is bytes4(keccak256(\"vendorname.featurename\"))\n * this is to prevent collisions between different vendors, while allowing innovation and the\n * development of new features without coordination between ERC-7579 implementing accounts\n *\n * ModePayload: 22 bytes\n * Mode payload is used to pass additional data to the smart account execution, this may be\n * interpreted depending on the ModeSelector\n *\n * ExecutionCallData: n bytes\n * single, delegatecall or batch exec abi.encoded as bytes\n */\nimport { Execution } from \"../interfaces/IERC7579Account.sol\";\n\n// Custom type for improved developer experience\ntype ModeCode is bytes32;\n\ntype CallType is bytes1;\n\ntype ExecType is bytes1;\n\ntype ModeSelector is bytes4;\n\ntype ModePayload is bytes22;\n\n// Default CallType\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\n// Batched CallType\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\n// @dev Implementing delegatecall is OPTIONAL!\n// implement delegatecall with extreme care.\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\n\n// @dev default behavior is to revert on failure\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\n// Since this is value 0x00, no additional encoding is required for simple accounts\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\n// @dev account may elect to change execution behavior. For example \"try exec\" / \"allow fail\"\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\n\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\n// Example declaration of a custom mode selector\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\"default.mode.offset\")));\n\n/**\n * @dev ModeLib is a helper library to encode/decode ModeCodes\n */\nlibrary ModeLib {\n    function decode(ModeCode mode)\n        internal\n        pure\n        returns (\n            CallType _calltype,\n            ExecType _execType,\n            ModeSelector _modeSelector,\n            ModePayload _modePayload\n        )\n    {\n        assembly {\n            _calltype := mode\n            _execType := shl(8, mode)\n            _modeSelector := shl(48, mode)\n            _modePayload := shl(80, mode)\n        }\n    }\n\n    function encode(\n        CallType callType,\n        ExecType execType,\n        ModeSelector mode,\n        ModePayload payload\n    )\n        internal\n        pure\n        returns (ModeCode)\n    {\n        return ModeCode.wrap(\n            bytes32(\n                abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)\n            )\n        );\n    }\n\n    function encodeSimpleBatch() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeSimpleSingle() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function getCallType(ModeCode mode) internal pure returns (CallType calltype) {\n        assembly {\n            calltype := mode\n        }\n    }\n}\n\nusing { eqModeSelector as == } for ModeSelector global;\nusing { eqCallType as == } for CallType global;\nusing { eqExecType as == } for ExecType global;\n\nfunction eqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) == CallType.unwrap(b);\n}\n\nfunction eqExecType(ExecType a, ExecType b) pure returns (bool) {\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\n}\n\nfunction eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\n}\n"},"node_modules/stringutils/src/strings.sol":{"content":"/*\n * @title String & slice utility library for Solidity contracts.\n * @author Nick Johnson <arachnid@notdot.net>\n *\n * @dev Functionality in this library is largely implemented using an\n *      abstraction called a 'slice'. A slice represents a part of a string -\n *      anything from the entire string to a single character, or even no\n *      characters at all (a 0-length slice). Since a slice only has to specify\n *      an offset and a length, copying and manipulating slices is a lot less\n *      expensive than copying and manipulating the strings they reference.\n *\n *      To further reduce gas costs, most functions on slice that need to return\n *      a slice modify the original one instead of allocating a new one; for\n *      instance, `s.split(\".\")` will return the text up to the first '.',\n *      modifying s to only contain the remainder of the string after the '.'.\n *      In situations where you do not want to modify the original slice, you\n *      can make a copy first with `.copy()`, for example:\n *      `s.copy().split(\".\")`. Try and avoid using this idiom in loops; since\n *      Solidity has no memory management, it will result in allocating many\n *      short-lived slices that are later discarded.\n *\n *      Functions that return two slices come in two versions: a non-allocating\n *      version that takes the second slice as an argument, modifying it in\n *      place, and an allocating version that allocates and returns the second\n *      slice; see `nextRune` for example.\n *\n *      Functions that have to copy string data will return strings rather than\n *      slices; these can be cast back to slices for further processing if\n *      required.\n *\n *      For convenience, some functions are provided with non-modifying\n *      variants that create a new slice and return both; for instance,\n *      `s.splitNew('.')` leaves s unmodified, and returns two values\n *      corresponding to the left and right parts of the string.\n */\n\npragma solidity ^0.8.0;\n\nlibrary strings {\n    struct slice {\n        uint _len;\n        uint _ptr;\n    }\n\n    function memcpy(uint dest, uint src, uint length) private pure {\n        // Copy word-length chunks while possible\n        for(; length >= 32; length -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = type(uint).max;\n        if (length > 0) {\n            mask = 256 ** (32 - length) - 1;\n        }\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /*\n     * @dev Returns a slice containing the entire string.\n     * @param self The string to make a slice from.\n     * @return A newly allocated slice containing the entire string.\n     */\n    function toSlice(string memory self) internal pure returns (slice memory) {\n        uint ptr;\n        assembly {\n            ptr := add(self, 0x20)\n        }\n        return slice(bytes(self).length, ptr);\n    }\n\n    /*\n     * @dev Returns the length of a null-terminated bytes32 string.\n     * @param self The value to find the length of.\n     * @return The length of the string, from 0 to 32.\n     */\n    function len(bytes32 self) internal pure returns (uint) {\n        uint ret;\n        if (self == 0)\n            return 0;\n        if (uint(self) & type(uint128).max == 0) {\n            ret += 16;\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n        }\n        if (uint(self) & type(uint64).max == 0) {\n            ret += 8;\n            self = bytes32(uint(self) / 0x10000000000000000);\n        }\n        if (uint(self) & type(uint32).max == 0) {\n            ret += 4;\n            self = bytes32(uint(self) / 0x100000000);\n        }\n        if (uint(self) & type(uint16).max == 0) {\n            ret += 2;\n            self = bytes32(uint(self) / 0x10000);\n        }\n        if (uint(self) & type(uint8).max == 0) {\n            ret += 1;\n        }\n        return 32 - ret;\n    }\n\n    /*\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\n     *      null-terminated utf-8 string.\n     * @param self The bytes32 value to convert to a slice.\n     * @return A new slice containing the value of the input argument up to the\n     *         first null.\n     */\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n        assembly {\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, 0x20))\n            mstore(ptr, self)\n            mstore(add(ret, 0x20), ptr)\n        }\n        ret._len = len(self);\n    }\n\n    /*\n     * @dev Returns a new slice containing the same data as the current slice.\n     * @param self The slice to copy.\n     * @return A new slice containing the same data as `self`.\n     */\n    function copy(slice memory self) internal pure returns (slice memory) {\n        return slice(self._len, self._ptr);\n    }\n\n    /*\n     * @dev Copies a slice to a new string.\n     * @param self The slice to copy.\n     * @return A newly allocated string containing the slice's text.\n     */\n    function toString(slice memory self) internal pure returns (string memory) {\n        string memory ret = new string(self._len);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n        return ret;\n    }\n\n    /*\n     * @dev Returns the length in runes of the slice. Note that this operation\n     *      takes time proportional to the length of the slice; avoid using it\n     *      in loops, and call `slice.empty()` if you only need to know whether\n     *      the slice is empty or not.\n     * @param self The slice to operate on.\n     * @return The length of the slice in runes.\n     */\n    function len(slice memory self) internal pure returns (uint l) {\n        // Starting at ptr-31 means the LSB will be the byte we care about\n        uint ptr = self._ptr - 31;\n        uint end = ptr + self._len;\n        for (l = 0; ptr < end; l++) {\n            uint8 b;\n            assembly { b := and(mload(ptr), 0xFF) }\n            if (b < 0x80) {\n                ptr += 1;\n            } else if(b < 0xE0) {\n                ptr += 2;\n            } else if(b < 0xF0) {\n                ptr += 3;\n            } else if(b < 0xF8) {\n                ptr += 4;\n            } else if(b < 0xFC) {\n                ptr += 5;\n            } else {\n                ptr += 6;\n            }\n        }\n    }\n\n    /*\n     * @dev Returns true if the slice is empty (has a length of 0).\n     * @param self The slice to operate on.\n     * @return True if the slice is empty, False otherwise.\n     */\n    function empty(slice memory self) internal pure returns (bool) {\n        return self._len == 0;\n    }\n\n    /*\n     * @dev Returns a positive number if `other` comes lexicographically after\n     *      `self`, a negative number if it comes before, or zero if the\n     *      contents of the two slices are equal. Comparison is done per-rune,\n     *      on unicode codepoints.\n     * @param self The first slice to compare.\n     * @param other The second slice to compare.\n     * @return The result of the comparison.\n     */\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\n        uint shortest = self._len;\n        if (other._len < self._len)\n            shortest = other._len;\n\n        uint selfptr = self._ptr;\n        uint otherptr = other._ptr;\n        for (uint idx = 0; idx < shortest; idx += 32) {\n            uint a;\n            uint b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint mask = type(uint).max; // 0xffff...\n                if(shortest < 32) {\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n                }\n                unchecked {\n                    uint diff = (a & mask) - (b & mask);\n                    if (diff != 0)\n                        return int(diff);\n                }\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }\n        return int(self._len) - int(other._len);\n    }\n\n    /*\n     * @dev Returns true if the two slices contain the same text.\n     * @param self The first slice to compare.\n     * @param self The second slice to compare.\n     * @return True if the slices are equal, false otherwise.\n     */\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\n        return compare(self, other) == 0;\n    }\n\n    /*\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\n     *      slice to point to the next rune and returning `self`.\n     * @param self The slice to operate on.\n     * @param rune The slice that will contain the first rune.\n     * @return `rune`.\n     */\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n        rune._ptr = self._ptr;\n\n        if (self._len == 0) {\n            rune._len = 0;\n            return rune;\n        }\n\n        uint l;\n        uint b;\n        // Load the first byte of the rune into the LSBs of b\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n        if (b < 0x80) {\n            l = 1;\n        } else if(b < 0xE0) {\n            l = 2;\n        } else if(b < 0xF0) {\n            l = 3;\n        } else {\n            l = 4;\n        }\n\n        // Check for truncated codepoints\n        if (l > self._len) {\n            rune._len = self._len;\n            self._ptr += self._len;\n            self._len = 0;\n            return rune;\n        }\n\n        self._ptr += l;\n        self._len -= l;\n        rune._len = l;\n        return rune;\n    }\n\n    /*\n     * @dev Returns the first rune in the slice, advancing the slice to point\n     *      to the next rune.\n     * @param self The slice to operate on.\n     * @return A slice containing only the first rune from `self`.\n     */\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\n        nextRune(self, ret);\n    }\n\n    /*\n     * @dev Returns the number of the first codepoint in the slice.\n     * @param self The slice to operate on.\n     * @return The number of the first codepoint in the slice.\n     */\n    function ord(slice memory self) internal pure returns (uint ret) {\n        if (self._len == 0) {\n            return 0;\n        }\n\n        uint word;\n        uint length;\n        uint divisor = 2 ** 248;\n\n        // Load the rune into the MSBs of b\n        assembly { word:= mload(mload(add(self, 32))) }\n        uint b = word / divisor;\n        if (b < 0x80) {\n            ret = b;\n            length = 1;\n        } else if(b < 0xE0) {\n            ret = b & 0x1F;\n            length = 2;\n        } else if(b < 0xF0) {\n            ret = b & 0x0F;\n            length = 3;\n        } else {\n            ret = b & 0x07;\n            length = 4;\n        }\n\n        // Check for truncated codepoints\n        if (length > self._len) {\n            return 0;\n        }\n\n        for (uint i = 1; i < length; i++) {\n            divisor = divisor / 256;\n            b = (word / divisor) & 0xFF;\n            if (b & 0xC0 != 0x80) {\n                // Invalid UTF-8 sequence\n                return 0;\n            }\n            ret = (ret * 64) | (b & 0x3F);\n        }\n\n        return ret;\n    }\n\n    /*\n     * @dev Returns the keccak-256 hash of the slice.\n     * @param self The slice to hash.\n     * @return The hash of the slice.\n     */\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n        assembly {\n            ret := keccak256(mload(add(self, 32)), mload(self))\n        }\n    }\n\n    /*\n     * @dev Returns true if `self` starts with `needle`.\n     * @param self The slice to operate on.\n     * @param needle The slice to search for.\n     * @return True if the slice starts with the provided text, false otherwise.\n     */\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n        if (self._len < needle._len) {\n            return false;\n        }\n\n        if (self._ptr == needle._ptr) {\n            return true;\n        }\n\n        bool equal;\n        assembly {\n            let length := mload(needle)\n            let selfptr := mload(add(self, 0x20))\n            let needleptr := mload(add(needle, 0x20))\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n        }\n        return equal;\n    }\n\n    /*\n     * @dev If `self` starts with `needle`, `needle` is removed from the\n     *      beginning of `self`. Otherwise, `self` is unmodified.\n     * @param self The slice to operate on.\n     * @param needle The slice to search for.\n     * @return `self`\n     */\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n        if (self._len < needle._len) {\n            return self;\n        }\n\n        bool equal = true;\n        if (self._ptr != needle._ptr) {\n            assembly {\n                let length := mload(needle)\n                let selfptr := mload(add(self, 0x20))\n                let needleptr := mload(add(needle, 0x20))\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n            }\n        }\n\n        if (equal) {\n            self._len -= needle._len;\n            self._ptr += needle._len;\n        }\n\n        return self;\n    }\n\n    /*\n     * @dev Returns true if the slice ends with `needle`.\n     * @param self The slice to operate on.\n     * @param needle The slice to search for.\n     * @return True if the slice starts with the provided text, false otherwise.\n     */\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n        if (self._len < needle._len) {\n            return false;\n        }\n\n        uint selfptr = self._ptr + self._len - needle._len;\n\n        if (selfptr == needle._ptr) {\n            return true;\n        }\n\n        bool equal;\n        assembly {\n            let length := mload(needle)\n            let needleptr := mload(add(needle, 0x20))\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n        }\n\n        return equal;\n    }\n\n    /*\n     * @dev If `self` ends with `needle`, `needle` is removed from the\n     *      end of `self`. Otherwise, `self` is unmodified.\n     * @param self The slice to operate on.\n     * @param needle The slice to search for.\n     * @return `self`\n     */\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n        if (self._len < needle._len) {\n            return self;\n        }\n\n        uint selfptr = self._ptr + self._len - needle._len;\n        bool equal = true;\n        if (selfptr != needle._ptr) {\n            assembly {\n                let length := mload(needle)\n                let needleptr := mload(add(needle, 0x20))\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n            }\n        }\n\n        if (equal) {\n            self._len -= needle._len;\n        }\n\n        return self;\n    }\n\n    // Returns the memory address of the first byte of the first occurrence of\n    // `needle` in `self`, or the first byte after `self` if not found.\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n        uint ptr = selfptr;\n        uint idx;\n\n        if (needlelen <= selflen) {\n            if (needlelen <= 32) {\n                bytes32 mask;\n                if (needlelen > 0) {\n                    mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n                }\n\n                bytes32 needledata;\n                assembly { needledata := and(mload(needleptr), mask) }\n\n                uint end = selfptr + selflen - needlelen;\n                bytes32 ptrdata;\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n                while (ptrdata != needledata) {\n                    if (ptr >= end)\n                        return selfptr + selflen;\n                    ptr++;\n                    assembly { ptrdata := and(mload(ptr), mask) }\n                }\n                return ptr;\n            } else {\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := keccak256(needleptr, needlelen) }\n\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n                    bytes32 testHash;\n                    assembly { testHash := keccak256(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr;\n                    ptr += 1;\n                }\n            }\n        }\n        return selfptr + selflen;\n    }\n\n    // Returns the memory address of the first byte after the last occurrence of\n    // `needle` in `self`, or the address of `self` if not found.\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n        uint ptr;\n\n        if (needlelen <= selflen) {\n            if (needlelen <= 32) {\n                bytes32 mask;\n                if (needlelen > 0) {\n                    mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n                }\n\n                bytes32 needledata;\n                assembly { needledata := and(mload(needleptr), mask) }\n\n                ptr = selfptr + selflen - needlelen;\n                bytes32 ptrdata;\n                assembly { ptrdata := and(mload(ptr), mask) }\n\n                while (ptrdata != needledata) {\n                    if (ptr <= selfptr)\n                        return selfptr;\n                    ptr--;\n                    assembly { ptrdata := and(mload(ptr), mask) }\n                }\n                return ptr + needlelen;\n            } else {\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := keccak256(needleptr, needlelen) }\n                ptr = selfptr + (selflen - needlelen);\n                while (ptr >= selfptr) {\n                    bytes32 testHash;\n                    assembly { testHash := keccak256(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr + needlelen;\n                    ptr -= 1;\n                }\n            }\n        }\n        return selfptr;\n    }\n\n    /*\n     * @dev Modifies `self` to contain everything from the first occurrence of\n     *      `needle` to the end of the slice. `self` is set to the empty slice\n     *      if `needle` is not found.\n     * @param self The slice to search and modify.\n     * @param needle The text to search for.\n     * @return `self`.\n     */\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n        self._len -= ptr - self._ptr;\n        self._ptr = ptr;\n        return self;\n    }\n\n    /*\n     * @dev Modifies `self` to contain the part of the string from the start of\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\n     *      is not found, `self` is set to the empty slice.\n     * @param self The slice to search and modify.\n     * @param needle The text to search for.\n     * @return `self`.\n     */\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n        self._len = ptr - self._ptr;\n        return self;\n    }\n\n    /*\n     * @dev Splits the slice, setting `self` to everything after the first\n     *      occurrence of `needle`, and `token` to everything before it. If\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n     *      and `token` is set to the entirety of `self`.\n     * @param self The slice to split.\n     * @param needle The text to search for in `self`.\n     * @param token An output parameter to which the first token is written.\n     * @return `token`.\n     */\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n        token._ptr = self._ptr;\n        token._len = ptr - self._ptr;\n        if (ptr == self._ptr + self._len) {\n            // Not found\n            self._len = 0;\n        } else {\n            self._len -= token._len + needle._len;\n            self._ptr = ptr + needle._len;\n        }\n        return token;\n    }\n\n    /*\n     * @dev Splits the slice, setting `self` to everything after the first\n     *      occurrence of `needle`, and returning everything before it. If\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n     *      and the entirety of `self` is returned.\n     * @param self The slice to split.\n     * @param needle The text to search for in `self`.\n     * @return The part of `self` up to the first occurrence of `delim`.\n     */\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n        split(self, needle, token);\n    }\n\n    /*\n     * @dev Splits the slice, setting `self` to everything before the last\n     *      occurrence of `needle`, and `token` to everything after it. If\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n     *      and `token` is set to the entirety of `self`.\n     * @param self The slice to split.\n     * @param needle The text to search for in `self`.\n     * @param token An output parameter to which the first token is written.\n     * @return `token`.\n     */\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n        token._ptr = ptr;\n        token._len = self._len - (ptr - self._ptr);\n        if (ptr == self._ptr) {\n            // Not found\n            self._len = 0;\n        } else {\n            self._len -= token._len + needle._len;\n        }\n        return token;\n    }\n\n    /*\n     * @dev Splits the slice, setting `self` to everything before the last\n     *      occurrence of `needle`, and returning everything after it. If\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n     *      and the entirety of `self` is returned.\n     * @param self The slice to split.\n     * @param needle The text to search for in `self`.\n     * @return The part of `self` after the last occurrence of `delim`.\n     */\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n        rsplit(self, needle, token);\n    }\n\n    /*\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\n     * @param self The slice to search.\n     * @param needle The text to search for in `self`.\n     * @return The number of occurrences of `needle` found in `self`.\n     */\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n        while (ptr <= self._ptr + self._len) {\n            cnt++;\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n        }\n    }\n\n    /*\n     * @dev Returns True if `self` contains `needle`.\n     * @param self The slice to search.\n     * @param needle The text to search for in `self`.\n     * @return True if `needle` is found in `self`, false otherwise.\n     */\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n    }\n\n    /*\n     * @dev Returns a newly allocated string containing the concatenation of\n     *      `self` and `other`.\n     * @param self The first slice to concatenate.\n     * @param other The second slice to concatenate.\n     * @return The concatenation of the two strings.\n     */\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n        string memory ret = new string(self._len + other._len);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n        memcpy(retptr, self._ptr, self._len);\n        memcpy(retptr + self._len, other._ptr, other._len);\n        return ret;\n    }\n\n    /*\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\n     *      newly allocated string.\n     * @param self The delimiter to use.\n     * @param parts A list of slices to join.\n     * @return A newly allocated string containing all the slices in `parts`,\n     *         joined with `self`.\n     */\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n        if (parts.length == 0)\n            return \"\";\n\n        uint length = self._len * (parts.length - 1);\n        for(uint i = 0; i < parts.length; i++)\n            length += parts[i]._len;\n\n        string memory ret = new string(length);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n\n        for(uint i = 0; i < parts.length; i++) {\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n            retptr += parts[i]._len;\n            if (i < parts.length - 1) {\n                memcpy(retptr, self._ptr, self._len);\n                retptr += self._len;\n            }\n        }\n\n        return ret;\n    }\n}\n"},"node_modules/erc7579/src/interfaces/IERC7579Module.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\nuint256 constant VALIDATION_SUCCESS = 0;\nuint256 constant VALIDATION_FAILED = 1;\n\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\nuint256 constant MODULE_TYPE_FALLBACK = 3;\nuint256 constant MODULE_TYPE_HOOK = 4;\n\ninterface IModule {\n    error AlreadyInitialized(address smartAccount);\n    error NotInitialized(address smartAccount);\n\n    /**\n     * @dev This function is called by the smart account during installation of the module\n     * @param data arbitrary data that may be required on the module during `onInstall`\n     * initialization\n     *\n     * MUST revert on error (i.e. if module is already enabled)\n     */\n    function onInstall(bytes calldata data) external;\n\n    /**\n     * @dev This function is called by the smart account during uninstallation of the module\n     * @param data arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization\n     *\n     * MUST revert on error\n     */\n    function onUninstall(bytes calldata data) external;\n\n    /**\n     * @dev Returns boolean value if module is a certain type\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *\n     * MUST return true if the module is of the given type and false otherwise\n     */\n    function isModuleType(uint256 moduleTypeId) external view returns (bool);\n\n    /**\n     * @dev Returns if the module was already initialized for a provided smartaccount\n     */\n    function isInitialized(address smartAccount) external view returns (bool);\n}\n\ninterface IValidator is IModule {\n    error InvalidTargetAddress(address target);\n\n    /**\n     * @dev Validates a transaction on behalf of the account.\n     *         This function is intended to be called by the MSA during the ERC-4337 validaton phase\n     *         Note: solely relying on bytes32 hash and signature is not suffcient for some\n     * validation implementations (i.e. SessionKeys often need access to userOp.calldata)\n     * @param userOp The user operation to be validated. The userOp MUST NOT contain any metadata.\n     * The MSA MUST clean up the userOp before sending it to the validator.\n     * @param userOpHash The hash of the user operation to be validated\n     * @return return value according to ERC-4337\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        returns (uint256);\n\n    /**\n     * Validator can be used for ERC-1271 validation\n     */\n    function isValidSignatureWithSender(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes4);\n}\n\ninterface IExecutor is IModule { }\n\ninterface IHook is IModule {\n    function preCheck(\n        address msgSender,\n        uint256 msgValue,\n        bytes calldata msgData\n    )\n        external\n        returns (bytes memory hookData);\n\n    function postCheck(bytes calldata hookData) external;\n}\n\ninterface IFallback is IModule { }\n"},"node_modules/erc7579/src/MSAFactory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport { LibClone } from \"solady/utils/LibClone.sol\";\nimport { IMSA } from \"./interfaces/IMSA.sol\";\n\ncontract MSAFactory {\n    address public immutable implementation;\n\n    constructor(address _msaImplementation) {\n        implementation = _msaImplementation;\n    }\n\n    function createAccount(\n        bytes32 salt,\n        bytes calldata initCode\n    )\n        public\n        payable\n        virtual\n        returns (address)\n    {\n        bytes32 _salt = _getSalt(salt, initCode);\n        (bool alreadyDeployed, address account) =\n            LibClone.createDeterministicERC1967(msg.value, implementation, _salt);\n\n        if (!alreadyDeployed) {\n            IMSA(account).initializeAccount(initCode);\n        }\n        return account;\n    }\n\n    function getAddress(\n        bytes32 salt,\n        bytes calldata initcode\n    )\n        public\n        view\n        virtual\n        returns (address)\n    {\n        bytes32 _salt = _getSalt(salt, initcode);\n        return LibClone.predictDeterministicAddressERC1967(implementation, _salt, address(this));\n    }\n\n    function _getSalt(\n        bytes32 _salt,\n        bytes calldata initCode\n    )\n        public\n        pure\n        virtual\n        returns (bytes32 salt)\n    {\n        salt = keccak256(abi.encodePacked(_salt, initCode));\n    }\n}\n"},"node_modules/erc7579/src/MSAAdvanced.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"./lib/ModeLib.sol\";\nimport { ExecutionLib } from \"./lib/ExecutionLib.sol\";\nimport { ExecutionHelper } from \"./core/ExecutionHelper.sol\";\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\nimport \"./interfaces/IERC7579Module.sol\";\nimport { IERC7579Account } from \"./interfaces/IERC7579Account.sol\";\nimport { IMSA } from \"./interfaces/IMSA.sol\";\nimport { ModuleManager } from \"./core/ModuleManager.sol\";\nimport { HookManager } from \"./core/HookManager.sol\";\nimport { RegistryAdapter } from \"./core/RegistryAdapter.sol\";\n\n/**\n * @author zeroknots.eth | rhinestone.wtf\n * Reference implementation of a very simple ERC7579 Account.\n * This account implements CallType: SINGLE, BATCH and DELEGATECALL.\n * This account implements ExecType: DEFAULT and TRY.\n * Hook support is implemented\n */\ncontract MSAAdvanced is IMSA, ExecutionHelper, ModuleManager, HookManager, RegistryAdapter {\n    using ExecutionLib for bytes;\n    using ModeLib for ModeCode;\n\n    /**\n     * @inheritdoc IERC7579Account\n     * @dev this function is only callable by the entry point or the account itself\n     * @dev this function demonstrates how to implement\n     * CallType SINGLE and BATCH and ExecType DEFAULT and TRY\n     * @dev this function demonstrates how to implement hook support (modifier)\n     */\n    function execute(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        payable\n        onlyEntryPointOrSelf\n        withHook\n    {\n        (CallType callType, ExecType execType,,) = mode.decode();\n\n        // check if calltype is batch or single\n        if (callType == CALLTYPE_BATCH) {\n            // destructure executionCallData according to batched exec\n            Execution[] calldata executions = executionCalldata.decodeBatch();\n            // check if execType is revert or try\n            if (execType == EXECTYPE_DEFAULT) _execute(executions);\n            else if (execType == EXECTYPE_TRY) _tryExecute(executions);\n            else revert UnsupportedExecType(execType);\n        } else if (callType == CALLTYPE_SINGLE) {\n            // destructure executionCallData according to single exec\n            (address target, uint256 value, bytes calldata callData) =\n                executionCalldata.decodeSingle();\n            // check if execType is revert or try\n            if (execType == EXECTYPE_DEFAULT) _execute(target, value, callData);\n            // TODO: implement event emission for tryExecute singleCall\n            else if (execType == EXECTYPE_TRY) _tryExecute(target, value, callData);\n            else revert UnsupportedExecType(execType);\n        } else if (callType == CALLTYPE_DELEGATECALL) {\n            // destructure executionCallData according to single exec\n            address delegate = address(uint160(bytes20(executionCalldata[0:20])));\n            bytes calldata callData = executionCalldata[20:];\n            // check if execType is revert or try\n            if (execType == EXECTYPE_DEFAULT) _executeDelegatecall(delegate, callData);\n            else if (execType == EXECTYPE_TRY) _tryExecuteDelegatecall(delegate, callData);\n            else revert UnsupportedExecType(execType);\n        } else {\n            revert UnsupportedCallType(callType);\n        }\n    }\n\n    /**\n     * @inheritdoc IERC7579Account\n     * @dev this function is only callable by an installed executor module\n     * @dev this function demonstrates how to implement\n     * CallType SINGLE and BATCH and ExecType DEFAULT and TRY\n     * @dev this function demonstrates how to implement hook support (modifier)\n     */\n    function executeFromExecutor(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        payable\n        onlyExecutorModule\n        withHook\n        withRegistry(msg.sender, MODULE_TYPE_EXECUTOR)\n        returns (\n            bytes[] memory returnData // TODO returnData is not used\n        )\n    {\n        (CallType callType, ExecType execType,,) = mode.decode();\n\n        // check if calltype is batch or single\n        if (callType == CALLTYPE_BATCH) {\n            // destructure executionCallData according to batched exec\n            Execution[] calldata executions = executionCalldata.decodeBatch();\n            // check if execType is revert or try\n            if (execType == EXECTYPE_DEFAULT) returnData = _execute(executions);\n            else if (execType == EXECTYPE_TRY) returnData = _tryExecute(executions);\n            else revert UnsupportedExecType(execType);\n        } else if (callType == CALLTYPE_SINGLE) {\n            // destructure executionCallData according to single exec\n            (address target, uint256 value, bytes calldata callData) =\n                executionCalldata.decodeSingle();\n            returnData = new bytes[](1);\n            bool success;\n            // check if execType is revert or try\n            if (execType == EXECTYPE_DEFAULT) {\n                returnData[0] = _execute(target, value, callData);\n            }\n            // TODO: implement event emission for tryExecute singleCall\n            else if (execType == EXECTYPE_TRY) {\n                (success, returnData[0]) = _tryExecute(target, value, callData);\n                if (!success) emit TryExecuteUnsuccessful(0, returnData[0]);\n            } else {\n                revert UnsupportedExecType(execType);\n            }\n        } else if (callType == CALLTYPE_DELEGATECALL) {\n            // destructure executionCallData according to single exec\n            address delegate = address(uint160(bytes20(executionCalldata[0:20])));\n            bytes calldata callData = executionCalldata[20:];\n            // check if execType is revert or try\n            if (execType == EXECTYPE_DEFAULT) _executeDelegatecall(delegate, callData);\n            else if (execType == EXECTYPE_TRY) _tryExecuteDelegatecall(delegate, callData);\n            else revert UnsupportedExecType(execType);\n        } else {\n            revert UnsupportedCallType(callType);\n        }\n    }\n\n    /**\n     * @dev ERC-4337 executeUserOp according to ERC-4337 v0.7\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\n     *      The implementation of the function is OPTIONAL\n     *\n     * @param userOp PackedUserOperation struct (see ERC-4337 v0.7+)\n     */\n    function executeUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        payable\n        onlyEntryPoint\n    {\n        bytes calldata callData = userOp.callData[4:];\n        (bool success,) = address(this).delegatecall(callData);\n        if (!success) revert ExecutionFailed();\n    }\n\n    /**\n     * @inheritdoc IERC7579Account\n     */\n    function installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    )\n        external\n        payable\n        onlyEntryPointOrSelf\n        withHook\n        withRegistry(module, moduleTypeId)\n    {\n        if (!IModule(module).isModuleType(moduleTypeId)) revert MismatchModuleTypeId(moduleTypeId);\n\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) _installValidator(module, initData);\n        else if (moduleTypeId == MODULE_TYPE_EXECUTOR) _installExecutor(module, initData);\n        else if (moduleTypeId == MODULE_TYPE_FALLBACK) _installFallbackHandler(module, initData);\n        else if (moduleTypeId == MODULE_TYPE_HOOK) _installHook(module, initData);\n        else revert UnsupportedModuleType(moduleTypeId);\n        emit ModuleInstalled(moduleTypeId, module);\n    }\n\n    /**\n     * @inheritdoc IERC7579Account\n     */\n    function uninstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata deInitData\n    )\n        external\n        payable\n        onlyEntryPointOrSelf\n        withHook\n    {\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\n            _uninstallValidator(module, deInitData);\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\n            _uninstallExecutor(module, deInitData);\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            _uninstallFallbackHandler(module, deInitData);\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\n            _uninstallHook(module, deInitData);\n        } else {\n            revert UnsupportedModuleType(moduleTypeId);\n        }\n        emit ModuleUninstalled(moduleTypeId, module);\n    }\n\n    /**\n     * @dev ERC-4337 validateUserOp according to ERC-4337 v0.7\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * this validation function should decode / sload the validator module to validate the userOp\n     * and call it.\n     *\n     * @dev MSA MUST implement this function signature.\n     * @param userOp PackedUserOperation struct (see ERC-4337 v0.7+)\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    )\n        external\n        payable\n        virtual\n        onlyEntryPoint\n        payPrefund(missingAccountFunds)\n        returns (uint256 validSignature)\n    {\n        address validator;\n        // @notice validator encoding in nonce is just an example!\n        // @notice this is not part of the standard!\n        // Account Vendors may choose any other way to implement validator selection\n        uint256 nonce = userOp.nonce;\n        assembly {\n            validator := shr(96, nonce)\n        }\n\n        // check if validator is enabled. If not terminate the validation phase.\n        if (!_isValidatorInstalled(validator)) return VALIDATION_FAILED;\n\n        // bubble up the return value of the validator module\n        validSignature = IValidator(validator).validateUserOp(userOp, userOpHash);\n    }\n\n    /**\n     * @dev ERC-1271 isValidSignature\n     *         This function is intended to be used to validate a smart account signature\n     * and may forward the call to a validator module\n     *\n     * @param hash The hash of the data that is signed\n     * @param data The data that is signed\n     */\n    function isValidSignature(\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        virtual\n        override\n        returns (bytes4)\n    {\n        address validator = address(bytes20(data[0:20]));\n        if (!_isValidatorInstalled(validator)) revert InvalidModule(validator);\n        return IValidator(validator).isValidSignatureWithSender(msg.sender, hash, data[20:]);\n    }\n\n    /**\n     * @inheritdoc IERC7579Account\n     */\n    function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    )\n        external\n        view\n        override\n        returns (bool)\n    {\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\n            return _isValidatorInstalled(module);\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\n            return _isExecutorInstalled(module);\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            return _isFallbackHandlerInstalled(abi.decode(additionalContext, (bytes4)), module);\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\n            return _isHookInstalled(module);\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @inheritdoc IERC7579Account\n     */\n    function accountId() external view virtual override returns (string memory) {\n        // vendor.flavour.SemVer\n        return \"uMSA.advanced/withHook.v0.1\";\n    }\n\n    /**\n     * @inheritdoc IERC7579Account\n     */\n    function supportsExecutionMode(ModeCode mode)\n        external\n        view\n        virtual\n        override\n        returns (bool isSupported)\n    {\n        (CallType callType, ExecType execType,,) = mode.decode();\n        if (callType == CALLTYPE_BATCH) isSupported = true;\n        else if (callType == CALLTYPE_SINGLE) isSupported = true;\n        else if (callType == CALLTYPE_DELEGATECALL) isSupported = true;\n        // if callType is not single, batch or delegatecall return false\n        else return false;\n\n        if (execType == EXECTYPE_DEFAULT) isSupported = true;\n        else if (execType == EXECTYPE_TRY) isSupported = true;\n        // if execType is not default or try, return false\n        else return false;\n    }\n\n    /**\n     * @inheritdoc IERC7579Account\n     */\n    function supportsModule(uint256 modulTypeId) external view virtual override returns (bool) {\n        if (modulTypeId == MODULE_TYPE_VALIDATOR) return true;\n        else if (modulTypeId == MODULE_TYPE_EXECUTOR) return true;\n        else if (modulTypeId == MODULE_TYPE_FALLBACK) return true;\n        else if (modulTypeId == MODULE_TYPE_HOOK) return true;\n        else return false;\n    }\n\n    /**\n     * @dev Initializes the account. Function might be called directly, or by a Factory\n     * @param data. encoded data that can be used during the initialization phase\n     */\n    function initializeAccount(bytes calldata data) public payable virtual {\n        // checks if already initialized and reverts before setting the state to initialized\n        _initModuleManager();\n\n        // this is just implemented for demonstration purposes. You can use any other initialization\n        // logic here.\n        (address bootstrap, bytes memory bootstrapCall) = abi.decode(data, (address, bytes));\n        (bool success,) = bootstrap.delegatecall(bootstrapCall);\n        if (!success) revert();\n    }\n}\n"},"node_modules/erc7579/src/lib/ExecutionLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { Execution } from \"../interfaces/IERC7579Account.sol\";\n\n/**\n * Helper Library for decoding Execution calldata\n * malloc for memory allocation is bad for gas. use this assembly instead\n */\nlibrary ExecutionLib {\n    function decodeBatch(bytes calldata callData)\n        internal\n        pure\n        returns (Execution[] calldata executionBatch)\n    {\n        /*\n         * Batch Call Calldata Layout\n         * Offset (in bytes)    | Length (in bytes) | Contents\n         * 0x0                  | 0x4               | bytes4 function selector\n        *  0x4                  | -                 |\n        abi.encode(IERC7579Execution.Execution[])\n         */\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            let dataPointer := add(callData.offset, calldataload(callData.offset))\n\n            // Extract the ERC7579 Executions\n            executionBatch.offset := add(dataPointer, 32)\n            executionBatch.length := calldataload(dataPointer)\n        }\n    }\n\n    function encodeBatch(Execution[] memory executions)\n        internal\n        pure\n        returns (bytes memory callData)\n    {\n        callData = abi.encode(executions);\n    }\n\n    function decodeSingle(bytes calldata executionCalldata)\n        internal\n        pure\n        returns (address target, uint256 value, bytes calldata callData)\n    {\n        target = address(bytes20(executionCalldata[0:20]));\n        value = uint256(bytes32(executionCalldata[20:52]));\n        callData = executionCalldata[52:];\n    }\n\n    function encodeSingle(\n        address target,\n        uint256 value,\n        bytes memory callData\n    )\n        internal\n        pure\n        returns (bytes memory userOpCalldata)\n    {\n        userOpCalldata = abi.encodePacked(target, value, callData);\n    }\n}\n"},"node_modules/erc7579/src/utils/Bootstrap.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport \"../core/ModuleManager.sol\";\nimport \"../core/HookManager.sol\";\n\nimport \"../interfaces/IERC7579Module.sol\";\n\nstruct BootstrapConfig {\n    address module;\n    bytes data;\n}\n\ncontract Bootstrap is ModuleManager, HookManager {\n    function singleInitMSA(IModule validator, bytes calldata data) external {\n        // init validator\n        _installValidator(address(validator), data);\n    }\n\n    /**\n     * This function is intended to be called by the MSA with a delegatecall.\n     * Make sure that the MSA already initilazed the linked lists in the ModuleManager prior to\n     * calling this function\n     */\n    function initMSA(\n        BootstrapConfig[] calldata $valdiators,\n        BootstrapConfig[] calldata $executors,\n        BootstrapConfig calldata _hook,\n        BootstrapConfig[] calldata _fallbacks\n    )\n        external\n    {\n        // init validators\n        for (uint256 i; i < $valdiators.length; i++) {\n            _installValidator($valdiators[i].module, $valdiators[i].data);\n        }\n\n        // init executors\n        for (uint256 i; i < $executors.length; i++) {\n            if ($executors[i].module == address(0)) continue;\n            _installExecutor($executors[i].module, $executors[i].data);\n        }\n\n        // init hook\n        if (_hook.module != address(0)) {\n            _installHook(_hook.module, _hook.data);\n        }\n\n        // init fallback\n        for (uint256 i; i < _fallbacks.length; i++) {\n            if (_fallbacks[i].module == address(0)) continue;\n            _installFallbackHandler(_fallbacks[i].module, _fallbacks[i].data);\n        }\n    }\n\n    function _getInitMSACalldata(\n        BootstrapConfig[] calldata $valdiators,\n        BootstrapConfig[] calldata $executors,\n        BootstrapConfig calldata _hook,\n        BootstrapConfig[] calldata _fallbacks\n    )\n        external\n        view\n        returns (bytes memory init)\n    {\n        init = abi.encode(\n            address(this),\n            abi.encodeCall(this.initMSA, ($valdiators, $executors, _hook, _fallbacks))\n        );\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/PackedUserOperation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor/\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    bytes32 accountGasLimits;\n    uint256 preVerificationGas;\n    bytes32 gasFees;\n    bytes paymasterAndData;\n    bytes signature;\n}\n"},"node_modules/solady/src/utils/LibClone.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Minimal proxy library.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\n/// @author Minimal proxy by 0age (https://github.com/0age)\n/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\n/// @author Minimal ERC1967 proxy by jtriley-eth (https://github.com/jtriley-eth/minimum-viable-proxy)\n///\n/// @dev Minimal proxy:\n/// Although the sw0nt pattern saves 5 gas over the ERC1167 pattern during runtime,\n/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\n/// which saves 4 gas over the ERC1167 pattern during runtime, and has the smallest bytecode.\n/// - Automatically verified on Etherscan.\n///\n/// @dev Minimal proxy (PUSH0 variant):\n/// This is a new minimal proxy that uses the PUSH0 opcode introduced during Shanghai.\n/// It is optimized first for minimal runtime gas, then for minimal bytecode.\n/// The PUSH0 clone functions are intentionally postfixed with a jarring \"_PUSH0\" as\n/// many EVM chains may not support the PUSH0 opcode in the early months after Shanghai.\n/// Please use with caution.\n/// - Automatically verified on Etherscan.\n///\n/// @dev Clones with immutable args (CWIA):\n/// The implementation of CWIA here is does NOT append the immutable args into the calldata\n/// passed into delegatecall. It is simply an ERC1167 minimal proxy with the immutable arguments\n/// appended to the back of the runtime bytecode.\n/// - Uses the identity precompile (0x4) to copy args during deployment.\n///\n/// @dev Minimal ERC1967 proxy:\n/// An minimal ERC1967 proxy, intended to be upgraded with UUPS.\n/// This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\n/// - Automatically verified on Etherscan.\n///\n/// @dev Minimal ERC1967 proxy with immutable args:\n/// - Uses the identity precompile (0x4) to copy args during deployment.\n/// - Automatically verified on Etherscan.\n///\n/// @dev ERC1967I proxy:\n/// An variant of the minimal ERC1967 proxy, with a special code path that activates\n/// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the\n/// `implementation` address. The returned implementation is guaranteed to be valid if the\n/// keccak256 of the proxy's code is equal to `ERC1967I_CODE_HASH`.\n///\n/// @dev ERC1967I proxy with immutable args:\n/// An variant of the minimal ERC1967 proxy, with a special code path that activates\n/// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the\n/// - Uses the identity precompile (0x4) to copy args during deployment.\n///\n/// @dev Minimal ERC1967 beacon proxy:\n/// A minimal beacon proxy, intended to be upgraded with an upgradable beacon.\n/// - Automatically verified on Etherscan.\n///\n/// @dev Minimal ERC1967 beacon proxy with immutable args:\n/// - Uses the identity precompile (0x4) to copy args during deployment.\n/// - Automatically verified on Etherscan.\n///\n/// @dev ERC1967I beacon proxy:\n/// An variant of the minimal ERC1967 beacon proxy, with a special code path that activates\n/// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the\n/// `implementation` address. The returned implementation is guaranteed to be valid if the\n/// keccak256 of the proxy's code is equal to `ERC1967I_CODE_HASH`.\n///\n/// @dev ERC1967I proxy with immutable args:\n/// An variant of the minimal ERC1967 beacon proxy, with a special code path that activates\n/// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the\n/// - Uses the identity precompile (0x4) to copy args during deployment.\nlibrary LibClone {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The keccak256 of deployed code for the clone proxy,\n    /// with the implementation set to `address(0)`.\n    bytes32 internal constant CLONE_CODE_HASH =\n        0x48db2cfdb2853fce0b464f1f93a1996469459df3ab6c812106074c4106a1eb1f;\n\n    /// @dev The keccak256 of deployed code for the PUSH0 proxy,\n    /// with the implementation set to `address(0)`.\n    bytes32 internal constant PUSH0_CLONE_CODE_HASH =\n        0x67bc6bde1b84d66e267c718ba44cf3928a615d29885537955cb43d44b3e789dc;\n\n    /// @dev The keccak256 of deployed code for the ERC-1167 CWIA proxy,\n    /// with the implementation set to `address(0)`.\n    bytes32 internal constant CWIA_CODE_HASH =\n        0x3cf92464268225a4513da40a34d967354684c32cd0edd67b5f668dfe3550e940;\n\n    /// @dev The keccak256 of the deployed code for the ERC1967 proxy.\n    bytes32 internal constant ERC1967_CODE_HASH =\n        0xaaa52c8cc8a0e3fd27ce756cc6b4e70c51423e9b597b11f32d3e49f8b1fc890d;\n\n    /// @dev The keccak256 of the deployed code for the ERC1967I proxy.\n    bytes32 internal constant ERC1967I_CODE_HASH =\n        0xce700223c0d4cea4583409accfc45adac4a093b3519998a9cbbe1504dadba6f7;\n\n    /// @dev The keccak256 of the deployed code for the ERC1967 beacon proxy.\n    bytes32 internal constant ERC1967_BEACON_PROXY_CODE_HASH =\n        0x14044459af17bc4f0f5aa2f658cb692add77d1302c29fe2aebab005eea9d1162;\n\n    /// @dev The keccak256 of the deployed code for the ERC1967 beacon proxy.\n    bytes32 internal constant ERC1967I_BEACON_PROXY_CODE_HASH =\n        0xf8c46d2793d5aa984eb827aeaba4b63aedcab80119212fce827309788735519a;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unable to deploy the clone.\n    error DeploymentFailed();\n\n    /// @dev The salt must start with either the zero address or `by`.\n    error SaltDoesNotStartWith();\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  MINIMAL PROXY OPERATIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a clone of `implementation`.\n    function clone(address implementation) internal returns (address instance) {\n        instance = clone(0, implementation);\n    }\n\n    /// @dev Deploys a clone of `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function clone(uint256 value, address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (44 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | 0                      |                       |\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create(value, 0x0c, 0x35)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\n    function cloneDeterministic(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\n    /// Deposits `value` ETH during deployment.\n    function cloneDeterministic(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create2(value, 0x0c, 0x35, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the clone of `implementation`.\n    function initCode(address implementation) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x40), 0x5af43d3d93803e602a57fd5bf30000000000000000000000)\n            mstore(add(c, 0x28), implementation)\n            mstore(add(c, 0x14), 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            mstore(c, 0x35) // Store the length.\n            mstore(0x40, add(c, 0x60)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`.\n    function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            hash := keccak256(0x0c, 0x35)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the address of the clone of `implementation`, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          MINIMAL PROXY OPERATIONS (PUSH0 VARIANT)          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a PUSH0 clone of `implementation`.\n    function clone_PUSH0(address implementation) internal returns (address instance) {\n        instance = clone_PUSH0(0, implementation);\n    }\n\n    /// @dev Deploys a PUSH0 clone of `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function clone_PUSH0(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 5f         | PUSH0             | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 5f         | PUSH0             | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (45 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 5f      | PUSH0          | 0                      |                       |\n             * 5f      | PUSH0          | 0 0                    |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0                |                       |\n             * 5f      | PUSH0          | 0 cds 0 0              |                       |\n             * 5f      | PUSH0          | 0 0 cds 0 0            |                       |\n             * 37      | CALLDATACOPY   | 0 0                    | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0                | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 cds 0 0              | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0         | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0     | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success            | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 rds success          | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 0 rds success        | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success                | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x29 | PUSH1 0x29     | 0x29 success           | [0..rds): returndata  |\n             * 57      | JUMPI          |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       |                        | [0..rds): returndata  |\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            instance := create(value, 0x0e, 0x36)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\n    function cloneDeterministic_PUSH0(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic_PUSH0(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\n    /// Deposits `value` ETH during deployment.\n    function cloneDeterministic_PUSH0(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            instance := create2(value, 0x0e, 0x36, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the PUSH0 clone of `implementation`.\n    function initCode_PUSH0(address implementation) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x40), 0x5af43d5f5f3e6029573d5ffd5b3d5ff300000000000000000000) // 16\n            mstore(add(c, 0x26), implementation) // 20\n            mstore(add(c, 0x12), 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            mstore(c, 0x36) // Store the length.\n            mstore(0x40, add(c, 0x60)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the PUSH0 clone of `implementation`.\n    function initCodeHash_PUSH0(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            hash := keccak256(0x0e, 0x36)\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the address of the PUSH0 clone of `implementation`, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress_PUSH0(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHash_PUSH0(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*           CLONES WITH IMMUTABLE ARGS OPERATIONS            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `args`.\n    function clone(address implementation, bytes memory args) internal returns (address instance) {\n        instance = clone(0, implementation, args);\n    }\n\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `args`.\n    /// Deposits `value` ETH during deployment.\n    function clone(uint256 value, address implementation, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------+\n             * CREATION (10 bytes)                                                        |\n             * ---------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                        |\n             * ---------------------------------------------------------------------------|\n             * 61 runSize | PUSH2 runSize     | r         |                               |\n             * 3d         | RETURNDATASIZE    | 0 r       |                               |\n             * 81         | DUP2              | r 0 r     |                               |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                               |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                               |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code    |\n             * f3         | RETURN            |           | [0..runSize): runtime code    |\n             * ---------------------------------------------------------------------------|\n             * RUNTIME (45 bytes + extraLength)                                           |\n             * ---------------------------------------------------------------------------|\n             * Opcode   | Mnemonic       | Stack                  | Memory                |\n             * ---------------------------------------------------------------------------|\n             *                                                                            |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds                    |                       |\n             * 3d       | RETURNDATASIZE | 0 cds                  |                       |\n             * 3d       | RETURNDATASIZE | 0 0 cds                |                       |\n             * 37       | CALLDATACOPY   |                        | [0..cds): calldata    |\n             *                                                                            |\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | 0                      | [0..cds): calldata    |\n             * 3d       | RETURNDATASIZE | 0 0                    | [0..cds): calldata    |\n             * 3d       | RETURNDATASIZE | 0 0 0                  | [0..cds): calldata    |\n             * 36       | CALLDATASIZE   | cds 0 0 0              | [0..cds): calldata    |\n             * 3d       | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\n             * 73 addr  | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\n             * 5a       | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\n             * f4       | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\n             *                                                                            |\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | rds success 0          | [0..cds): calldata    |\n             * 82       | DUP3           | 0 rds success 0         | [0..cds): calldata   |\n             * 80       | DUP1           | 0 0 rds success 0      | [0..cds): calldata    |\n             * 3e       | RETURNDATACOPY | success 0              | [0..rds): returndata  |\n             * 90       | SWAP1          | 0 success              | [0..rds): returndata  |\n             * 3d       | RETURNDATASIZE | rds 0 success          | [0..rds): returndata  |\n             * 91       | SWAP2          | success 0 rds          | [0..rds): returndata  |\n             *                                                                            |\n             * 60 0x2b  | PUSH1 0x2b     | 0x2b success 0 rds     | [0..rds): returndata  |\n             * 57       | JUMPI          | 0 rds                  | [0..rds): returndata  |\n             *                                                                            |\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd       | REVERT         |                        | [0..rds): returndata  |\n             *                                                                            |\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b       | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\n             * f3       | RETURN         |                        | [0..rds): returndata  |\n             * ---------------------------------------------------------------------------+\n             */\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x43), n))\n            mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0xfe61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(0x88, n)))\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            instance := create(value, add(m, add(0x0b, lt(n, 0xffd3))), add(n, 0x37))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n    // 0,0x5e17b14ADd6c386305A32928F985b29bbA34Eff5, hex\"01020304\"\n    /// @dev Deploys a deterministic clone of `implementation`\n    /// with immutable arguments encoded in `args` and `salt`.\n\n    function cloneDeterministic(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic(0, implementation, args, salt);\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation`\n    /// with immutable arguments encoded in `args` and `salt`.\n    function cloneDeterministic(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x43), n))\n            mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0xfe61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(0x88, n)))\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            instance := create2(value, add(m, add(0x0b, lt(n, 0xffd3))), add(n, 0x37), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`\n    /// using immutable arguments encoded in `args`.\n    function initCode(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffd2))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x57), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x37), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(c, 0x28), implementation)\n            mstore(add(c, 0x14), add(0x61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(0x88, n)))\n            mstore(c, add(0x37, n)) // Store the length.\n            mstore(add(c, add(n, 0x57)), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(c, add(n, 0x77))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`\n    /// using immutable arguments encoded in `args`.\n    function initCodeHash(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffd2))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x43), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0x61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(0x88, n)))\n            hash := keccak256(add(m, 0x0c), add(n, 0x37))\n        }\n    }\n\n    /// @dev Returns the address of the clone of\n    /// `implementation` using immutable arguments encoded in `args`, with `salt`, by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(\n        address implementation,\n        bytes memory data,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHash(implementation, data);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /// @dev Equivalent to `argsOnClone(instance, 0, 2 ** 256 - 1)`.\n    function argsOnClone(address instance) internal view returns (bytes memory args) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, sub(extcodesize(instance), 0x2d)) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x2d, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }\n\n    /// @dev Equivalent to `argsOnClone(instance, start, 2 ** 256 - 1)`.\n    function argsOnClone(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := sub(extcodesize(instance), 0x2d)\n            extcodecopy(instance, add(args, 0x20), add(start, 0x2d), add(n, 0x20))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(args, add(0x40, mload(args)))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns a slice of the immutable arguments on `instance` from `start` to `end`.\n    /// `start` and `end` will be clamped to the range `[0, args.length]`.\n    /// The `instance` MUST be deployed via the clone with immutable args functions.\n    /// Otherwise, the behavior is undefined.\n    /// Out-of-gas reverts if `instance` does not have any code.\n    function argsOnClone(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x0d), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x2d)\n                returndatacopy(returndatasize(), returndatasize(), shr(64, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              MINIMAL ERC1967 PROXY OPERATIONS              */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: The ERC1967 proxy here is intended to be upgraded with UUPS.\n    // This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\n\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\n    function deployERC1967(address implementation) internal returns (address instance) {\n        instance = deployERC1967(0, implementation);\n    }\n\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (61 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x38    | PUSH1 0x38     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            instance := create(value, 0x21, 0x5f)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    function deployDeterministicERC1967(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            instance := create2(value, 0x21, 0x5f, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967(address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967(0, implementation, salt);\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x21, 0x5f))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x21, 0x5f, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation`.\n    function initCodeERC1967(address implementation) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x60), 0x3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f300)\n            mstore(add(c, 0x40), 0x55f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076cc)\n            mstore(add(c, 0x20), or(shl(24, implementation), 0x600951))\n            mstore(add(c, 0x09), 0x603d3d8160223d3973)\n            mstore(c, 0x5f) // Store the length.\n            mstore(0x40, add(c, 0x80)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation`.\n    function initCodeHashERC1967(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            hash := keccak256(0x21, 0x5f)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967 proxy of `implementation`, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*    MINIMAL ERC1967 PROXY WITH IMMUTABLE ARGS OPERATIONS    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation` and `args`.\n    function deployERC1967(address implementation, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        instance = deployERC1967(0, implementation, args);\n    }\n\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation` and `args`.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967(uint256 value, address implementation, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x60), n))\n            mstore(add(m, 0x40), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(m, 0x20), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x16, 0x6009)\n            mstore(0x14, implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            mstore(gt(n, 0xffc2), add(0xfe61003d3d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            instance := create(value, m, add(n, 0x60))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation`, `args` and `salt`.\n    function deployDeterministicERC1967(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967(0, implementation, args, salt);\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation`, `args` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x60), n))\n            mstore(add(m, 0x40), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(m, 0x20), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x16, 0x6009)\n            mstore(0x14, implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            mstore(gt(n, 0xffc2), add(0xfe61003d3d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            instance := create2(value, m, add(n, 0x60), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation`, `args` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967(0, implementation, args, salt);\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation`, `args` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x60), n))\n            mstore(add(m, 0x40), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(m, 0x20), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x16, 0x6009)\n            mstore(0x14, implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            mstore(gt(n, 0xffc2), add(0xfe61003d3d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(m, add(n, 0x60)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, m, add(n, 0x60), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation` and `args`.\n    function initCodeERC1967(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffc2))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x80), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x60), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(c, 0x40), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(add(c, 0x20), 0x6009)\n            mstore(add(c, 0x1e), implementation)\n            mstore(add(c, 0x0a), add(0x61003d3d8160233d3973, shl(56, n)))\n            mstore(c, add(n, 0x60)) // Store the length.\n            mstore(add(c, add(n, 0x80)), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(c, add(n, 0xa0))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation` and `args`.\n    function initCodeHashERC1967(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffc2))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x60), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(m, 0x40), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(m, 0x20), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x16, 0x6009)\n            mstore(0x14, implementation)\n            mstore(0x00, add(0x61003d3d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            hash := keccak256(m, add(n, 0x60))\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967 proxy of `implementation`, `args`, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967(implementation, args);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /// @dev Equivalent to `argsOnERC1967(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967(address instance) internal view returns (bytes memory args) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, sub(extcodesize(instance), 0x3d)) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x3d, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }\n\n    /// @dev Equivalent to `argsOnERC1967(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := sub(extcodesize(instance), 0x3d)\n            extcodecopy(instance, add(args, 0x20), add(start, 0x3d), add(n, 0x20))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(args, add(0x40, mload(args)))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns a slice of the immutable arguments on `instance` from `start` to `end`.\n    /// `start` and `end` will be clamped to the range `[0, args.length]`.\n    /// The `instance` MUST be deployed via the ERC1967 with immutable args functions.\n    /// Otherwise, the behavior is undefined.\n    /// Out-of-gas reverts if `instance` does not have any code.\n    function argsOnERC1967(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x1d), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x3d)\n                returndatacopy(returndatasize(), returndatasize(), shr(64, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                 ERC1967I PROXY OPERATIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: This proxy has a special code path that activates if `calldatasize() == 1`.\n    // This code path skips the delegatecall and directly returns the `implementation` address.\n    // The returned implementation is guaranteed to be valid if the keccak256 of the\n    // proxy's code is equal to `ERC1967I_CODE_HASH`.\n\n    /// @dev Deploys a ERC1967I proxy with `implementation`.\n    function deployERC1967I(address implementation) internal returns (address instance) {\n        instance = deployERC1967I(0, implementation);\n    }\n\n    /// @dev Deploys a ERC1967I proxy with `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967I(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (82 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: check calldatasize ::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 58         | PC             | 1 cds            |                                 |\n             * 14         | EQ             | eqs              |                                 |\n             * 60 0x43    | PUSH1 0x43     | dest eqs         |                                 |\n             * 57         | JUMPI          |                  |                                 |\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x3E    | PUSH1 0x3E     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: implementation , return :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  |                                 |\n             * 60 0x20    | PUSH1 0x20     | 32               |                                 |\n             * 60 0x0F    | PUSH1 0x0F     | o 32             |                                 |\n             * 3d         | RETURNDATASIZE | 0 o 32           |                                 |\n             * 39         | CODECOPY       |                  | [0..32): implementation slot    |\n             * 3d         | RETURNDATASIZE | 0                | [0..32): implementation slot    |\n             * 51         | MLOAD          | slot             | [0..32): implementation slot    |\n             * 54         | SLOAD          | impl             | [0..32): implementation slot    |\n             * 3d         | RETURNDATASIZE | 0 impl           | [0..32): implementation slot    |\n             * 52         | MSTORE         |                  | [0..32): implementation address |\n             * 59         | MSIZE          | 32               | [0..32): implementation address |\n             * 3d         | RETURNDATASIZE | 0 32             | [0..32): implementation address |\n             * f3         | RETURN         |                  | [0..32): implementation address |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            instance := create(value, 0x0c, 0x74)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.\n    function deployDeterministicERC1967I(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967I(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            instance := create2(value, 0x0c, 0x74, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967I(address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967I(0, implementation, salt);\n    }\n\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x0c, 0x74, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the initialization code of the ERC1967I proxy of `implementation`.\n    function initCodeERC1967I(address implementation) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x74), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(c, 0x54), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(c, 0x34), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(c, 0x1d), implementation)\n            mstore(add(c, 0x09), 0x60523d8160223d3973)\n            mstore(add(c, 0x94), 0)\n            mstore(c, 0x74) // Store the length.\n            mstore(0x40, add(c, 0xa0)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the ERC1967I proxy of `implementation`.\n    function initCodeHashERC1967I(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            hash := keccak256(0x0c, 0x74)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967I proxy of `implementation`, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967I(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967I(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*       ERC1967I PROXY WITH IMMUTABLE ARGS OPERATIONS        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a minimal ERC1967I proxy with `implementation` and `args`.\n    function deployERC1967I(address implementation, bytes memory args) internal returns (address) {\n        return deployERC1967I(0, implementation, args);\n    }\n\n    /// @dev Deploys a minimal ERC1967I proxy with `implementation` and `args`.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967I(uint256 value, address implementation, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n\n            mstore(add(m, 0x6b), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(m, 0x4b), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(m, 0x2b), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0xfe6100523d8160233d3973, shl(56, n)))\n\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            instance := create(value, add(m, add(0x15, lt(n, 0xffae))), add(0x75, n))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation`, `args`, and `salt`.\n    function deployDeterministicERC1967I(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967I(0, implementation, args, salt);\n    }\n\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation`,`args`,  and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967I(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n\n            mstore(add(m, 0x6b), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(m, 0x4b), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(m, 0x2b), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0xfe6100523d8160233d3973, shl(56, n)))\n\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            instance := create2(value, add(m, add(0x15, lt(n, 0xffae))), add(0x75, n), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation`, `args` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967I(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967I(0, implementation, args, salt);\n    }\n\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation`,`args` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967I(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x75), n))\n            mstore(add(m, 0x55), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(m, 0x35), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(m, 0x15), 0x5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x16, 0x600f)\n            mstore(0x14, implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            mstore(gt(n, 0xffad), add(0xfe6100523d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(m, add(n, 0x75)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, m, add(0x75, n), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the ERC1967I proxy of `implementation`and `args`.\n    function initCodeERC1967I(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffad))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x95), i), mload(add(add(args, 0x20), i)))\n            }\n\n            mstore(add(c, 0x75), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(c, 0x55), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(c, 0x35), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(c, 0x1e), implementation)\n            mstore(add(c, 0x0a), add(0x6100523d8160233d3973, shl(56, n)))\n            mstore(add(c, add(n, 0x95)), 0)\n            mstore(c, add(0x75, n)) // Store the length.\n            mstore(0x40, add(c, add(n, 0xb5))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the ERC1967I proxy of `implementation` and `args.\n    function initCodeHashERC1967I(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffad))\n\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x75), i), mload(add(add(args, 0x20), i)))\n            }\n\n            mstore(add(m, 0x55), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(m, 0x35), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(m, 0x15), 0x5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x16, 0x600f)\n            mstore(0x14, implementation)\n            mstore(0x00, add(0x6100523d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            hash := keccak256(m, add(0x75, n))\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967I proxy of `implementation`, 'args` with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967I(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967I(implementation, args);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /// @dev Equivalent to `argsOnERC1967I(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967I(address instance) internal view returns (bytes memory args) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, sub(extcodesize(instance), 0x52)) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x52, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }\n\n    /// @dev Equivalent to `argsOnERC1967I(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967I(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := sub(extcodesize(instance), 0x52)\n            extcodecopy(instance, add(args, 0x20), add(start, 0x52), add(n, 0x20))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns a slice of the immutable arguments on `instance` from `start` to `end`.\n    /// `start` and `end` will be clamped to the range `[0, args.length]`.\n    /// The `instance` MUST be deployed via the ERC1967 with immutable args functions.\n    /// Otherwise, the behavior is undefined.\n    /// Out-of-gas reverts if `instance` does not have any code.\n    function argsOnERC1967I(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x32), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x52)\n                returndatacopy(returndatasize(), returndatasize(), shr(64, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*            CONSTANT ERC1967 BOOTSTRAP OPERATIONS           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: This enables an ERC1967 proxy to be deployed at a deterministic address\n    // independent of the implementation:\n    // ```\n    //     address bootstrap = LibClone.constantERC1967Bootstrap();\n    //     address instance = LibClone.deployDeterministicERC1967(0, bootstrap, salt);\n    //     LibClone.bootstrapConstantERC1967(bootstrap, implementation);\n    // ```\n\n    /// @dev Deploys the constant ERC1967 bootstrap if it has not been deployed.\n    function constantERC1967Bootstrap() internal returns (address bootstrap) {\n        bootstrap = constantERC1967BootstrapAddress();\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(extcodesize(bootstrap)) {\n                mstore(0x20, 0x0894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc55)\n                mstore(0x00, 0x60258060093d393df358357f36)\n                if iszero(create2(0, 0x13, 0x2e, 0)) {\n                    mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the implementation address of the ERC1967 bootstrap for this contract.\n    function constantERC1967BootstrapAddress() internal view returns (address bootstrap) {\n        bytes32 hash = 0xfe1a42b9c571a6a8c083c94ac67b9cfd74e2582923426aa3b762e3431d717cd1;\n        bootstrap = predictDeterministicAddress(hash, bytes32(0), address(this));\n    }\n\n    /// @dev Replaces the implementation at `instance`.\n    function bootstrapERC1967(address instance, address implementation) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, shr(96, shl(96, implementation)))\n            if iszero(call(gas(), instance, 0, 0x00, 0x20, codesize(), 0x00)) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          MINIMAL ERC1967 BEACON PROXY OPERATIONS           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: If you use this proxy, you MUST make sure that the beacon is a\n    // valid ERC1967 beacon. This means that the beacon must always return a valid\n    // address upon a staticcall to `implementation()`, given sufficient gas.\n    // For performance, the deployment operations and the proxy assumes that the\n    // beacon is always valid and will NOT validate it.\n\n    /// @dev Deploys a minimal ERC1967 beacon proxy.\n    function deployERC1967BeaconProxy(address beacon) internal returns (address instance) {\n        instance = deployERC1967BeaconProxy(0, beacon);\n    }\n\n    /// @dev Deploys a minimal ERC1967 beacon proxy.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967BeaconProxy(uint256 value, address beacon)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 beac    | PUSH20 beac    | beac 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos beac 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot beac 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (82 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ~~~~~~~ beacon staticcall sub procedure ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 60 0x20       | PUSH1 0x20       | 32                          |                 |\n             * 36            | CALLDATASIZE     | cds 32                      |                 |\n             * 60 0x04       | PUSH1 0x04       | 4 cds 32                    |                 |\n             * 36            | CALLDATASIZE     | cds 4 cds 32                |                 |\n             * 63 0x5c60da1b | PUSH4 0x5c60da1b | 0x5c60da1b cds 4 cds 32     |                 |\n             * 60 0xe0       | PUSH1 0xe0       | 224 0x5c60da1b cds 4 cds 32 |                 |\n             * 1b            | SHL              | sel cds 4 cds 32            |                 |\n             * 36            | CALLDATASIZE     | cds sel cds 4 cds 32        |                 |\n             * 52            | MSTORE           | cds 4 cds 32                | sel             |\n             * 7f slot       | PUSH32 slot      | s cds 4 cds 32              | sel             |\n             * 54            | SLOAD            | beac cds 4 cds 32           | sel             |\n             * 5a            | GAS              | g beac cds 4 cds 32         | sel             |\n             * fa            | STATICCALL       | succ                        | impl            |\n             * 50            | POP              |                             | impl            |\n             * 36            | CALLDATASIZE     | cds                         | impl            |\n             * 51            | MLOAD            | impl                        | impl            |\n             * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 5a         | GAS            | g impl 0 cds 0 0 | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x4d    | PUSH1 0x4d     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create(value, 0x0c, 0x74)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `salt`.\n    function deployDeterministicERC1967BeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967BeaconProxy(0, beacon, salt);\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create2(value, 0x0c, 0x74, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967BeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967BeaconProxy(0, beacon, salt);\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x0c, 0x74, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the initialization code of the minimal ERC1967 beacon proxy.\n    function initCodeERC1967BeaconProxy(address beacon) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x74), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(c, 0x54), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(c, 0x34), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(c, 0x1d), beacon)\n            mstore(add(c, 0x09), 0x60523d8160223d3973)\n            mstore(add(c, 0x94), 0)\n            mstore(c, 0x74) // Store the length.\n            mstore(0x40, add(c, 0xa0)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the minimal ERC1967 beacon proxy.\n    function initCodeHashERC1967BeaconProxy(address beacon) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            hash := keccak256(0x0c, 0x74)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967 beacon proxy, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967BeaconProxy(\n        address beacon,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967BeaconProxy(beacon);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*    ERC1967 BEACON PROXY WITH IMMUTABLE ARGS OPERATIONS     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a minimal ERC1967 beacon proxy with `args`.\n    function deployERC1967BeaconProxy(address beacon, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        instance = deployERC1967BeaconProxy(0, beacon, args);\n    }\n\n    /// @dev Deploys a minimal ERC1967 beacon proxy with `args`.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967BeaconProxy(uint256 value, address beacon, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n            mstore(add(m, 0x6b), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(m, 0x4b), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(m, 0x2b), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            mstore(add(m, gt(n, 0xffad)), add(0xfe6100523d8160233d3973, shl(56, n)))\n            instance := create(value, add(m, 0x16), add(n, 0x75))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `args` and `salt`.\n    function deployDeterministicERC1967BeaconProxy(address beacon, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967BeaconProxy(0, beacon, args, salt);\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `args` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967BeaconProxy(\n        uint256 value,\n        address beacon,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n            mstore(add(m, 0x6b), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(m, 0x4b), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(m, 0x2b), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            mstore(add(m, gt(n, 0xffad)), add(0xfe6100523d8160233d3973, shl(56, n)))\n            instance := create2(value, add(m, 0x16), add(n, 0x75), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `args` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967BeaconProxy(address beacon, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967BeaconProxy(0, beacon, args, salt);\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `args` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967BeaconProxy(\n        uint256 value,\n        address beacon,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n            mstore(add(m, 0x6b), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(m, 0x4b), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(m, 0x2b), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            mstore(add(m, gt(n, 0xffad)), add(0xfe6100523d8160233d3973, shl(56, n)))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(add(m, 0x16), add(n, 0x75)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, add(m, 0x16), add(n, 0x75), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the minimal ERC1967 beacon proxy.\n    function initCodeERC1967BeaconProxy(address beacon, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffad))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x95), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x75), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(c, 0x55), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(c, 0x35), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(c, 0x1e), beacon)\n            mstore(add(c, 0x0a), add(0x6100523d8160233d3973, shl(56, n)))\n            mstore(c, add(n, 0x75)) // Store the length.\n            mstore(add(c, add(n, 0x95)), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(c, add(n, 0xb5))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the minimal ERC1967 beacon proxy with `args`.\n    function initCodeHashERC1967BeaconProxy(address beacon, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffad))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x8b), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(m, 0x6b), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(m, 0x4b), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(m, 0x2b), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(m, 0x14), beacon)\n            mstore(m, add(0x6100523d8160233d3973, shl(56, n)))\n            hash := keccak256(add(m, 0x16), add(n, 0x75))\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967 beacon proxy with `args`, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967BeaconProxy(\n        address beacon,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967BeaconProxy(beacon, args);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /// @dev Equivalent to `argsOnERC1967BeaconProxy(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967BeaconProxy(address instance) internal view returns (bytes memory args) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, sub(extcodesize(instance), 0x52)) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x52, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }\n\n    /// @dev Equivalent to `argsOnERC1967BeaconProxy(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967BeaconProxy(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := sub(extcodesize(instance), 0x52)\n            extcodecopy(instance, add(args, 0x20), add(start, 0x52), add(n, 0x20))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(args, add(0x40, mload(args)))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns a slice of the immutable arguments on `instance` from `start` to `end`.\n    /// `start` and `end` will be clamped to the range `[0, args.length]`.\n    /// The `instance` MUST be deployed via the ERC1967 beacon proxy with immutable args functions.\n    /// Otherwise, the behavior is undefined.\n    /// Out-of-gas reverts if `instance` does not have any code.\n    function argsOnERC1967BeaconProxy(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x32), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x52)\n                returndatacopy(returndatasize(), returndatasize(), shr(64, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              ERC1967I BEACON PROXY OPERATIONS              */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: This proxy has a special code path that activates if `calldatasize() == 1`.\n    // This code path skips the delegatecall and directly returns the `implementation` address.\n    // The returned implementation is guaranteed to be valid if the keccak256 of the\n    // proxy's code is equal to `ERC1967_BEACON_PROXY_CODE_HASH`.\n    //\n    // If you use this proxy, you MUST make sure that the beacon is a\n    // valid ERC1967 beacon. This means that the beacon must always return a valid\n    // address upon a staticcall to `implementation()`, given sufficient gas.\n    // For performance, the deployment operations and the proxy assumes that the\n    // beacon is always valid and will NOT validate it.\n\n    /// @dev Deploys a ERC1967I beacon proxy.\n    function deployERC1967IBeaconProxy(address beacon) internal returns (address instance) {\n        instance = deployERC1967IBeaconProxy(0, beacon);\n    }\n\n    /// @dev Deploys a ERC1967I beacon proxy.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967IBeaconProxy(uint256 value, address beacon)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 beac    | PUSH20 beac    | beac 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos beac 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot beac 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (87 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ~~~~~~~ beacon staticcall sub procedure ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 60 0x20       | PUSH1 0x20       | 32                          |                 |\n             * 36            | CALLDATASIZE     | cds 32                      |                 |\n             * 60 0x04       | PUSH1 0x04       | 4 cds 32                    |                 |\n             * 36            | CALLDATASIZE     | cds 4 cds 32                |                 |\n             * 63 0x5c60da1b | PUSH4 0x5c60da1b | 0x5c60da1b cds 4 cds 32     |                 |\n             * 60 0xe0       | PUSH1 0xe0       | 224 0x5c60da1b cds 4 cds 32 |                 |\n             * 1b            | SHL              | sel cds 4 cds 32            |                 |\n             * 36            | CALLDATASIZE     | cds sel cds 4 cds 32        |                 |\n             * 52            | MSTORE           | cds 4 cds 32                | sel             |\n             * 7f slot       | PUSH32 slot      | s cds 4 cds 32              | sel             |\n             * 54            | SLOAD            | beac cds 4 cds 32           | sel             |\n             * 5a            | GAS              | g beac cds 4 cds 32         | sel             |\n             * fa            | STATICCALL       | succ                        | impl            |\n             * ~~~~~~ check calldatasize ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 36            | CALLDATASIZE     | cds succ                    |                 |\n             * 14            | EQ               |                             | impl            |\n             * 60 0x52       | PUSH1 0x52       |                             | impl            |\n             * 57            | JUMPI            |                             | impl            |\n             * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 36            | CALLDATASIZE     | cds                         | impl            |\n             * 51            | MLOAD            | impl                        | impl            |\n             * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 5a         | GAS            | g impl 0 cds 0 0 | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 60 0x01    | PUSH1 0x01     | 1 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [1..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x52    | PUSH1 0x52     | dest succ        | [1..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [1..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [1..returndatasize): returndata |\n             * 60 0x01    | PUSH1 0x01     | 1 rds            | [1..returndatasize): returndata |\n             * fd         | REVERT         |                  | [1..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [1..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [1..returndatasize): returndata |\n             * 60 0x01    | PUSH1 0x01     | 1 rds            | [1..returndatasize): returndata |\n             * f3         | RETURN         |                  | [1..returndatasize): returndata |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(0x40, 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(0x04, or(shl(160, 0x60573d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create(value, 0x07, 0x79)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Deploys a deterministic ERC1967I beacon proxy with `salt`.\n    function deployDeterministicERC1967IBeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967IBeaconProxy(0, beacon, salt);\n    }\n\n    /// @dev Deploys a deterministic ERC1967I beacon proxy with `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967IBeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(0x40, 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(0x04, or(shl(160, 0x60573d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create2(value, 0x07, 0x79, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Creates a deterministic ERC1967I beacon proxy with `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967IBeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967IBeaconProxy(0, beacon, salt);\n    }\n\n    /// @dev Creates a deterministic ERC1967I beacon proxy with `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967IBeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(0x40, 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(0x04, or(shl(160, 0x60573d8160223d3973), shr(96, shl(96, beacon))))\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x07, 0x79))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x07, 0x79, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the initialization code of the ERC1967I beacon proxy.\n    function initCodeERC1967IBeaconProxy(address beacon) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x79), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(c, 0x59), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(c, 0x39), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(c, 0x1d), beacon)\n            mstore(add(c, 0x09), 0x60573d8160223d3973)\n            mstore(add(c, 0x99), 0)\n            mstore(c, 0x79) // Store the length.\n            mstore(0x40, add(c, 0xa0)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the ERC1967I beacon proxy.\n    function initCodeHashERC1967IBeaconProxy(address beacon) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(0x40, 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(0x04, or(shl(160, 0x60573d8160223d3973), shr(96, shl(96, beacon))))\n            hash := keccak256(0x07, 0x79)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967I beacon proxy, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967IBeaconProxy(\n        address beacon,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967IBeaconProxy(beacon);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*    ERC1967I BEACON PROXY WITH IMMUTABLE ARGS OPERATIONS    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a ERC1967I beacon proxy with `args.\n    function deployERC1967IBeaconProxy(address beacon, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        instance = deployERC1967IBeaconProxy(0, beacon, args);\n    }\n\n    /// @dev Deploys a ERC1967I beacon proxy with `args.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967IBeaconProxy(uint256 value, address beacon, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x90), n))\n            mstore(add(m, 0x70), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(m, 0x50), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(m, 0x30), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            mstore(add(m, gt(n, 0xffa8)), add(0xfe6100573d8160233d3973, shl(56, n)))\n            instance := create(value, add(m, 0x16), add(n, 0x7a))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Deploys a deterministic ERC1967I beacon proxy with `args` and `salt`.\n    function deployDeterministicERC1967IBeaconProxy(address beacon, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967IBeaconProxy(0, beacon, args, salt);\n    }\n\n    /// @dev Deploys a deterministic ERC1967I beacon proxy with `args` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967IBeaconProxy(\n        uint256 value,\n        address beacon,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x90), n))\n            mstore(add(m, 0x70), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(m, 0x50), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(m, 0x30), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            mstore(add(m, gt(n, 0xffa8)), add(0xfe6100573d8160233d3973, shl(56, n)))\n            instance := create2(value, add(m, 0x16), add(n, 0x7a), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Creates a deterministic ERC1967I beacon proxy with `args` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967IBeaconProxy(address beacon, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967IBeaconProxy(0, beacon, args, salt);\n    }\n\n    /// @dev Creates a deterministic ERC1967I beacon proxy with `args` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967IBeaconProxy(\n        uint256 value,\n        address beacon,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x90), n))\n            mstore(add(m, 0x70), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(m, 0x50), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(m, 0x30), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            mstore(add(m, gt(n, 0xffa8)), add(0xfe6100573d8160233d3973, shl(56, n)))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(add(m, 0x16), add(n, 0x7a)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, add(m, 0x16), add(n, 0x7a), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the ERC1967I beacon proxy with `args`.\n    function initCodeERC1967IBeaconProxy(address beacon, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffa8))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x9a), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x7a), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(c, 0x5a), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(c, 0x3a), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(c, 0x1e), beacon)\n            mstore(add(c, 0x0a), add(0x6100573d8160233d3973, shl(56, n)))\n            mstore(add(c, add(n, 0x9a)), 0)\n            mstore(c, add(n, 0x7a)) // Store the length.\n            mstore(0x40, add(c, add(n, 0xba))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the ERC1967I beacon proxy with `args`.\n    function initCodeHashERC1967IBeaconProxy(address beacon, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let c := mload(0x40) // Cache the free memory pointer.\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffa8))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x90), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x70), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(c, 0x50), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(c, 0x30), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(c, 0x14), beacon)\n            mstore(c, add(0x6100573d8160233d3973, shl(56, n)))\n            hash := keccak256(add(c, 0x16), add(n, 0x7a))\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967I beacon proxy, with  `args` and salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967IBeaconProxy(\n        address beacon,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967IBeaconProxy(beacon, args);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /// @dev Equivalent to `argsOnERC1967IBeaconProxy(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967IBeaconProxy(address instance)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, sub(extcodesize(instance), 0x57)) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x57, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }\n\n    /// @dev Equivalent to `argsOnERC1967IBeaconProxy(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967IBeaconProxy(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := sub(extcodesize(instance), 0x57)\n            extcodecopy(instance, add(args, 0x20), add(start, 0x57), add(n, 0x20))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(args, add(0x40, mload(args)))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns a slice of the immutable arguments on `instance` from `start` to `end`.\n    /// `start` and `end` will be clamped to the range `[0, args.length]`.\n    /// The `instance` MUST be deployed via the ERC1967I beacon proxy with immutable args functions.\n    /// Otherwise, the behavior is undefined.\n    /// Out-of-gas reverts if `instance` does not have any code.\n    function argsOnERC1967IBeaconProxy(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x37), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x57)\n                returndatacopy(returndatasize(), returndatasize(), shr(64, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      OTHER OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `address(0)` if the implementation address cannot be determined.\n    function implementationOf(address instance) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { extcodecopy(instance, 0x00, 0x00, 0x57) } 1 {} {\n                if mload(0x2d) {\n                    // ERC1967I and ERC1967IBeaconProxy detection.\n                    if or(\n                        eq(keccak256(0x00, 0x52), ERC1967I_CODE_HASH),\n                        eq(keccak256(0x00, 0x57), ERC1967I_BEACON_PROXY_CODE_HASH)\n                    ) {\n                        pop(staticcall(gas(), instance, 0x00, 0x01, 0x00, 0x20))\n                        result := mload(0x0c)\n                        break\n                    }\n                }\n                // 0age clone detection.\n                result := mload(0x0b)\n                codecopy(0x0b, codesize(), 0x14) // Zeroize the 20 bytes for the address.\n                if iszero(xor(keccak256(0x00, 0x2c), CLONE_CODE_HASH)) { break }\n                mstore(0x0b, result) // Restore the zeroized memory.\n                // CWIA detection.\n                result := mload(0x0a)\n                codecopy(0x0a, codesize(), 0x14) // Zeroize the 20 bytes for the address.\n                if iszero(xor(keccak256(0x00, 0x2d), CWIA_CODE_HASH)) { break }\n                mstore(0x0a, result) // Restore the zeroized memory.\n                // PUSH0 clone detection.\n                result := mload(0x09)\n                codecopy(0x09, codesize(), 0x14) // Zeroize the 20 bytes for the address.\n                result := shr(xor(keccak256(0x00, 0x2d), PUSH0_CLONE_CODE_HASH), result)\n                break\n            }\n            result := shr(96, result)\n            mstore(0x37, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the address when a contract with initialization code hash,\n    /// `hash`, is deployed with `salt`, by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Requires that `salt` starts with either the zero address or `by`.\n    function checkStartsWith(bytes32 salt, address by) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the salt does not start with the zero address or `by`.\n            if iszero(or(iszero(shr(96, salt)), eq(shr(96, shl(96, by)), shr(96, salt)))) {\n                mstore(0x00, 0x0c4549ef) // `SaltDoesNotStartWith()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"},"node_modules/erc7579/src/interfaces/IMSA.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport { IERC7579Account } from \"./IERC7579Account.sol\";\nimport { IERC4337Account } from \"./IERC4337Account.sol\";\n\nimport { CallType, ExecType, ModeCode } from \"../lib/ModeLib.sol\";\n\ninterface IMSA is IERC7579Account, IERC4337Account {\n    // Error thrown when an unsupported ModuleType is requested\n    error UnsupportedModuleType(uint256 moduleTypeId);\n    // Error thrown when an execution with an unsupported CallType was made\n    error UnsupportedCallType(CallType callType);\n    // Error thrown when an execution with an unsupported ExecType was made\n    error UnsupportedExecType(ExecType execType);\n    // Error thrown when account initialization fails\n    error AccountInitializationFailed();\n    // Error thrown when account installs/unistalls module with mismatched input `moduleTypeId`\n    error MismatchModuleTypeId(uint256 moduleTypeId);\n\n    /**\n     * @dev Initializes the account. Function might be called directly, or by a Factory\n     * @param data. encoded data that can be used during the initialization phase\n     */\n    function initializeAccount(bytes calldata data) external payable;\n}\n"},"node_modules/erc7579/src/core/ExecutionHelper.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { Execution } from \"../interfaces/IERC7579Account.sol\";\n\n/**\n * @title Execution\n * @dev This contract executes calls in the context of this contract.\n * @author zeroknots.eth | rhinestone.wtf\n * shoutout to solady (vectorized, ross) for this code\n * https://github.com/Vectorized/solady/blob/main/src/accounts/ERC4337.sol\n */\ncontract ExecutionHelper {\n    error ExecutionFailed();\n\n    event TryExecuteUnsuccessful(uint256 batchExecutionindex, bytes result);\n\n    function _execute(Execution[] calldata executions) internal returns (bytes[] memory result) {\n        uint256 length = executions.length;\n        result = new bytes[](length);\n\n        for (uint256 i; i < length; i++) {\n            Execution calldata _exec = executions[i];\n            result[i] = _execute(_exec.target, _exec.value, _exec.callData);\n        }\n    }\n\n    function _tryExecute(Execution[] calldata executions)\n        internal\n        returns (bytes[] memory result)\n    {\n        uint256 length = executions.length;\n        result = new bytes[](length);\n\n        for (uint256 i; i < length; i++) {\n            Execution calldata _exec = executions[i];\n            bool success;\n            (success, result[i]) = _tryExecute(_exec.target, _exec.value, _exec.callData);\n            if (!success) emit TryExecuteUnsuccessful(i, result[i]);\n        }\n    }\n\n    function _execute(\n        address target,\n        uint256 value,\n        bytes calldata callData\n    )\n        internal\n        virtual\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            if iszero(call(gas(), target, value, result, callData.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    function _tryExecute(\n        address target,\n        uint256 value,\n        bytes calldata callData\n    )\n        internal\n        virtual\n        returns (bool success, bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            success := call(gas(), target, value, result, callData.length, codesize(), 0x00)\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    /// @dev Execute a delegatecall with `delegate` on this account.\n    function _executeDelegatecall(\n        address delegate,\n        bytes calldata callData\n    )\n        internal\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            // Forwards the `data` to `delegate` via delegatecall.\n            if iszero(delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    /// @dev Execute a delegatecall with `delegate` on this account and catch reverts.\n    function _tryExecuteDelegatecall(\n        address delegate,\n        bytes calldata callData\n    )\n        internal\n        returns (bool success, bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            // Forwards the `data` to `delegate` via delegatecall.\n            success := delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n}\n"},"node_modules/erc7579/src/core/ModuleManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport { SentinelListLib, SENTINEL } from \"sentinellist/SentinelList.sol\";\nimport {\n    CallType, CALLTYPE_SINGLE, CALLTYPE_DELEGATECALL, CALLTYPE_STATIC\n} from \"../lib/ModeLib.sol\";\nimport { AccountBase } from \"./AccountBase.sol\";\nimport \"../interfaces/IERC7579Module.sol\";\nimport \"forge-std/interfaces/IERC165.sol\";\nimport \"./Receiver.sol\";\n\n/**\n * @title ModuleManager\n * @author zeroknots.eth | rhinestone.wtf\n * @dev This contract manages Validator, Executor and Fallback modules for the MSA\n * @dev it uses SentinelList to manage the linked list of modules\n * NOTE: the linked list is just an example. accounts may implement this differently\n */\nabstract contract ModuleManager is AccountBase, Receiver {\n    using SentinelListLib for SentinelListLib.SentinelList;\n\n    error InvalidModule(address module);\n    error NoFallbackHandler(bytes4 selector);\n    error CannotRemoveLastValidator();\n\n    // keccak256(\"modulemanager.storage.msa\");\n    bytes32 internal constant MODULEMANAGER_STORAGE_LOCATION =\n        0xf88ce1fdb7fb1cbd3282e49729100fa3f2d6ee9f797961fe4fb1871cea89ea02;\n\n    struct FallbackHandler {\n        address handler;\n        CallType calltype;\n    }\n\n    /// @custom:storage-location erc7201:modulemanager.storage.msa\n    struct ModuleManagerStorage {\n        // linked list of validators. List is initialized by initializeAccount()\n        SentinelListLib.SentinelList $valdiators;\n        // linked list of executors. List is initialized by initializeAccount()\n        SentinelListLib.SentinelList $executors;\n        // single fallback handler for all fallbacks\n        // account vendors may implement this differently. This is just a reference implementation\n        mapping(bytes4 selector => FallbackHandler fallbackHandler) $fallbacks;\n    }\n\n    function $moduleManager() internal pure virtual returns (ModuleManagerStorage storage $ims) {\n        bytes32 position = MODULEMANAGER_STORAGE_LOCATION;\n        assembly {\n            $ims.slot := position\n        }\n    }\n\n    modifier onlyExecutorModule() {\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\n        if (!$executors.contains(msg.sender)) revert InvalidModule(msg.sender);\n        _;\n    }\n\n    modifier onlyValidatorModule(address validator) {\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\n        if (!$valdiators.contains(validator)) revert InvalidModule(validator);\n        _;\n    }\n\n    function _initModuleManager() internal virtual {\n        ModuleManagerStorage storage $ims = $moduleManager();\n        $ims.$executors.init();\n        $ims.$valdiators.init();\n    }\n\n    function isAlreadyInitialized() internal view virtual returns (bool) {\n        ModuleManagerStorage storage $ims = $moduleManager();\n        return $ims.$valdiators.alreadyInitialized();\n    }\n\n    /////////////////////////////////////////////////////\n    //  Manage Validators\n    ////////////////////////////////////////////////////\n    function _installValidator(address validator, bytes calldata data) internal virtual {\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\n        $valdiators.push(validator);\n        IValidator(validator).onInstall(data);\n    }\n\n    function _uninstallValidator(address validator, bytes calldata data) internal {\n        // TODO: check if its the last validator. this might brick the account\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\n        (address prev, bytes memory disableModuleData) = abi.decode(data, (address, bytes));\n        $valdiators.pop(prev, validator);\n        IValidator(validator).onUninstall(disableModuleData);\n    }\n\n    function _isValidatorInstalled(address validator) internal view virtual returns (bool) {\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\n        return $valdiators.contains(validator);\n    }\n\n    /**\n     * THIS IS NOT PART OF THE STANDARD\n     * Helper Function to access linked list\n     */\n    function getValidatorsPaginated(\n        address cursor,\n        uint256 size\n    )\n        external\n        view\n        virtual\n        returns (address[] memory array, address next)\n    {\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\n        return $valdiators.getEntriesPaginated(cursor, size);\n    }\n\n    /////////////////////////////////////////////////////\n    //  Manage Executors\n    ////////////////////////////////////////////////////\n\n    function _installExecutor(address executor, bytes calldata data) internal {\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\n        $executors.push(executor);\n        IExecutor(executor).onInstall(data);\n    }\n\n    function _uninstallExecutor(address executor, bytes calldata data) internal {\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\n        (address prev, bytes memory disableModuleData) = abi.decode(data, (address, bytes));\n        $executors.pop(prev, executor);\n        IExecutor(executor).onUninstall(disableModuleData);\n    }\n\n    function _isExecutorInstalled(address executor) internal view virtual returns (bool) {\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\n        return $executors.contains(executor);\n    }\n\n    /**\n     * THIS IS NOT PART OF THE STANDARD\n     * Helper Function to access linked list\n     */\n    function getExecutorsPaginated(\n        address cursor,\n        uint256 size\n    )\n        external\n        view\n        virtual\n        returns (address[] memory array, address next)\n    {\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\n        return $executors.getEntriesPaginated(cursor, size);\n    }\n\n    /////////////////////////////////////////////////////\n    //  Manage Fallback\n    ////////////////////////////////////////////////////\n\n    function _installFallbackHandler(address handler, bytes calldata params) internal virtual {\n        bytes4 selector = bytes4(params[0:4]);\n        CallType calltype = CallType.wrap(bytes1(params[4]));\n        bytes memory initData = params[5:];\n\n        if (_isFallbackHandlerInstalled(selector)) {\n            revert(\"Function selector already used\");\n        }\n        $moduleManager().$fallbacks[selector] = FallbackHandler(handler, calltype);\n        IFallback(handler).onInstall(initData);\n    }\n\n    function _uninstallFallbackHandler(\n        address handler,\n        bytes calldata deInitData\n    )\n        internal\n        virtual\n    {\n        bytes4 selector = bytes4(deInitData[0:4]);\n        bytes memory _deInitData = deInitData[4:];\n\n        if (!_isFallbackHandlerInstalled(selector)) {\n            revert(\"Function selector not used\");\n        }\n\n        FallbackHandler memory activeFallback = $moduleManager().$fallbacks[selector];\n\n        if (activeFallback.handler != handler) {\n            revert(\"Function selector not used by this handler\");\n        }\n\n        CallType callType = activeFallback.calltype;\n\n        $moduleManager().$fallbacks[selector] = FallbackHandler(address(0), CallType.wrap(0x00));\n\n        IFallback(handler).onUninstall(_deInitData);\n    }\n\n    function _isFallbackHandlerInstalled(bytes4 functionSig) internal view virtual returns (bool) {\n        FallbackHandler storage $fallback = $moduleManager().$fallbacks[functionSig];\n        return $fallback.handler != address(0);\n    }\n\n    function _isFallbackHandlerInstalled(\n        bytes4 functionSig,\n        address _handler\n    )\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        FallbackHandler storage $fallback = $moduleManager().$fallbacks[functionSig];\n        return $fallback.handler == _handler;\n    }\n\n    function getActiveFallbackHandler(bytes4 functionSig)\n        external\n        view\n        virtual\n        returns (FallbackHandler memory)\n    {\n        return $moduleManager().$fallbacks[functionSig];\n    }\n\n    // FALLBACK\n    fallback() external payable override(Receiver) receiverFallback {\n        FallbackHandler storage $fallbackHandler = $moduleManager().$fallbacks[msg.sig];\n        address handler = $fallbackHandler.handler;\n        CallType calltype = $fallbackHandler.calltype;\n        if (handler == address(0)) revert NoFallbackHandler(msg.sig);\n\n        if (calltype == CALLTYPE_STATIC) {\n            assembly {\n                function allocate(length) -> pos {\n                    pos := mload(0x40)\n                    mstore(0x40, add(pos, length))\n                }\n\n                let calldataPtr := allocate(calldatasize())\n                calldatacopy(calldataPtr, 0, calldatasize())\n\n                // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n                // Then the address without padding is stored right after the calldata\n                let senderPtr := allocate(20)\n                mstore(senderPtr, shl(96, caller()))\n\n                // Add 20 bytes for the address appended add the end\n                let success :=\n                    staticcall(gas(), handler, calldataPtr, add(calldatasize(), 20), 0, 0)\n\n                let returnDataPtr := allocate(returndatasize())\n                returndatacopy(returnDataPtr, 0, returndatasize())\n                if iszero(success) { revert(returnDataPtr, returndatasize()) }\n                return(returnDataPtr, returndatasize())\n            }\n        }\n        if (calltype == CALLTYPE_SINGLE) {\n            assembly {\n                function allocate(length) -> pos {\n                    pos := mload(0x40)\n                    mstore(0x40, add(pos, length))\n                }\n\n                let calldataPtr := allocate(calldatasize())\n                calldatacopy(calldataPtr, 0, calldatasize())\n\n                // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n                // Then the address without padding is stored right after the calldata\n                let senderPtr := allocate(20)\n                mstore(senderPtr, shl(96, caller()))\n\n                // Add 20 bytes for the address appended add the end\n                let success := call(gas(), handler, 0, calldataPtr, add(calldatasize(), 20), 0, 0)\n\n                let returnDataPtr := allocate(returndatasize())\n                returndatacopy(returnDataPtr, 0, returndatasize())\n                if iszero(success) { revert(returnDataPtr, returndatasize()) }\n                return(returnDataPtr, returndatasize())\n            }\n        }\n    }\n}\n"},"node_modules/erc7579/src/core/HookManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport \"./ModuleManager.sol\";\nimport \"../interfaces/IERC7579Account.sol\";\nimport \"../interfaces/IERC7579Module.sol\";\n\n/**\n * @title reference implementation of HookManager\n * @author zeroknots.eth | rhinestone.wtf\n */\nabstract contract HookManager {\n    /// @custom:storage-location erc7201:hookmanager.storage.msa\n    struct HookManagerStorage {\n        IHook _hook;\n    }\n\n    // keccak256(\"hookmanager.storage.msa\");\n    bytes32 constant HOOKMANAGER_STORAGE_LOCATION =\n        0x36e05829dd1b9a4411d96a3549582172d7f071c1c0db5c573fcf94eb28431608;\n\n    error HookPostCheckFailed();\n    error HookAlreadyInstalled(address currentHook);\n\n    modifier withHook() {\n        address hook = _getHook();\n        if (hook == address(0)) {\n            _;\n        } else {\n            bytes memory hookData = IHook(hook).preCheck(msg.sender, msg.value, msg.data);\n            _;\n            IHook(hook).postCheck(hookData);\n        }\n    }\n\n    function _setHook(address hook) internal virtual {\n        bytes32 slot = HOOKMANAGER_STORAGE_LOCATION;\n        assembly {\n            sstore(slot, hook)\n        }\n    }\n\n    function _installHook(address hook, bytes calldata data) internal virtual {\n        address currentHook = _getHook();\n        if (currentHook != address(0)) {\n            revert HookAlreadyInstalled(currentHook);\n        }\n        _setHook(hook);\n        IHook(hook).onInstall(data);\n    }\n\n    function _uninstallHook(address hook, bytes calldata data) internal virtual {\n        _setHook(address(0));\n        IHook(hook).onUninstall(data);\n    }\n\n    function _getHook() internal view returns (address _hook) {\n        bytes32 slot = HOOKMANAGER_STORAGE_LOCATION;\n        assembly {\n            _hook := sload(slot)\n        }\n    }\n\n    function _isHookInstalled(address module) internal view returns (bool) {\n        return _getHook() == module;\n    }\n\n    function getActiveHook() external view returns (address hook) {\n        return _getHook();\n    }\n}\n"},"node_modules/erc7579/src/core/RegistryAdapter.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { IERC7484 } from \"../interfaces/IERC7484.sol\";\nimport { AccountBase } from \"./AccountBase.sol\";\n\n/**\n * @title RegistryAdapter\n * @author kopy-kat | rhinestone.wtf\n * @dev This contract uses ERC-7484 to check if a module is attested to and exposes a modifier to\n * use it.\n */\nabstract contract RegistryAdapter is AccountBase {\n    event ERC7484RegistryConfigured(address indexed smartAccount, address indexed registry);\n\n    IERC7484 internal $registry;\n\n    modifier withRegistry(address module, uint256 moduleTypeId) {\n        IERC7484 registry = $registry;\n        if (address(registry) != address(0)) {\n            registry.check(module, moduleTypeId);\n        }\n        _;\n    }\n\n    function setRegistry(\n        IERC7484 registry,\n        address[] calldata attesters,\n        uint8 threshold\n    )\n        external\n        onlyEntryPointOrSelf\n    {\n        $registry = registry;\n        if (attesters.length > 0) {\n            registry.trustAttesters(threshold, attesters);\n        }\n    }\n}\n"},"node_modules/erc7579/src/interfaces/IERC4337Account.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\ninterface IERC4337Account {\n    /**\n     * Validate user's signature and nonce\n     * the entryPoint will make the call to the recipient only if this validation call returns\n     * successfully.\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\n     * This allows making a \"simulation call\" without a valid signature\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to\n     * signal failure.\n     *\n     * @dev Must validate caller is the entryPoint.\n     *      Must validate the signature and nonce\n     * @param userOp              - The operation that is about to be executed.\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for\n     * signature.\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\n     *                              This is the minimum amount to transfer to the sender(entryPoint)\n     * to be\n     *                              able to make the call. The excess is left as a deposit in the\n     * entrypoint\n     *                              for future calls. Can be withdrawn anytime using\n     * \"entryPoint.withdrawTo()\".\n     *                              In case there is a paymaster in the request (or the current\n     * deposit is high\n     *                              enough), this value will be zero.\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData`\n     * and\n     *                              `_unpackValidationData` to encode and decode.\n     *                              <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark\n     * signature failure,\n     *                                 otherwise, an address of an \"authorizer\" contract.\n     *                              <6-byte> validUntil - Last timestamp this operation is valid. 0\n     * for \"indefinite\"\n     *                              <6-byte> validAfter - First timestamp this operation is valid\n     *                                                    If an account doesn't use time-range, it\n     * is enough to\n     *                                                    return SIG_VALIDATION_FAILED value (1) for\n     * signature failure.\n     *                              Note that the validation code cannot use block.timestamp (or\n     * block.number) directly.\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    )\n        external\n        payable\n        returns (uint256 validationData);\n\n    /**\n     * Account may implement this execute method.\n     * passing this methodSig at the beginning of callData will cause the entryPoint to pass the\n     * full UserOp (and hash)\n     * to the account.\n     * The account should skip the methodSig, and use the callData (and optionally, other UserOp\n     * fields)\n     *\n     * @param userOp              - The operation that was just validated.\n     * @param userOpHash          - Hash of the user's request data.\n     */\n    function executeUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        payable;\n}\n"},"node_modules/@rhinestone/sentinellist/src/SentinelList.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Sentinel address\naddress constant SENTINEL = address(0x1);\n// Zero address\naddress constant ZERO_ADDRESS = address(0x0);\n\n/**\n * @title SentinelListLib\n * @dev Library for managing a linked list of addresses\n * @author Rhinestone\n */\nlibrary SentinelListLib {\n    // Struct to hold the linked list\n    struct SentinelList {\n        mapping(address => address) entries;\n    }\n\n    error LinkedList_AlreadyInitialized();\n    error LinkedList_InvalidPage();\n    error LinkedList_InvalidEntry(address entry);\n    error LinkedList_EntryAlreadyInList(address entry);\n\n    /**\n     * Initialize the linked list\n     *\n     * @param self The linked list\n     */\n    function init(SentinelList storage self) internal {\n        if (alreadyInitialized(self)) revert LinkedList_AlreadyInitialized();\n        self.entries[SENTINEL] = SENTINEL;\n    }\n\n    /**\n     * Check if the linked list is already initialized\n     *\n     * @param self The linked list\n     *\n     * @return bool True if the linked list is already initialized\n     */\n    function alreadyInitialized(SentinelList storage self) internal view returns (bool) {\n        return self.entries[SENTINEL] != ZERO_ADDRESS;\n    }\n\n    /**\n     * Get the next entry in the linked list\n     *\n     * @param self The linked list\n     * @param entry The current entry\n     *\n     * @return address The next entry\n     */\n    function getNext(SentinelList storage self, address entry) internal view returns (address) {\n        if (entry == ZERO_ADDRESS) {\n            revert LinkedList_InvalidEntry(entry);\n        }\n        return self.entries[entry];\n    }\n\n    /**\n     * Push a new entry to the linked list\n     *\n     * @param self The linked list\n     * @param newEntry The new entry\n     */\n    function push(SentinelList storage self, address newEntry) internal {\n        if (newEntry == ZERO_ADDRESS || newEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(newEntry);\n        }\n        if (self.entries[newEntry] != ZERO_ADDRESS) revert LinkedList_EntryAlreadyInList(newEntry);\n        self.entries[newEntry] = self.entries[SENTINEL];\n        self.entries[SENTINEL] = newEntry;\n    }\n\n    /**\n     * Safe push a new entry to the linked list\n     * @dev This ensures that the linked list is initialized and initializes it if it is not\n     *\n     * @param self The linked list\n     * @param newEntry The new entry\n     */\n    function safePush(SentinelList storage self, address newEntry) internal {\n        if (!alreadyInitialized({ self: self })) {\n            init({ self: self });\n        }\n        push({ self: self, newEntry: newEntry });\n    }\n\n    /**\n     * Pop an entry from the linked list\n     *\n     * @param self The linked list\n     * @param prevEntry The entry before the entry to pop\n     * @param popEntry The entry to pop\n     */\n    function pop(SentinelList storage self, address prevEntry, address popEntry) internal {\n        if (popEntry == ZERO_ADDRESS || popEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(prevEntry);\n        }\n        if (self.entries[prevEntry] != popEntry) revert LinkedList_InvalidEntry(popEntry);\n        self.entries[prevEntry] = self.entries[popEntry];\n        self.entries[popEntry] = ZERO_ADDRESS;\n    }\n\n    /**\n     * Pop all entries from the linked list\n     *\n     * @param self The linked list\n     */\n    function popAll(SentinelList storage self) internal {\n        address next = self.entries[SENTINEL];\n        while (next != ZERO_ADDRESS) {\n            address current = next;\n            next = self.entries[next];\n            self.entries[current] = ZERO_ADDRESS;\n        }\n    }\n\n    /**\n     * Check if the linked list contains an entry\n     *\n     * @param self The linked list\n     * @param entry The entry to check\n     *\n     * @return bool True if the linked list contains the entry\n     */\n    function contains(SentinelList storage self, address entry) internal view returns (bool) {\n        return SENTINEL != entry && self.entries[entry] != ZERO_ADDRESS;\n    }\n\n    /**\n     * Get all entries in the linked list\n     *\n     * @param self The linked list\n     * @param start The start entry\n     * @param pageSize The page size\n     *\n     * @return array All entries in the linked list\n     * @return next The next entry\n     */\n    function getEntriesPaginated(\n        SentinelList storage self,\n        address start,\n        uint256 pageSize\n    )\n        internal\n        view\n        returns (address[] memory array, address next)\n    {\n        if (start != SENTINEL && !contains(self, start)) revert LinkedList_InvalidEntry(start);\n        if (pageSize == 0) revert LinkedList_InvalidPage();\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 entryCount = 0;\n        next = self.entries[start];\n        while (next != ZERO_ADDRESS && next != SENTINEL && entryCount < pageSize) {\n            array[entryCount] = next;\n            next = self.entries[next];\n            entryCount++;\n        }\n\n        /**\n         * Because of the argument validation, we can assume that the loop will always iterate over\n         * the valid entry list values\n         *       and the `next` variable will either be an enabled entry or a sentinel address\n         * (signalling the end).\n         *\n         *       If we haven't reached the end inside the loop, we need to set the next pointer to\n         * the last element of the entry array\n         *       because the `next` variable (which is a entry by itself) acting as a pointer to the\n         * start of the next page is neither\n         *       incSENTINELrent page, nor will it be included in the next one if you pass it as a\n         * start.\n         */\n        if (next != SENTINEL && entryCount > 0) {\n            next = array[entryCount - 1];\n        }\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(array, entryCount)\n        }\n    }\n}\n"},"node_modules/erc7579/src/core/AccountBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\n/**\n * @title reference implementation of the minimal modular smart account with Hook Extension\n * @author zeroknots.eth | rhinestone.wtf\n */\ncontract AccountBase {\n    error AccountAccessUnauthorized();\n\n    /////////////////////////////////////////////////////\n    // Access Control\n    ////////////////////////////////////////////////////\n\n    modifier onlyEntryPointOrSelf() virtual {\n        if (!(msg.sender == entryPoint() || msg.sender == address(this))) {\n            revert AccountAccessUnauthorized();\n        }\n        _;\n    }\n\n    modifier onlyEntryPoint() virtual {\n        if (msg.sender != entryPoint()) {\n            revert AccountAccessUnauthorized();\n        }\n        _;\n    }\n\n    function entryPoint() public view virtual returns (address) {\n        return 0x0000000071727De22E5E9d8BAf0edAc6f37da032;\n    }\n\n    /// @dev Sends to the EntryPoint (i.e. `msg.sender`) the missing funds for this transaction.\n    /// Subclass MAY override this modifier for better funds management.\n    /// (e.g. send to the EntryPoint more than the minimum required, so that in future transactions\n    /// it will not be required to send again)\n    ///\n    /// `missingAccountFunds` is the minimum value this modifier should send the EntryPoint,\n    /// which MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\n    modifier payPrefund(uint256 missingAccountFunds) virtual {\n        _;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if missingAccountFunds {\n                // Ignore failure (it's EntryPoint's job to verify, not the account's).\n                pop(call(gas(), caller(), missingAccountFunds, codesize(), 0x00, codesize(), 0x00))\n            }\n        }\n    }\n}\n"},"node_modules/forge-std/src/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    /// uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"},"node_modules/erc7579/src/core/Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title Receiver\n * @dev This contract receives safe-transferred ERC721 and ERC1155 tokens.\n * @author Modified from Solady\n * (https://github.com/Vectorized/solady/blob/main/src/accounts/Receiver.sol)\n */\nabstract contract Receiver {\n    /// @dev For receiving ETH.\n    receive() external payable virtual { }\n\n    /// @dev Fallback function with the `receiverFallback` modifier.\n    fallback() external payable virtual receiverFallback { }\n\n    /// @dev Modifier for the fallback function to handle token callbacks.\n    modifier receiverFallback() virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, calldataload(0))\n            // 0x150b7a02: `onERC721Received(address,address,uint256,bytes)`.\n            // 0xf23a6e61: `onERC1155Received(address,address,uint256,uint256,bytes)`.\n            // 0xbc197c81: `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n            if or(eq(s, 0x150b7a02), or(eq(s, 0xf23a6e61), eq(s, 0xbc197c81))) {\n                mstore(0x20, s) // Store `msg.sig`.\n                return(0x3c, 0x20) // Return `msg.sig`.\n            }\n        }\n        _;\n    }\n}\n"},"node_modules/erc7579/src/interfaces/IERC7484.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC7484 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          Check with Registry internal attesters            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    function check(address module) external view;\n\n    function checkForAccount(address smartAccount, address module) external view;\n\n    function check(address module, uint256 moduleType) external view;\n\n    function checkForAccount(\n        address smartAccount,\n        address module,\n        uint256 moduleType\n    )\n        external\n        view;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              Check with external attester(s)               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module, address attester) external view;\n\n    function check(address module, uint256 moduleType, address attester) external view;\n\n    function checkN(\n        address module,\n        address[] calldata attesters,\n        uint256 threshold\n    )\n        external\n        view;\n\n    function checkN(\n        address module,\n        uint256 moduleType,\n        address[] calldata attesters,\n        uint256 threshold\n    )\n        external\n        view;\n\n    function trustAttesters(uint8 threshold, address[] calldata attesters) external;\n}\n"}},"settings":{"remappings":["@rhinestone/=node_modules/@rhinestone/","sentinellist/=node_modules/@rhinestone/sentinellist/src/","erc4337-validation/=node_modules/@rhinestone/erc4337-validation/src/","safe7579/=node_modules/@rhinestone/safe7579/src/","modulekit/=node_modules/@rhinestone/modulekit/src/","module-bases/=node_modules/@rhinestone/module-bases/src/","solmate/=node_modules/solmate/src/","@ERC4337/=node_modules/@ERC4337/","account-abstraction/=node_modules/@ERC4337/account-abstraction/contracts/","account-abstraction-v0.6/=node_modules/@ERC4337/account-abstraction-v0.6/contracts/","@openzeppelin/=node_modules/@openzeppelin/","@safe-global/=node_modules/@safe-global/","ds-test/=node_modules/ds-test/src/","erc7579/=node_modules/erc7579/src/","forge-std/=node_modules/forge-std/src/","solady/=node_modules/solady/src/","solarray/=node_modules/solarray/src/","@prb/math/=node_modules/@prb/math/src/","freshcryptolib/=node_modules/freshcryptolib/solidity/src/","kernel/=node_modules/@zerodev/kernel/src/","ExcessivelySafeCall/=node_modules/excessively-safe-call/src/","excessively-safe-call/=node_modules/excessively-safe-call/src/","flatbytes/=node_modules/@rhinestone/flatbytes/src/","stringutils/=node_modules/stringutils/src/","@gnosis.pm/=node_modules/@gnosis.pm/","@zerodev/=node_modules/@zerodev/","hardhat-deploy/=node_modules/hardhat-deploy/","hardhat/=node_modules/hardhat/"],"optimizer":{"enabled":true,"runs":833},"metadata":{"useLiteralContent":false,"bytecodeHash":"none","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":false,"libraries":{}}}
