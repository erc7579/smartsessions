{"language":"Solidity","sources":{"contracts/SmartSession.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.25;\n\nimport \"./DataTypes.sol\";\n\nimport { IERC7579Account } from \"erc7579/interfaces/IERC7579Account.sol\";\nimport { IAccountExecute } from \"modulekit/external/ERC4337.sol\";\nimport { PackedUserOperation } from \"modulekit/external/ERC4337.sol\";\nimport { EIP1271_MAGIC_VALUE, IERC1271 } from \"module-bases/interfaces/IERC1271.sol\";\nimport { ExecType, CallType, CALLTYPE_BATCH, CALLTYPE_SINGLE, EXECTYPE_DEFAULT } from \"erc7579/lib/ModeLib.sol\";\n\nimport { ISmartSession } from \"./ISmartSession.sol\";\nimport { SmartSessionBase } from \"./core/SmartSessionBase.sol\";\nimport { SmartSessionERC7739 } from \"./core/SmartSessionERC7739.sol\";\nimport { EnumerableSet } from \"./utils/EnumerableSet4337.sol\";\nimport { ExecutionLib as ExecutionLib } from \"./lib/ExecutionLib.sol\";\nimport { IUserOpPolicy, IActionPolicy } from \"./interfaces/IPolicy.sol\";\nimport { PolicyLib } from \"./lib/PolicyLib.sol\";\nimport { SignerLib } from \"./lib/SignerLib.sol\";\nimport { ConfigLib } from \"./lib/ConfigLib.sol\";\nimport { EncodeLib } from \"./lib/EncodeLib.sol\";\nimport { HashLib } from \"./lib/HashLib.sol\";\nimport { ValidationDataLib } from \"./lib/ValidationDataLib.sol\";\nimport { IdLib } from \"./lib/IdLib.sol\";\nimport { SmartSessionModeLib } from \"./lib/SmartSessionModeLib.sol\";\n\n/**\n * @title SmartSession\n * @author [alphabetically] Filipp Makarov (Biconomy) & zeroknots.eth (Rhinestone)\n * @dev A collaborative effort between Rhinestone and Biconomy to create a powerful\n *      and flexible session key management system for ERC-4337 and ERC-7579 accounts.\n * SmartSession is an advanced module for ERC-4337 and ERC-7579 compatible smart contract wallets, enabling granular\n * control over session keys. It allows users to create and manage temporary, limited-permission access to their\n * accounts through configurable policies. The module supports various policy types, including user operation\n * validation, action-specific policies, and ERC-1271 signature validation. SmartSession implements a unique \"enable\n * flow\" that allows session keys to be created within the first user operation, enhancing security and user experience.\n * It uses a nested EIP-712 approach for signature validation, providing phishing resistance and compatibility with\n * existing wallet interfaces. The module also supports batched executions and integrates with external policy contracts\n * for flexible permission management. Overall, SmartSession offers a comprehensive solution for secure, temporary\n * account access in the evolving landscape of account abstraction.\n */\ncontract SmartSession is ISmartSession, SmartSessionBase, SmartSessionERC7739 {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableMap for EnumerableMap.Bytes32ToBytes32Map;\n    using SmartSessionModeLib for SmartSessionMode;\n    using IdLib for *;\n    using ValidationDataLib for ValidationData;\n    using HashLib for *;\n    using PolicyLib for *;\n    using SignerLib for *;\n    using ConfigLib for *;\n    using ExecutionLib for *;\n    using EncodeLib for *;\n\n    /**\n     * @notice Validates a user operation for ERC4337/ERC7579 compatibility\n     * @dev This function is the entry point for validating user operations in SmartSession\n     * @dev This function will dissect the userop.signature field, and parse out the provided PermissionId, which\n     * identifies a\n     * unique ID of a dapp for a specific user. n Policies and one Signer contract are mapped to this Id and will be\n     * checked. Only UserOps that pass policies and signer checks, are considered valid.\n     * Enable Flow:\n     *     SmartSessions allows session keys to be created within the \"first\" UserOp. If the enable flow is chosen, the\n     *     EnableSession data, which is packed in userOp.signature is parsed, and stored in the SmartSession storage.\n     * @param userOp The user operation to validate\n     * @param userOpHash The hash of the user operation\n     * @return vd ValidationData containing the validation result\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        override\n        returns (ValidationData vd)\n    {\n        // ensure that userOp.sender == msg.sender == account\n        // SmartSession will sstore configs for a certain account,\n        // so we have to ensure that unauthorized access is not possible\n        address account = userOp.getSender();\n        if (account != msg.sender) revert InvalidUserOpSender(account);\n\n        // unpacking data packed in userOp.signature\n        (SmartSessionMode mode, PermissionId permissionId, bytes calldata packedSig) = userOp.signature.unpackMode();\n\n        // If the SmartSession.USE mode was selected, no further policies have to be enabled.\n        // We can go straight to userOp validation\n        // This condition is the average case, so should be handled as the first condition\n        if (mode.isUseMode()) {\n            // USE mode: Directly enforce policies without enabling new ones\n            vd = _enforcePolicies({\n                permissionId: permissionId,\n                userOpHash: userOpHash,\n                userOp: userOp,\n                decompressedSignature: packedSig,\n                account: account\n            });\n        }\n        // If the SmartSession.ENABLE mode was selected, the userOp.signature will contain the EnableSession data\n        // This data will be used to enable policies and signer for the session\n        // The signature of the user on the EnableSession data will be checked\n        // If the signature is valid, the policies and signer will be enabled\n        // after enabling the session, the policies will be enforced on the userOp similarly to the SmartSession.USE\n        else if (mode.isEnableMode()) {\n            // unpack the EnableSession data and signature\n            // calculate the permissionId from the Session data\n            EnableSession memory enableData;\n            bytes memory usePermissionSig;\n            (enableData, usePermissionSig) = packedSig.decodeEnable();\n            permissionId = enableData.sessionToEnable.toPermissionIdMemory();\n\n            // ENABLE mode: Enable new policies and then enforce them\n            _enablePolicies({ enableData: enableData, permissionId: permissionId, account: account, mode: mode });\n\n            vd = _enforcePolicies({\n                permissionId: permissionId,\n                userOpHash: userOpHash,\n                userOp: userOp,\n                decompressedSignature: usePermissionSig,\n                account: account\n            });\n        }\n        // if an Unknown mode is provided, the function will revert\n        else {\n            revert UnsupportedSmartSessionMode(mode);\n        }\n    }\n\n    /**\n     * @notice Enables policies for a session during user operation validation\n     * @dev This function handles the enabling of new policies and session validators\n     * @param enableData The EnableSession data containing the session to enable\n     * @param permissionId The unique identifier for the permission set\n     * @param account The account for which policies are being enabled\n     * @param mode The SmartSession mode being used\n     */\n    function _enablePolicies(\n        EnableSession memory enableData,\n        PermissionId permissionId,\n        address account,\n        SmartSessionMode mode\n    )\n        internal\n    {\n        // Increment nonce to prevent replay attacks\n        uint256 nonce = $signerNonce[permissionId][account]++;\n        bytes32 hash = enableData.getAndVerifyDigest(account, nonce, mode);\n\n        // require signature on account\n        // this is critical as it is the only way to ensure that the user is aware of the policies and signer\n        // NOTE: although SmartSession implements a ERC1271 feature,\n        // it CAN NOT be used as a valid ERC1271 validator for\n        // this step. SmartSessions ERC1271 function must prevent this\n        if (IERC1271(account).isValidSignature(hash, enableData.permissionEnableSig) != EIP1271_MAGIC_VALUE) {\n            revert InvalidEnableSignature(account, hash);\n        }\n\n        // Do not use registry for enabling policies\n        bool useRegistry = false;\n\n        // Enable UserOp policies\n        $userOpPolicies.enable({\n            policyType: PolicyType.USER_OP,\n            permissionId: permissionId,\n            configId: permissionId.toUserOpPolicyId().toConfigId(),\n            policyDatas: enableData.sessionToEnable.userOpPolicies,\n            useRegistry: useRegistry\n        });\n\n        // Enable ERC1271 policies\n        $enabledERC7739.enable({\n            contexts: enableData.sessionToEnable.erc7739Policies.allowedERC7739Content,\n            permissionId: permissionId\n        });\n\n        // Enabel ERC1271 policies\n        $erc1271Policies.enable({\n            policyType: PolicyType.ERC1271,\n            permissionId: permissionId,\n            configId: permissionId.toErc1271PolicyId().toConfigId(),\n            policyDatas: enableData.sessionToEnable.erc7739Policies.erc1271Policies,\n            useRegistry: useRegistry\n        });\n\n        // Enable action policies\n        $actionPolicies.enable({\n            permissionId: permissionId,\n            actionPolicyDatas: enableData.sessionToEnable.actions,\n            useRegistry: useRegistry\n        });\n\n        _setPermit4337Paymaster(permissionId, enableData.sessionToEnable.permitERC4337Paymaster);\n\n        // Enable mode can involve enabling ISessionValidator (new Permission)\n        // or just adding policies (existing permission)\n        // a) ISessionValidator is not set => enable ISessionValidator\n        // b) ISessionValidator is set => just add policies (above)\n        // Attention: if the same policy that has already been configured is added again,\n        // the policy will be overwritten with the new configuration\n        if (!_isISessionValidatorSet(permissionId, account)) {\n            $sessionValidators.enable({\n                permissionId: permissionId,\n                sessionValidator: enableData.sessionToEnable.sessionValidator,\n                sessionValidatorConfig: enableData.sessionToEnable.sessionValidatorInitData,\n                useRegistry: useRegistry\n            });\n        }\n\n        // Mark the session as enabled\n        $enabledSessions.add(msg.sender, PermissionId.unwrap(permissionId));\n    }\n\n    /**\n     * @notice Enforces policies and checks ISessionValidator signature for a session\n     * @dev This function is the core of policy enforcement in SmartSession\n     * @param permissionId The unique identifier for the permission set\n     * @param userOpHash The hash of the user operation\n     * @param userOp The user operation being validated\n     * @param decompressedSignature The decompressed signature for validation\n     * @param account The account for which policies are being enforced\n     * @return vd ValidationData containing the result of policy checks\n     */\n    function _enforcePolicies(\n        PermissionId permissionId,\n        bytes32 userOpHash,\n        PackedUserOperation calldata userOp,\n        bytes memory decompressedSignature,\n        address account\n    )\n        internal\n        returns (ValidationData vd)\n    {\n        // ensure that the permissionId is enabled\n        if (!$enabledSessions.contains({ account: account, value: PermissionId.unwrap(permissionId) })) {\n            revert InvalidPermissionId(permissionId);\n        }\n\n        /* --- Scope: Check UserOp Policies --- */\n        {\n            // by default, minPolicies for userOp policies is 0\n            // in the case of the UserOp having paymasterAndData and the user opted in, to allow the PermissionID to use\n            // paymasters, this value will be 1\n            uint256 minPolicies;\n\n            // if a paymaster is used in this userop, we must ensure that the user authorized this PermissionID to use\n            // any\n            // paymasters. Should this be the case, a UserOpPolicy must run, this could be a yes policy, or a specific\n            // UserOpPolicy that can destructure the paymasterAndData and inspect it\n            if (userOp.paymasterAndData.length != 0) {\n                if ($permitERC4337Paymaster[permissionId][account]) minPolicies = 1;\n                else revert PaymasterValidationNotEnabled(permissionId);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                    Check UserOp Policies                   */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            // Check UserOp policies\n            // This reverts if policies are violated\n            vd = $userOpPolicies.check({\n                permissionId: permissionId,\n                callOnIPolicy: abi.encodeCall(\n                    IUserOpPolicy.checkUserOpPolicy, (permissionId.toUserOpPolicyId().toConfigId(), userOp)\n                ),\n                minPolicies: minPolicies\n            });\n        }\n        /* --- End Scope: Check UserOp Policies --- */\n\n        bytes4 selector = bytes4(userOp.callData[0:4]);\n\n        /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n        /*                      Handle Executions                     */\n        /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n        // if the selector indicates that the userOp is an execution,\n        // action policies have to be checked\n        if (selector == IERC7579Account.execute.selector) {\n            // Decode ERC7579 execution mode\n            (CallType callType, ExecType execType) = userOp.callData.get7579ExecutionTypes();\n            // ERC7579 allows for different execution types, but SmartSession only supports the default execution type\n            if (ExecType.unwrap(execType) != ExecType.unwrap(EXECTYPE_DEFAULT)) {\n                revert UnsupportedExecutionType();\n            }\n            // DEFAULT EXEC & BATCH CALL\n            else if (callType == CALLTYPE_BATCH) {\n                vd = vd.intersect(\n                    $actionPolicies.actionPolicies.checkBatch7579Exec({\n                        userOp: userOp,\n                        permissionId: permissionId,\n                        minPolicies: 1 // minimum of one actionPolicy must be set.\n                     })\n                );\n            }\n            // DEFAULT EXEC & SINGLE CALL\n            else if (callType == CALLTYPE_SINGLE) {\n                (address target, uint256 value, bytes calldata callData) =\n                    userOp.callData.decodeUserOpCallData().decodeSingle();\n                vd = vd.intersect(\n                    $actionPolicies.actionPolicies.checkSingle7579Exec({\n                        permissionId: permissionId,\n                        target: target,\n                        value: value,\n                        callData: callData,\n                        minPolicies: 1 // minimum of one actionPolicy must be set.\n                     })\n                );\n            }\n            // DelegateCalls are not supported by SmartSession\n            else {\n                revert UnsupportedCallType(callType);\n            }\n        }\n        // SmartSession does not support executeUserOp,\n        // should this function selector be used in the userOp: revert\n        // see why: https://github.com/erc7579/smartsessions/issues/17\n        else if (selector == IAccountExecute.executeUserOp.selector) {\n            revert UnsupportedExecutionType();\n        }\n        /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n        /*                        Handle Actions                      */\n        /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n        // all other executions are supported and are handled by the actionPolicies\n        else {\n            ActionId actionId = account.toActionId(bytes4(userOp.callData[:4]));\n\n            vd = vd.intersect(\n                $actionPolicies.actionPolicies[actionId].check({\n                    permissionId: permissionId,\n                    callOnIPolicy: abi.encodeCall(\n                        IActionPolicy.checkAction,\n                        (\n                            permissionId.toConfigId(actionId),\n                            account, // account\n                            account, // target\n                            0, // value\n                            userOp.callData // data\n                        )\n                    ),\n                    minPolicies: 1 // minimum of one actionPolicy must be set.\n                 })\n            );\n        }\n\n        /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n        /*                 Check SessionKey ISessionValidator         */\n        /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n        // perform signature check with ISessionValidator\n        // this function will revert if no ISessionValidator is set for this permissionId\n        bool validSig = $sessionValidators.isValidISessionValidator({\n            hash: userOpHash,\n            account: account,\n            permissionId: permissionId,\n            signature: decompressedSignature\n        });\n\n        // if the ISessionValidator signature is invalid, the userOp is invalid\n        if (!validSig) return ERC4337_VALIDATION_FAILED;\n\n        // In every Policy check, the ERC4337.ValidationData sigFailed required to be false, SmartSession validation\n        // flow will only reach to this line, if all Policies return valid and ISessionValidator signature is valid\n        return vd;\n    }\n\n    /**\n     * @notice SessionKey ERC-1271 signature validation\n     * this function implements the ERC-1271 forwarding function defined by ERC-7579\n     * SessionKeys can be used to sign messages and validate ERC-1271 on behalf of Accounts\n     * In order to validate a signature, the signature must be wrapped with ERC-7739\n     * @param sender The address of ERC-1271 sender\n     * @param hash The hash of the message\n     * @param signature The signature of the message\n     *         signature is expected to be in the format:\n     *         (PermissionId (32 bytes),\n     *          ERC7739 (abi.encodePacked(signatureForSessionValidator,\n     *                                    _DOMAIN_SEP_B,\n     *                                    contents,\n     *                                    contentsType,\n     *                                    uint16(contentsType.length))\n     */\n    function isValidSignatureWithSender(\n        address sender,\n        bytes32 hash,\n        bytes calldata signature\n    )\n        external\n        view\n        override\n        returns (bytes4 result)\n    {\n        // ERC-7739 support detection\n        if (hash == 0x7739773977397739773977397739773977397739773977397739773977397739) return bytes4(0x77390001);\n        // disallow that session can be authorized by other sessions\n        if (sender == address(this)) return EIP1271_FAILED;\n\n        bool success = _erc1271IsValidSignatureViaNestedEIP712(sender, hash, _erc1271UnwrapSignature(signature));\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `success ? bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")) : 0xffffffff`.\n            // We use `0xffffffff` for invalid, in convention with the reference implementation.\n            result := shl(224, or(0x1626ba7e, sub(0, iszero(success))))\n        }\n    }\n\n    /**\n     * @notice Validates an ERC-1271 signature with additional ERC-7739 content checks\n     * @dev This function performs several checks to validate the signature:\n     *      1. Verifies that the permissionId is enabled for the sender\n     *      2. Ensures the ERC-7739 content is enabled for the given permissionId\n     *      3. Checks the ERC-1271 policy\n     *      4. Validates the signature using ISessionValidator\n     * @dev This function returns false if a permissionId supplied within the signature is not enabled\n     * @dev This function returns false if the ERC-7739 content is not enabled for the given permissionId\n     * @param sender The address initiating the signature validation\n     * @param hash The hash of the data to be signed\n     * @param signature The signature to be validated (first 32 bytes contain the permissionId)\n     * @param contents The ERC-7739 content to be validated\n     * @return valid Boolean indicating whether the signature is valid\n     */\n    function _erc1271IsValidSignatureNowCalldata(\n        address sender,\n        bytes32 hash,\n        bytes calldata signature,\n        bytes32 appDomainSeparator,\n        bytes calldata contents\n    )\n        internal\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        bytes32 contentHash = string(contents).hashERC7739Content();\n        // isolate the PermissionId and actual signature from the supplied signature param\n        PermissionId permissionId = PermissionId.wrap(bytes32(signature[0:32]));\n        signature = signature[32:];\n\n        // forgefmt: disable-next-item\n        if (\n            // return false if the permissionId is not enabled\n            !$enabledSessions.contains(msg.sender, PermissionId.unwrap(permissionId))\n            // return false if the content is not enabled\n            || !$enabledERC7739.enabledContentNames[permissionId][appDomainSeparator].contains(msg.sender, contentHash)\n        ) return false;\n\n        // check the ERC-1271 policy\n        bool valid = $erc1271Policies.checkERC1271({\n            account: msg.sender,\n            requestSender: sender,\n            hash: hash,\n            signature: signature,\n            permissionId: permissionId,\n            configId: permissionId.toErc1271PolicyId().toConfigId(),\n            minPoliciesToEnforce: 1\n        });\n\n        // if the erc1271 policy check failed, return false\n        if (!valid) return valid;\n        // this call reverts if the ISessionValidator is not set\n        return $sessionValidators.isValidISessionValidator({\n            hash: hash,\n            account: msg.sender,\n            permissionId: permissionId,\n            signature: signature\n        });\n    }\n}\n"},"contracts/DataTypes.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.25;\n\nimport \"./utils/AssociatedArrayLib.sol\";\nimport { IRegistry, ModuleType } from \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/ISessionValidator.sol\";\nimport { EnumerableSet } from \"./utils/EnumerableSet4337.sol\";\nimport { EnumerableMap } from \"./utils/EnumerableMap4337.sol\";\nimport { FlatBytesLib } from \"flatbytes/BytesLib.sol\";\n\n/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n/*                       Parameters                           */\n/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\nstruct EnableSession {\n    uint8 chainDigestIndex;\n    ChainDigest[] hashesAndChainIds;\n    Session sessionToEnable;\n    // in order to enable a session, the smart account has to sign a digest. The signature for this is stored here.\n    bytes permissionEnableSig;\n}\n\nstruct ChainDigest {\n    uint64 chainId;\n    bytes32 sessionDigest;\n}\n\n/**\n *\n * Represents a Session structure with various attributes for managing user operations and policies.\n *\n * Attributes:\n *     sessionValidator (ISessionValidator): The validator contract for signing user operations.\n *         Every userOp must be signed by the session key \"owner\". The signature is validated\n *         via a stateless external contract (ISessionValidator) that can implement different\n *         means of validation.\n *\n *     sessionValidatorInitData (bytes): Initialization data for the ISessionValidator contract.\n *         The ISessionValidator contract can be configured with different parameters that are\n *         passed in this field.\n *\n *     salt (bytes32): A unique identifier to prevent collision between sessions.\n *         A session key owner can have multiple sessions with the same parameters. To facilitate\n *         this, a salt is necessary to avoid collision.\n *\n *     userOpPolicies (PolicyData[]): An array of policy data for user operations.\n *         When every session can have multiple policies set.\n *\n *     erc7739Policies (ERC7739Data): ERC1271 Policies specific to the ERC7739 standard.\n *\n *     actions (ActionData[]): An array of action data for specifying function-specific policies.\n *         A common use case of session keys is to scope access to a specific target and function\n *         selector. SmartSession calls this \"Action\". With ActionData, we can specify policies\n *         that are only run if a 7579 execution contains a specific action.\n */\nstruct Session {\n    ISessionValidator sessionValidator;\n    bytes sessionValidatorInitData;\n    bytes32 salt;\n    PolicyData[] userOpPolicies;\n    ERC7739Data erc7739Policies;\n    ActionData[] actions;\n    bool permitERC4337Paymaster;\n}\n\nstruct MultiChainSession {\n    ChainSession[] sessionsAndChainIds;\n}\n\nstruct ChainSession {\n    uint64 chainId;\n    Session session;\n}\n\n// Policy data is a struct that contains the policy address and the initialization data for the policy.\nstruct PolicyData {\n    address policy;\n    bytes initData;\n}\n\n// Action data is a struct that contains the actionId and the policies that are associated with this action.\nstruct ActionData {\n    bytes4 actionTargetSelector;\n    address actionTarget;\n    PolicyData[] actionPolicies;\n}\n\nstruct ERC7739Context {\n    // we can not use a detailed EIP712Domain struct here.\n    // EIP712 specifies: Protocol designers only need to include the fields that make sense for their signing domain.\n    // Unused fields are left out of the struct type.\n    bytes32 appDomainSeparator;\n    string[] contentNames;\n}\n\nstruct EIP712Domain {\n    string name;\n    string version;\n    uint256 chainId;\n    address verifyingContract;\n}\n\nstruct ERC7739Data {\n    ERC7739Context[] allowedERC7739Content;\n    PolicyData[] erc1271Policies;\n}\n\nenum SmartSessionMode {\n    USE,\n    ENABLE,\n    UNSAFE_ENABLE\n}\n\nstruct ERC7739ContextHashes {\n    bytes32 appDomainSeparator;\n    bytes32[] contentNameHashes;\n}\n\n/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n/*                         Storage                            */\n/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\nstruct SignerConf {\n    ISessionValidator sessionValidator;\n    FlatBytesLib.Bytes config; // using FlatBytes to get around storage slot limitations\n}\n\nstruct Policy {\n    mapping(PermissionId => EnumerableSet.AddressSet) policyList;\n}\n\nstruct EnumerableActionPolicy {\n    mapping(ActionId => Policy) actionPolicies;\n    mapping(PermissionId => EnumerableSet.Bytes32Set) enabledActionIds;\n}\n\nstruct EnumerableERC7739Config {\n    mapping(PermissionId => mapping(bytes32 appDomainSeparator => EnumerableSet.Bytes32Set)) enabledContentNames;\n    mapping(PermissionId => EnumerableSet.Bytes32Set) enabledDomainSeparators;\n}\n\n// struct EnumerableERC7739Config {\n//     mapping(PermissionId => EnumerableMap.Bytes32ToBytes32Map) erc1271Policies;\n// }\n// mapping(PermissionId => EnumerableSet.Bytes32Set) enabledDomainSeparators;\n\n/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n/*                 Custom Types & Constants                   */\n/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\ntype PermissionId is bytes32;\n\ntype ActionId is bytes32;\n\ntype ActionPolicyId is bytes32;\n\ntype UserOpPolicyId is bytes32;\n\ntype Erc1271PolicyId is bytes32;\n\ntype ConfigId is bytes32;\n\ntype ValidationData is uint256;\n\nActionId constant EMPTY_ACTIONID = ActionId.wrap(bytes32(0));\nPermissionId constant EMPTY_PERMISSIONID = PermissionId.wrap(bytes32(0));\nUserOpPolicyId constant EMPTY_USEROPPOLICYID = UserOpPolicyId.wrap(bytes32(0));\nActionPolicyId constant EMPTY_ACTIONPOLICYID = ActionPolicyId.wrap(bytes32(0));\nErc1271PolicyId constant EMPTY_ERC1271POLICYID = Erc1271PolicyId.wrap(bytes32(0));\nConfigId constant EMPTY_CONFIGID = ConfigId.wrap(bytes32(0));\n\nValidationData constant ERC4337_VALIDATION_SUCCESS = ValidationData.wrap(0);\nValidationData constant ERC4337_VALIDATION_FAILED = ValidationData.wrap(1);\nbytes4 constant EIP1271_SUCCESS = 0x1626ba7e;\nbytes4 constant EIP1271_FAILED = 0xFFFFFFFF;\n\nuint256 constant ERC7579_MODULE_TYPE_VALIDATOR = 1;\nuint256 constant ERC7579_MODULE_TYPE_EXECUTOR = 2;\nuint256 constant ERC7579_MODULE_TYPE_FALLBACK = 3;\nuint256 constant ERC7579_MODULE_TYPE_HOOK = 4;\nuint256 constant ERC7579_MODULE_TYPE_STATELESS_VALIDATOR = 7;\n\nenum PolicyType {\n    NA,\n    USER_OP,\n    ACTION,\n    ERC1271\n}\n\nIRegistry constant registry = IRegistry(0x000000000069E2a187AEFFb852bF3cCdC95151B2);\nModuleType constant VALIDATOR_MODULE_TYPE = ModuleType.wrap(ERC7579_MODULE_TYPE_VALIDATOR);\n\n// ActionId for a fallback action policy. This id will be used if both action\n// target and selector are set to 1. During validation if the current target and\n// selector does not have a set action policy, then the fallback will be used if\n// enabled.\naddress constant FALLBACK_TARGET_FLAG = address(1);\nbytes4 constant FALLBACK_TARGET_SELECTOR_FLAG = 0x00000001;\nbytes4 constant FALLBACK_TARGET_SELECTOR_FLAG_PERMITTED_TO_CALL_SMARTSESSION = 0x00000002;\n// keccak256(abi.encodePacked(FALLBACK_TARGET_FLAG, FALLBACK_TARGET_SELECTOR_FLAG))\nActionId constant FALLBACK_ACTIONID = ActionId.wrap(0xd884b6afa19f8ace90a388daca691e4e28f20cdac5aeefd46ad8bd1c074d28cf);\n\n// keccak256(abi.encodePacked(FALLBACK_TARGET_FLAG, FALLBACK_TARGET_SELECTOR_FLAG_PERMITTED_TO_CALL_SMARTSESSION))\nActionId constant FALLBACK_ACTIONID_SMARTSESSION_CALL =\n    ActionId.wrap(0x986126569d6396d837d7adeb3ca726199afaf83546f38726e6f331bb92d8e9d6);\n\n// A unique ValidationData value to retry a policy check with the FALLBACK_ACTIONID.\nValidationData constant RETRY_WITH_FALLBACK = ValidationData.wrap(uint256(0x50FFBAAD));\n\nusing { validationDataEq as == } for ValidationData global;\nusing { validationDataNeq as != } for ValidationData global;\n\nfunction validationDataEq(ValidationData uid1, ValidationData uid2) pure returns (bool) {\n    return ValidationData.unwrap(uid1) == ValidationData.unwrap(uid2);\n}\n\nfunction validationDataNeq(ValidationData uid1, ValidationData uid2) pure returns (bool) {\n    return ValidationData.unwrap(uid1) != ValidationData.unwrap(uid2);\n}\n\nusing { permissionIdEq as == } for PermissionId global;\nusing { permissionIdNeq as != } for PermissionId global;\n\nfunction permissionIdEq(PermissionId uid1, PermissionId uid2) pure returns (bool) {\n    return PermissionId.unwrap(uid1) == PermissionId.unwrap(uid2);\n}\n\nfunction permissionIdNeq(PermissionId uid1, PermissionId uid2) pure returns (bool) {\n    return PermissionId.unwrap(uid1) != PermissionId.unwrap(uid2);\n}\n\n// ActionId\nusing { actionIdEq as == } for ActionId global;\nusing { actionIdNeq as != } for ActionId global;\n\nfunction actionIdEq(ActionId id1, ActionId id2) pure returns (bool) {\n    return ActionId.unwrap(id1) == ActionId.unwrap(id2);\n}\n\nfunction actionIdNeq(ActionId id1, ActionId id2) pure returns (bool) {\n    return ActionId.unwrap(id1) != ActionId.unwrap(id2);\n}\n\n// UserOpPolicyId\nusing { userOpPolicyIdEq as == } for UserOpPolicyId global;\nusing { userOpPolicyIdNeq as != } for UserOpPolicyId global;\n\nfunction userOpPolicyIdEq(UserOpPolicyId id1, UserOpPolicyId id2) pure returns (bool) {\n    return UserOpPolicyId.unwrap(id1) == UserOpPolicyId.unwrap(id2);\n}\n\nfunction userOpPolicyIdNeq(UserOpPolicyId id1, UserOpPolicyId id2) pure returns (bool) {\n    return UserOpPolicyId.unwrap(id1) != UserOpPolicyId.unwrap(id2);\n}\n\n// ActionPolicyId\nusing { actionPolicyIdEq as == } for ActionPolicyId global;\nusing { actionPolicyIdNeq as != } for ActionPolicyId global;\n\nfunction actionPolicyIdEq(ActionPolicyId id1, ActionPolicyId id2) pure returns (bool) {\n    return ActionPolicyId.unwrap(id1) == ActionPolicyId.unwrap(id2);\n}\n\nfunction actionPolicyIdNeq(ActionPolicyId id1, ActionPolicyId id2) pure returns (bool) {\n    return ActionPolicyId.unwrap(id1) != ActionPolicyId.unwrap(id2);\n}\n\n// Erc1271PolicyId\nusing { erc1271PolicyIdEq as == } for Erc1271PolicyId global;\nusing { erc1271PolicyIdNeq as != } for Erc1271PolicyId global;\n\nfunction erc1271PolicyIdEq(Erc1271PolicyId id1, Erc1271PolicyId id2) pure returns (bool) {\n    return Erc1271PolicyId.unwrap(id1) == Erc1271PolicyId.unwrap(id2);\n}\n\nfunction erc1271PolicyIdNeq(Erc1271PolicyId id1, Erc1271PolicyId id2) pure returns (bool) {\n    return Erc1271PolicyId.unwrap(id1) != Erc1271PolicyId.unwrap(id2);\n}\n\n// ConfigId\nusing { configIdEq as == } for ConfigId global;\nusing { configIdNeq as != } for ConfigId global;\n\nfunction configIdEq(ConfigId id1, ConfigId id2) pure returns (bool) {\n    return ConfigId.unwrap(id1) == ConfigId.unwrap(id2);\n}\n\nfunction configIdNeq(ConfigId id1, ConfigId id2) pure returns (bool) {\n    return ConfigId.unwrap(id1) != ConfigId.unwrap(id2);\n}\n"},"node_modules/erc7579/src/interfaces/IERC7579Account.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport { CallType, ExecType, ModeCode } from \"../lib/ModeLib.sol\";\n\nstruct Execution {\n    address target;\n    uint256 value;\n    bytes callData;\n}\n\ninterface IERC7579Account {\n    event ModuleInstalled(uint256 moduleTypeId, address module);\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by Executor Modules\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function executeFromExecutor(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        payable\n        returns (bytes[] memory returnData);\n\n    /**\n     * @dev ERC-1271 isValidSignature\n     *         This function is intended to be used to validate a smart account signature\n     * and may forward the call to a validator module\n     *\n     * @param hash The hash of the data that is signed\n     * @param data The data that is signed\n     */\n    function isValidSignature(bytes32 hash, bytes calldata data) external view returns (bytes4);\n\n    /**\n     * @dev installs a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param initData arbitrary data that may be required on the module during `onInstall`\n     * initialization.\n     */\n    function installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    )\n        external\n        payable;\n\n    /**\n     * @dev uninstalls a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization.\n     */\n    function uninstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata deInitData\n    )\n        external\n        payable;\n\n    /**\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\n     * @param encodedMode the encoded mode\n     */\n    function supportsExecutionMode(ModeCode encodedMode) external view returns (bool);\n\n    /**\n     * Function to check if the account supports installation of a certain module type Id\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     */\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\n\n    /**\n     * Function to check if the account has a certain module installed\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\n     *            thus may be necessary to query multiple module types\n     * @param module the module address\n     * @param additionalContext additional context data that the smart account may interpret to\n     *                          identifiy conditions under which the module is installed.\n     *                          usually this is not necessary, but for some special hooks that\n     *                          are stored in mappings, this param might be needed\n     */\n    function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    )\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Returns the account id of the smart account\n     * @return accountImplementationId the account id of the smart account\n     * the accountId should be structured like so:\n     *        \"vendorname.accountname.semver\"\n     */\n    function accountId() external view returns (string memory accountImplementationId);\n}\n"},"node_modules/@rhinestone/modulekit/src/external/ERC4337.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/* solhint-disable no-unused-import */\nimport { PackedUserOperation } from\n    \"@ERC4337/account-abstraction/contracts/interfaces/PackedUserOperation.sol\";\nimport { UserOperationLib } from \"@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol\";\nimport { IEntryPoint } from \"@ERC4337/account-abstraction/contracts/interfaces/IEntryPoint.sol\";\nimport { EntryPointSimulations } from\n    \"@ERC4337/account-abstraction/contracts/core/EntryPointSimulations.sol\";\nimport { IEntryPointSimulations } from\n    \"@ERC4337/account-abstraction/contracts/interfaces/IEntryPointSimulations.sol\";\nimport {\n    ValidationData,\n    _packValidationData\n} from \"@ERC4337/account-abstraction/contracts/core/Helpers.sol\";\nimport { IStakeManager } from \"@ERC4337/account-abstraction/contracts/interfaces/IStakeManager.sol\";\nimport { IAccount as IERC4337 } from\n    \"@ERC4337/account-abstraction/contracts/interfaces/IAccount.sol\";\nimport { IAccountExecute } from\n    \"@ERC4337/account-abstraction/contracts/interfaces/IAccountExecute.sol\";\n\n/* solhint-enable no-unused-import */\n"},"node_modules/@rhinestone/module-bases/src/interfaces/IERC1271.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.23;\n\n// bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\nbytes4 constant EIP1271_MAGIC_VALUE = 0x1626ba7e;\n\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param _dataHash Arbitrary length data signed on behalf of address(this)\n     * @param _signature Signature byte array associated with _data\n     *\n     * MUST return the bytes4 magic value 0x1626ba7e when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc >\n     * 0.5)\n     * MUST allow external calls\n     */\n    function isValidSignature(\n        bytes32 _dataHash,\n        bytes calldata _signature\n    )\n        external\n        view\n        returns (bytes4);\n}\n"},"node_modules/erc7579/src/lib/ModeLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title ModeLib\n * To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\n * encoding is used.\n *    Function Signature of execute function:\n *           function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\n * This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\n * context.\n * NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\n * implement\n * more complex execution modes may use the entire bytes32.\n *\n * |--------------------------------------------------------------------|\n * | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\n * |--------------------------------------------------------------------|\n * | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\n * |--------------------------------------------------------------------|\n *\n * CALLTYPE: 1 byte\n * CallType is used to determine how the executeCalldata paramter of the execute function has to be\n * decoded.\n * It can be either single, batch or delegatecall. In the future different calls could be added.\n * CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\n *\n * EXECTYPE: 1 byte\n * ExecType is used to determine how the account should handle the execution.\n * It can indicate if the execution should revert on failure or continue execution.\n * In the future more execution modes may be added.\n * Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\n * a batch fails, the entire batch is reverted\n *\n * UNUSED: 4 bytes\n * Unused bytes are reserved for future use.\n *\n * ModeSelector: bytes4\n * The \"optional\" mode selector can be used by account vendors, to implement custom behavior in\n * their accounts.\n * the way a ModeSelector is to be calculated is bytes4(keccak256(\"vendorname.featurename\"))\n * this is to prevent collisions between different vendors, while allowing innovation and the\n * development of new features without coordination between ERC-7579 implementing accounts\n *\n * ModePayload: 22 bytes\n * Mode payload is used to pass additional data to the smart account execution, this may be\n * interpreted depending on the ModeSelector\n *\n * ExecutionCallData: n bytes\n * single, delegatecall or batch exec abi.encoded as bytes\n */\nimport { Execution } from \"../interfaces/IERC7579Account.sol\";\n\n// Custom type for improved developer experience\ntype ModeCode is bytes32;\n\ntype CallType is bytes1;\n\ntype ExecType is bytes1;\n\ntype ModeSelector is bytes4;\n\ntype ModePayload is bytes22;\n\n// Default CallType\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\n// Batched CallType\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\n// @dev Implementing delegatecall is OPTIONAL!\n// implement delegatecall with extreme care.\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\n\n// @dev default behavior is to revert on failure\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\n// Since this is value 0x00, no additional encoding is required for simple accounts\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\n// @dev account may elect to change execution behavior. For example \"try exec\" / \"allow fail\"\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\n\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\n// Example declaration of a custom mode selector\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\"default.mode.offset\")));\n\n/**\n * @dev ModeLib is a helper library to encode/decode ModeCodes\n */\nlibrary ModeLib {\n    function decode(ModeCode mode)\n        internal\n        pure\n        returns (\n            CallType _calltype,\n            ExecType _execType,\n            ModeSelector _modeSelector,\n            ModePayload _modePayload\n        )\n    {\n        assembly {\n            _calltype := mode\n            _execType := shl(8, mode)\n            _modeSelector := shl(48, mode)\n            _modePayload := shl(80, mode)\n        }\n    }\n\n    function encode(\n        CallType callType,\n        ExecType execType,\n        ModeSelector mode,\n        ModePayload payload\n    )\n        internal\n        pure\n        returns (ModeCode)\n    {\n        return ModeCode.wrap(\n            bytes32(\n                abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)\n            )\n        );\n    }\n\n    function encodeSimpleBatch() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeSimpleSingle() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function getCallType(ModeCode mode) internal pure returns (CallType calltype) {\n        assembly {\n            calltype := mode\n        }\n    }\n}\n\nusing { eqModeSelector as == } for ModeSelector global;\nusing { eqCallType as == } for CallType global;\nusing { eqExecType as == } for ExecType global;\n\nfunction eqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) == CallType.unwrap(b);\n}\n\nfunction eqExecType(ExecType a, ExecType b) pure returns (bool) {\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\n}\n\nfunction eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\n}\n"},"contracts/ISmartSession.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"./DataTypes.sol\";\nimport { PackedUserOperation } from \"modulekit/external/ERC4337.sol\";\nimport { CallType, ExecType, ModeCode as ExecutionMode } from \"erc7579/lib/ModeLib.sol\";\n\n/**\n * @title ISmartSession\n * @author Filipp Makarov (Biconomy) & zeroknots.eth (Rhinestone)\n * @dev A collaborative effort between Rhinestone and Biconomy to create a powerful\n *      and flexible session key management system for ERC-4337 and ERC-7579 accounts.\n * SmartSession is an advanced module for ERC-4337 and ERC-7579 compatible smart contract wallets, enabling granular\n * control over session keys. It allows users to create and manage temporary, limited-permission access to their\n * accounts through configurable policies. The module supports various policy types, including user operation\n * validation, action-specific policies, and ERC-1271 signature validation. SmartSession implements a unique \"enable\n * flow\" that allows session keys to be created within the first user operation, enhancing security and user experience.\n * It uses a nested EIP-712 approach for signature validation, providing phishing resistance and compatibility with\n * existing wallet interfaces. The module also supports batched executions and integrates with external policy contracts\n * for flexible permission management. Overall, SmartSession offers a comprehensive solution for secure, temporary\n * account access in the evolving landscape of account abstraction.\n */\ninterface ISmartSession {\n    error AssociatedArray_OutOfBounds(uint256 index);\n    error ChainIdMismatch(uint64 providedChainId);\n    error HashIndexOutOfBounds(uint256 index);\n    error HashMismatch(bytes32 providedHash, bytes32 computedHash);\n    error InvalidData();\n    error InvalidActionId();\n    error NoExecutionsInBatch();\n    error InvalidTarget();\n    error InvalidEnableSignature(address account, bytes32 hash);\n    error InvalidISessionValidator(ISessionValidator sessionValidator);\n    error InvalidSelfCall();\n    error InvalidSession(PermissionId permissionId);\n    error InvalidSessionKeySignature(\n        PermissionId permissionId, address sessionValidator, address account, bytes32 userOpHash\n    );\n    error SmartSessionModuleAlreadyInstalled(address account);\n    error InvalidPermissionId(PermissionId permissionId);\n    error InvalidCallTarget();\n    error InvalidMode();\n    error InvalidUserOpSender(address sender);\n    error NoPoliciesSet(PermissionId permissionId);\n    error PartlyEnabledActions();\n    error PartlyEnabledPolicies();\n    error PolicyViolation(PermissionId permissionId, address policy);\n    error SignerNotFound(PermissionId permissionId, address account);\n    error UnsupportedCallType(CallType callType);\n    error UnsupportedExecutionType();\n    error UnsupportedPolicy(address policy);\n    error UnsupportedSmartSessionMode(SmartSessionMode mode);\n    error ForbiddenValidationData();\n    error PaymasterValidationNotEnabled(PermissionId permissionId);\n\n    event NonceIterated(PermissionId permissionId, address account, uint256 newValue);\n    event SessionValidatorEnabled(PermissionId permissionId, address sessionValidator, address smartAccount);\n    event SessionValidatorDisabled(PermissionId permissionId, address sessionValidator, address smartAccount);\n    event PolicyDisabled(PermissionId permissionId, PolicyType policyType, address policy, address smartAccount);\n    event ActionIdDisabled(PermissionId permissionId, ActionId actionId, address smartAccount);\n    event PolicyEnabled(PermissionId permissionId, PolicyType policyType, address policy, address smartAccount);\n    event SessionCreated(PermissionId permissionId, address account);\n    event SessionRemoved(PermissionId permissionId, address smartAccount);\n\n    event PermissionIdPermit4337Paymaster(PermissionId permissionId, address smartAccount, bool enabled);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           ERC7579                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * ERC4337/ERC7579 validation function\n     * the primary purpose of this function, is to validate if a userOp forwarded by a 7579 account is valid.\n     * This function will dissect the userop.signature field, and parse out the provided PermissionId, which identifies\n     * a\n     * unique ID of a dapp for a specific user. n Policies and one Signer contract are mapped to this Id and will be\n     * checked. Only UserOps that pass policies and signer checks, are considered valid.\n     * Enable Flow:\n     *     SmartSessions allows session keys to be created within the \"first\" UserOp. If the enable flow is chosen, the\n     *     EnableSession data, which is packed in userOp.signature is parsed, and stored in the SmartSession storage.\n     *\n     */\n    function validateUserOp(\n        PackedUserOperation memory userOp,\n        bytes32 userOpHash\n    )\n        external\n        returns (ValidationData vd);\n    /**\n     * ERC7579 compliant onInstall function.\n     * expected to abi.encode(Session[]) for the enable data\n     *\n     * Note: It's possible to install the smartsession module with data = \"\"\n     */\n    function onInstall(bytes memory data) external;\n\n    /**\n     * ERC7579 compliant uninstall function.\n     * will wipe all configIds and associated Policies / Signers\n     */\n    function onUninstall(bytes memory) external;\n\n    /**\n     * ERC7579 compliant ERC1271 function\n     * this function allows session keys to sign ERC1271 requests.\n     */\n    function isValidSignatureWithSender(\n        address sender,\n        bytes32 hash,\n        bytes memory signature\n    )\n        external\n        view\n        returns (bytes4 result);\n\n    function isInitialized(address smartAccount) external view returns (bool);\n    function isModuleType(uint256 typeID) external pure returns (bool);\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      Manage Sessions                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    function enableActionPolicies(PermissionId permissionId, ActionData[] memory actionPolicies) external;\n    function enableERC1271Policies(PermissionId permissionId, ERC7739Data calldata erc1271Policies) external;\n    function enableSessions(Session[] memory sessions) external returns (PermissionId[] memory permissionIds);\n    function enableUserOpPolicies(PermissionId permissionId, PolicyData[] memory userOpPolicies) external;\n    function disableActionPolicies(PermissionId permissionId, ActionId actionId, address[] memory policies) external;\n    function disableActionId(PermissionId permissionId, ActionId actionId) external;\n    function disableERC1271Policies(\n        PermissionId permissionId,\n        address[] memory policies,\n        ERC7739Context[] calldata contexts\n    )\n        external;\n    function disableUserOpPolicies(PermissionId permissionId, address[] memory policies) external;\n    function removeSession(PermissionId permissionId) external;\n    function revokeEnableSignature(PermissionId permissionId) external;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      View Functions                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function getSessionDigest(\n        PermissionId permissionId,\n        address account,\n        Session memory data,\n        SmartSessionMode mode\n    )\n        external\n        view\n        returns (bytes32);\n\n    function getNonce(PermissionId permissionId, address account) external view returns (uint256);\n    function getPermissionId(Session memory session) external pure returns (PermissionId permissionId);\n    function isPermissionEnabled(PermissionId permissionId, address account) external view returns (bool);\n\n    function getPermissionIDs(address account) external view returns (PermissionId[] memory permissionIds);\n}\n"},"contracts/core/SmartSessionBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.25;\n\nimport \"../DataTypes.sol\";\nimport { ISmartSession } from \"../ISmartSession.sol\";\nimport { EnumerableSet } from \"../utils/EnumerableSet4337.sol\";\nimport { EnumerableMap } from \"../utils/EnumerableMap4337.sol\";\nimport { ConfigLib } from \"../lib/ConfigLib.sol\";\nimport { EncodeLib } from \"../lib/EncodeLib.sol\";\nimport { PolicyLib } from \"../lib/PolicyLib.sol\";\nimport { IdLib } from \"../lib/IdLib.sol\";\nimport { HashLib } from \"../lib/HashLib.sol\";\nimport { SmartSessionModeLib } from \"../lib/SmartSessionModeLib.sol\";\nimport { NonceManager } from \"./NonceManager.sol\";\nimport { FlatBytesLib } from \"flatbytes/BytesLib.sol\";\n\nabstract contract SmartSessionBase is ISmartSession, NonceManager {\n    using EnumerableMap for EnumerableMap.Bytes32ToBytes32Map;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SmartSessionModeLib for SmartSessionMode;\n    using HashLib for *;\n    using PolicyLib for *;\n    using ConfigLib for *;\n    using EncodeLib for *;\n    using IdLib for *;\n    using ConfigLib for Policy;\n    using ConfigLib for EnumerableActionPolicy;\n    using FlatBytesLib for FlatBytesLib.Bytes;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    SmartSession Storage                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * In order to comply with ERC-4337 storage restrictions, every storage in smart session is using associated\n     * storage.\n     */\n    Policy internal $userOpPolicies;\n    Policy internal $erc1271Policies;\n    EnumerableActionPolicy internal $actionPolicies;\n    EnumerableSet.Bytes32Set internal $enabledSessions;\n    EnumerableERC7739Config internal $enabledERC7739;\n    mapping(PermissionId permissionId => mapping(address smartAccount => SignerConf conf)) internal $sessionValidators;\n    mapping(PermissionId permissionId => mapping(address smartAccount => bool permitERC4337Paymaster)) internal\n        $permitERC4337Paymaster;\n\n    /**\n     * Before enabling policies, we need to check if the session is enabled for the caller and the given permission\n     * after enabling policies, we need to check if the session is still enabled for the caller and the given\n     * permission. This is to ensure that the session is still enabled after the operation and no re-entrancy is\n     * possible\n     */\n    modifier enableWithPermissionId(PermissionId permissionId) {\n        // Check if the session is enabled for the caller and the given permission before enabling policies on it\n        $enabledSessions.requirePermissionIdEnabled(permissionId);\n        _;\n        // Check if the session is enabled for the caller and the given permission after enabling policies on it\n        // this is to ensure that the session is still enabled after the operation and no re-entrancy is possible\n        $enabledSessions.requirePermissionIdEnabled(permissionId);\n    }\n\n    /**\n     * Before disabling policies, we need to check if the session is enabled for the caller and the given permission\n     */\n    modifier disableWithPermissionId(PermissionId permissionId) {\n        // Check if the session is enabled for the caller and the given permission before enabling policies on it\n        $enabledSessions.requirePermissionIdEnabled(permissionId);\n        _;\n    }\n\n    function getPermissionIDs(address account) external view returns (PermissionId[] memory permissionIds) {\n        bytes32[] memory _permissionIds = $enabledSessions.values(account);\n        assembly {\n            permissionIds := _permissionIds\n        }\n    }\n\n    /**\n     * @notice Enable user operation policies for a specific permission\n     * @dev This function allows adding or updating user operation policies\n     * @param permissionId The unique identifier for the permission\n     * @param userOpPolicies An array of PolicyData structures containing policy information\n     */\n    function enableUserOpPolicies(\n        PermissionId permissionId,\n        PolicyData[] memory userOpPolicies\n    )\n        public\n        enableWithPermissionId(permissionId)\n    {\n        // Enable the specified user operation policies\n        $userOpPolicies.enable({\n            policyType: PolicyType.USER_OP,\n            permissionId: permissionId,\n            configId: permissionId.toUserOpPolicyId().toConfigId(),\n            policyDatas: userOpPolicies,\n            useRegistry: false\n        });\n    }\n\n    /**\n     * @notice Disable specific user operation policies for a given permission\n     * @param permissionId The unique identifier for the permission\n     * @param policies An array of policy addresses to be disabled\n     */\n    function disableUserOpPolicies(\n        PermissionId permissionId,\n        address[] calldata policies\n    )\n        public\n        disableWithPermissionId(permissionId)\n    {\n        // Disable the specified user operation policies\n        $userOpPolicies.disable({\n            policyType: PolicyType.USER_OP,\n            smartAccount: msg.sender,\n            permissionId: permissionId,\n            policies: policies\n        });\n    }\n\n    function setPermit4337Paymaster(PermissionId permissionId, bool enabled) external {\n        $enabledSessions.requirePermissionIdEnabled(permissionId);\n        _setPermit4337Paymaster(permissionId, enabled);\n    }\n\n    function _setPermit4337Paymaster(PermissionId permissionId, bool enabled) internal {\n        $permitERC4337Paymaster[permissionId][msg.sender] = enabled;\n        emit PermissionIdPermit4337Paymaster(permissionId, msg.sender, enabled);\n    }\n\n    /**\n     * @notice Enable ERC1271 policies for a specific permission\n     * @param permissionId The unique identifier for the permission\n     * @param erc1271Policies An array of PolicyData structures containing ERC1271 policy information\n     */\n    function enableERC1271Policies(\n        PermissionId permissionId,\n        ERC7739Data calldata erc1271Policies\n    )\n        public\n        enableWithPermissionId(permissionId)\n    {\n        // Enable the ERC1271 policies\n        $enabledERC7739.enable({ contexts: erc1271Policies.allowedERC7739Content, permissionId: permissionId });\n        $erc1271Policies.enable({\n            policyType: PolicyType.ERC1271,\n            permissionId: permissionId,\n            configId: permissionId.toErc1271PolicyId().toConfigId(),\n            policyDatas: erc1271Policies.erc1271Policies,\n            useRegistry: false\n        });\n    }\n\n    /**\n     * @notice Disable specific ERC1271 policies and contents for a given permission\n     * @param permissionId The unique identifier for the permission\n     * @param policies An array of policy addresses to be disabled\n     * @param contexts An array of 7739 contents to be disabled\n     */\n    function disableERC1271Policies(\n        PermissionId permissionId,\n        address[] calldata policies,\n        ERC7739Context[] calldata contexts\n    )\n        public\n        disableWithPermissionId(permissionId)\n    {\n        // Check if the session is enabled for the caller and the given permission\n        // forgefmt: disable-next-item\n        if (!$enabledSessions.contains(msg.sender, PermissionId.unwrap(permissionId))) revert InvalidSession(permissionId);\n\n        $enabledERC7739.disable(contexts, permissionId, msg.sender);\n\n        // Disable the specified ERC1271 policies\n        $erc1271Policies.disable({\n            policyType: PolicyType.ERC1271,\n            smartAccount: msg.sender,\n            permissionId: permissionId,\n            policies: policies\n        });\n    }\n\n    /**\n     * @notice Enable action policies for a specific permission\n     * @param permissionId The unique identifier for the permission\n     * @param actionPolicies An array of ActionData structures containing action policy information\n     */\n    function enableActionPolicies(\n        PermissionId permissionId,\n        ActionData[] memory actionPolicies\n    )\n        public\n        enableWithPermissionId(permissionId)\n    {\n        // Enable the action policies\n        $actionPolicies.enable({ permissionId: permissionId, actionPolicyDatas: actionPolicies, useRegistry: false });\n    }\n\n    /**\n     * @notice Disable specific action policies for a given permission and action ID\n     * @param permissionId The unique identifier for the permission\n     * @param actionId The specific action identifier\n     */\n    function disableActionId(\n        PermissionId permissionId,\n        ActionId actionId\n    )\n        public\n        disableWithPermissionId(permissionId)\n    {\n        // Disable all action policies for the given action ID\n        // No need to emit events here, as unlike with 7739contents and 1271 policies,\n        // here disabling the actionId means all action policies are also disabled\n        $actionPolicies.actionPolicies[actionId].policyList[permissionId].removeAll(msg.sender);\n\n        // remove action Id from enabledActionIds\n        $actionPolicies.enabledActionIds[permissionId].remove(msg.sender, ActionId.unwrap(actionId));\n        emit ISmartSession.ActionIdDisabled(permissionId, actionId, msg.sender);\n    }\n\n    /**\n     * @notice Disable action id for a given permission and action ID\n     * @param permissionId The unique identifier for the permission\n     * @param actionId The specific action identifier\n     * @param policies An array of policy addresses to be disabled\n     */\n    function disableActionPolicies(\n        PermissionId permissionId,\n        ActionId actionId,\n        address[] calldata policies\n    )\n        public\n        disableWithPermissionId(permissionId)\n    {\n        // Disable the specified action policies for the given action ID\n        $actionPolicies.actionPolicies[actionId].disable({\n            policyType: PolicyType.ACTION,\n            smartAccount: msg.sender,\n            permissionId: permissionId,\n            policies: policies\n        });\n\n        // remove the actionId from the enabledActionIds if no policies are left\n        if ($actionPolicies.actionPolicies[actionId].policyList[permissionId].length(msg.sender) == 0) {\n            $actionPolicies.enabledActionIds[permissionId].remove(msg.sender, ActionId.unwrap(actionId));\n            emit ISmartSession.ActionIdDisabled(permissionId, actionId, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Enable multiple sessions with their associated policies\n     * since this function is only called during the ERC-4337 execution phase, it is safe to use the registry\n     * @param sessions An array of Session structures to be enabled\n     * @return permissionIds An array of PermissionId values corresponding to the enabled sessions\n     */\n    function enableSessions(Session[] calldata sessions) external returns (PermissionId[] memory permissionIds) {\n        return _enableSessions(sessions, true);\n    }\n\n    /**\n     * @notice Enable multiple sessions with their associated policies\n     * @param sessions An array of Session structures to be enabled\n     * @param useRegistry A flag to indicate whether to use a registry check for the policies and session validator\n     * @return permissionIds An array of PermissionId values corresponding to the enabled sessions\n     */\n    function _enableSessions(\n        Session[] calldata sessions,\n        bool useRegistry\n    )\n        internal\n        returns (PermissionId[] memory permissionIds)\n    {\n        uint256 length = sessions.length;\n        if (length == 0) revert InvalidData();\n\n        permissionIds = new PermissionId[](length);\n\n        for (uint256 i; i < length; i++) {\n            Session calldata session = sessions[i];\n            PermissionId permissionId = session.toPermissionId();\n\n            // Enable UserOp policies\n            $userOpPolicies.enable({\n                policyType: PolicyType.USER_OP,\n                permissionId: permissionId,\n                configId: permissionId.toUserOpPolicyId().toConfigId(),\n                policyDatas: session.userOpPolicies,\n                useRegistry: useRegistry\n            });\n\n            // Enable ERC1271 policies\n            $erc1271Policies.enable({\n                policyType: PolicyType.ERC1271,\n                permissionId: permissionId,\n                configId: permissionId.toErc1271PolicyId().toConfigId(),\n                policyDatas: session.erc7739Policies.erc1271Policies,\n                useRegistry: useRegistry\n            });\n            $enabledERC7739.enable(session.erc7739Policies.allowedERC7739Content, permissionId);\n\n            // Enable Action policies\n            $actionPolicies.enable({\n                permissionId: permissionId,\n                actionPolicyDatas: session.actions,\n                useRegistry: useRegistry\n            });\n\n            // Add the session to the list of enabled sessions for the caller\n            $enabledSessions.add({ account: msg.sender, value: PermissionId.unwrap(permissionId) });\n\n            _setPermit4337Paymaster(permissionId, session.permitERC4337Paymaster);\n\n            // Enable the ISessionValidator for this session\n            if (!_isISessionValidatorSet(permissionId, msg.sender)) {\n                $sessionValidators.enable({\n                    permissionId: permissionId,\n                    sessionValidator: session.sessionValidator,\n                    sessionValidatorConfig: session.sessionValidatorInitData,\n                    useRegistry: useRegistry\n                });\n            }\n            permissionIds[i] = permissionId;\n            emit SessionCreated(permissionId, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Remove a session and all its associated policies\n     * @param permissionId The unique identifier for the session to be removed\n     */\n    function removeSession(PermissionId permissionId) public {\n        if (permissionId == EMPTY_PERMISSIONID) revert InvalidSession(permissionId);\n\n        // Remove all UserOp policies for this session\n        $userOpPolicies.policyList[permissionId].removeAll(msg.sender);\n\n        // Remove all ERC1271 policies for this session\n        $erc1271Policies.policyList[permissionId].removeAll(msg.sender);\n\n        // Remove all Action policies for this session\n        uint256 actionLength = $actionPolicies.enabledActionIds[permissionId].length(msg.sender);\n        for (uint256 i; i < actionLength; i++) {\n            ActionId actionId = ActionId.wrap($actionPolicies.enabledActionIds[permissionId].at(msg.sender, i));\n            $actionPolicies.actionPolicies[actionId].policyList[permissionId].removeAll(msg.sender);\n        }\n\n        // removing all stored actionIds\n        $actionPolicies.enabledActionIds[permissionId].removeAll(msg.sender);\n\n        $sessionValidators.disable({ permissionId: permissionId, smartAccount: msg.sender });\n        delete $permitERC4337Paymaster[permissionId][msg.sender];\n\n        // Remove all ERC1271 policies for this session\n        $enabledSessions.remove({ account: msg.sender, value: PermissionId.unwrap(permissionId) });\n        $enabledERC7739.removeAll({ permissionId: permissionId, smartAccount: msg.sender });\n        emit SessionRemoved(permissionId, msg.sender);\n    }\n\n    /**\n     * Initialize the module with the given data\n     *\n     * @param data The data to initialize the module with\n     *         data is expected to be in the format of: abi.encode(SmartSessionMode, abi.encode(Session[]))\n     *         if no data is provided, the module will be installed without any sessions\n     */\n    function onInstall(bytes calldata data) external override {\n        // Its possible that the module was installed before and when uninstalling the module, the smart session storage\n        // for that smart account was not zero'ed correctly. In such cases, we need to check if the smart account has\n        // still some enabled permissions / sessions set.\n        // re-enabling these sessions will cause the smart account to be in the same state as before, potentially\n        // activating sessions that the user thought were terminated. This MUST be avoided.\n        // if this case happens, it's not possible for the account to install the module again, unless the account calls\n        // into the removreSession functions to disable all dangling permissions\n        // forgefmt: disable-next-item\n        if ($enabledSessions.length({ account: msg.sender }) != 0) revert SmartSessionModuleAlreadyInstalled(msg.sender);\n        // It's allowed to install smartsessions on a ERC7579 account without any params\n        if (data.length == 0) return;\n\n        // data is expected to be in the format of:\n        //    abi.encodePacked(SmartSessionMode, abi.encode(Session[]))\n        SmartSessionMode mode = SmartSessionMode(uint8(bytes1(data[:1])));\n        // ensure that the mode provided is a valid ENABLE mode\n        if (!mode.isEnableMode()) revert InvalidMode();\n        // nudge the data pointer to the next byte to make decoding easier\n        data = data[1:];\n        Session[] calldata sessions;\n\n        // equivalent of abi.decode(data,Session[])\n        assembly (\"memory-safe\") {\n            let dataPointer := add(data.offset, calldataload(data.offset))\n\n            sessions.offset := add(dataPointer, 32)\n            sessions.length := calldataload(dataPointer)\n        }\n        _enableSessions(sessions, mode.useRegistry());\n    }\n\n    /**\n     * De-initialize the module with the given data.\n     * All PermissionIds will be wiped from storage\n     */\n    function onUninstall(bytes calldata /*data*/ ) external override {\n        uint256 configIdsCnt = $enabledSessions.length({ account: msg.sender });\n\n        for (uint256 i; i < configIdsCnt; i++) {\n            // always remove index 0 since the array is shifted down when the first item is removed\n            PermissionId configId = PermissionId.wrap($enabledSessions.at({ account: msg.sender, index: 0 }));\n            removeSession(configId);\n        }\n    }\n\n    function isInitialized(address smartAccount) external view override returns (bool) {\n        return $enabledSessions.length({ account: smartAccount }) != 0;\n    }\n\n    function isModuleType(uint256 typeID) external pure override returns (bool) {\n        return typeID == ERC7579_MODULE_TYPE_VALIDATOR;\n    }\n\n    function getSessionDigest(\n        PermissionId permissionId,\n        address account,\n        Session memory data,\n        SmartSessionMode mode\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        uint256 nonce = $signerNonce[permissionId][account];\n        return data.sessionDigest({ account: account, mode: mode, nonce: nonce });\n    }\n\n    function getPermissionId(Session calldata session) public pure returns (PermissionId permissionId) {\n        permissionId = session.toPermissionId();\n    }\n\n    function _isISessionValidatorSet(PermissionId permissionId, address account) internal view returns (bool) {\n        return address($sessionValidators[permissionId][account].sessionValidator) != address(0);\n    }\n\n    function isISessionValidatorSet(PermissionId permissionId, address account) external view returns (bool) {\n        return _isISessionValidatorSet(permissionId, account);\n    }\n\n    function isPermissionEnabled(PermissionId permissionId, address account) external view returns (bool) {\n        return $enabledSessions.contains(account, PermissionId.unwrap(permissionId));\n    }\n\n    // This function accepts not the array of policies, but full PolicyData,\n    // So it is easier to use it with an EnableSessions object\n    // If you just need to check array of addresses, use is____PolicyEnabled methods in a loop\n    function areUserOpPoliciesEnabled(\n        address account,\n        PermissionId permissionId,\n        PolicyData[] calldata userOpPolicies\n    )\n        external\n        view\n        returns (bool)\n    {\n        return $userOpPolicies.areEnabled({\n            permissionId: permissionId,\n            smartAccount: account,\n            policyDatas: userOpPolicies\n        });\n    }\n\n    // This function accepts not the array of policies, but full PolicyData,\n    // So it is easier to use it with an EnableSessions object\n    function areERC1271PoliciesEnabled(\n        address account,\n        PermissionId permissionId,\n        PolicyData[] calldata erc1271Policies\n    )\n        external\n        view\n        returns (bool)\n    {\n        return $erc1271Policies.areEnabled({\n            permissionId: permissionId,\n            smartAccount: account,\n            policyDatas: erc1271Policies\n        });\n    }\n\n    // This function accepts not the array of policies, but full ActionData,\n    // So it is easier to use it with an EnableSessions object\n    function areActionsEnabled(\n        address account,\n        PermissionId permissionId,\n        ActionData[] calldata actions\n    )\n        external\n        view\n        returns (bool)\n    {\n        return $actionPolicies.areEnabled({\n            permissionId: permissionId,\n            smartAccount: account,\n            actionPolicyDatas: actions\n        });\n    }\n\n    function isUserOpPolicyEnabled(\n        address account,\n        PermissionId permissionId,\n        address policy\n    )\n        external\n        view\n        returns (bool)\n    {\n        return $userOpPolicies.policyList[permissionId].contains(account, policy);\n    }\n\n    function isERC1271PolicyEnabled(\n        address account,\n        PermissionId permissionId,\n        address policy\n    )\n        external\n        view\n        returns (bool)\n    {\n        return $erc1271Policies.policyList[permissionId].contains(account, policy);\n    }\n\n    // for action policies\n    function isActionPolicyEnabled(\n        address account,\n        PermissionId permissionId,\n        ActionId actionId,\n        address policy\n    )\n        external\n        view\n        returns (bool)\n    {\n        return $actionPolicies.actionPolicies[actionId].policyList[permissionId].contains(account, policy);\n    }\n\n    // for actionIds\n    function isActionIdEnabled(\n        address account,\n        PermissionId permissionId,\n        ActionId actionId\n    )\n        external\n        view\n        returns (bool)\n    {\n        return $actionPolicies.enabledActionIds[permissionId].contains(account, ActionId.unwrap(actionId));\n    }\n\n    function isERC7739ContentEnabled(\n        address account,\n        PermissionId permissionId,\n        bytes32 appDomainSeparator,\n        string memory content\n    )\n        external\n        view\n        returns (bool)\n    {\n        return $enabledERC7739.enabledContentNames[permissionId][appDomainSeparator].contains(\n            account, content.hashERC7739Content()\n        );\n    }\n\n    function getUserOpPolicies(address account, PermissionId permissionId) external view returns (address[] memory) {\n        return $userOpPolicies.policyList[permissionId].values(account);\n    }\n\n    function getERC1271Policies(address account, PermissionId permissionId) external view returns (address[] memory) {\n        return $erc1271Policies.policyList[permissionId].values(account);\n    }\n\n    function getActionPolicies(\n        address account,\n        PermissionId permissionId,\n        ActionId actionId\n    )\n        external\n        view\n        returns (address[] memory)\n    {\n        return $actionPolicies.actionPolicies[actionId].policyList[permissionId].values(account);\n    }\n\n    function getEnabledActions(address account, PermissionId permissionId) external view returns (bytes32[] memory) {\n        return $actionPolicies.enabledActionIds[permissionId].values(account);\n    }\n\n    function getEnabledERC7739Content(\n        address account,\n        PermissionId permissionId\n    )\n        external\n        view\n        returns (ERC7739ContextHashes[] memory enabledERC7739ContentHashes)\n    {\n        uint256 length = $enabledERC7739.enabledDomainSeparators[permissionId].length(account);\n        enabledERC7739ContentHashes = new ERC7739ContextHashes[](length);\n        for (uint256 i; i < length; i++) {\n            enabledERC7739ContentHashes[i].appDomainSeparator =\n                $enabledERC7739.enabledDomainSeparators[permissionId].at(account, i);\n            enabledERC7739ContentHashes[i].contentNameHashes = $enabledERC7739.enabledContentNames[permissionId][enabledERC7739ContentHashes[i]\n                .appDomainSeparator].values(account);\n        }\n    }\n\n    function getSessionValidatorAndConfig(\n        address account,\n        PermissionId permissionId\n    )\n        external\n        view\n        returns (address sessionValidator, bytes memory sessionValidatorData)\n    {\n        SignerConf storage $s = $sessionValidators[permissionId][account];\n        sessionValidator = address($s.sessionValidator);\n        sessionValidatorData = $s.config.load();\n    }\n}\n"},"contracts/core/SmartSessionERC7739.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.25;\n\nimport { EIP712 } from \"solady/utils/EIP712.sol\";\nimport { ISmartSession } from \"../ISmartSession.sol\";\n\n/// @notice ERC1271 mixin with nested EIP-712 approach.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC1271.sol)\nabstract contract SmartSessionERC7739 is ISmartSession {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     ERC1271 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns whether the `hash` and `signature` are valid.\n    /// Override if you need non-ECDSA logic.\n    function _erc1271IsValidSignatureNowCalldata(\n        address sender,\n        bytes32 hash,\n        bytes calldata signature,\n        bytes32 appDomainSeparator,\n        bytes calldata contents\n    )\n        internal\n        view\n        virtual\n        returns (bool);\n\n    /// @dev Unwraps and returns the signature.\n    function _erc1271UnwrapSignature(bytes calldata signature) internal view virtual returns (bytes calldata result) {\n        result = signature;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Unwraps the ERC6492 wrapper if it exists.\n            // See: https://eips.ethereum.org/EIPS/eip-6492\n            if eq(\n                calldataload(add(result.offset, sub(result.length, 0x20))),\n                mul(0x6492, div(not(mload(0x60)), 0xffff)) // `0x6492...6492`.\n            ) {\n                let o := add(result.offset, calldataload(add(result.offset, 0x40)))\n                result.length := calldataload(o)\n                result.offset := add(o, 0x20)\n            }\n        }\n    }\n\n    /// @dev ERC1271 signature validation (Nested EIP-712 workflow).\n    /// @dev Currently known as ERC-7739\n    /// https://ethereum-magicians.org/t/erc-7739-readable-typed-signatures-for-smart-accounts/20513\n    /// This forwards signature verification to an appropriate ISessionValidator\n    /// see: `_erc1271IsValidSignatureNowCalldata`.\n    /// It also uses a nested EIP-712 approach to prevent signature replays when a single EOA\n    /// owns multiple smart contract accounts,\n    /// while still enabling wallet UIs (e.g. Metamask) to show the EIP-712 values.\n    ///\n    /// Crafted for phishing resistance, efficiency, flexibility.\n    /// __________________________________________________________________________________________\n    ///\n    /// Glossary:\n    ///\n    /// - `APP_DOMAIN_SEPARATOR`: The domain separator of the `hash` passed in by the application.\n    ///   Provided by the front end. Intended to be the domain separator of the contract\n    ///   that will call `isValidSignature` on this account.\n    ///\n    /// - `ACCOUNT_DOMAIN_SEPARATOR`: The domain separator of this account.\n    ///   See: `EIP712._domainSeparator()`.\n    /// __________________________________________________________________________________________\n    ///\n    /// For the `TypedDataSign` workflow, the final hash will be:\n    /// ```\n    ///     keccak256(\\x19\\x01 ‖ APP_DOMAIN_SEPARATOR ‖\n    ///         hashStruct(TypedDataSign({\n    ///             contents: hashStruct(originalStruct),\n    ///             name: keccak256(bytes(eip712Domain().name)),\n    ///             version: keccak256(bytes(eip712Domain().version)),\n    ///             chainId: eip712Domain().chainId,\n    ///             verifyingContract: eip712Domain().verifyingContract,\n    ///             salt: eip712Domain().salt,\n    ///             extensions: keccak256(abi.encodePacked(eip712Domain().extensions))\n    ///         }))\n    ///     )\n    /// ```\n    /// where `‖` denotes the concatenation operator for bytes.\n    /// The order of the fields is important: `contents` comes before `name`.\n    ///\n    /// The signature will be `r ‖ s ‖ v ‖\n    ///     APP_DOMAIN_SEPARATOR ‖ contents ‖ contentsType ‖ uint16(contentsType.length)`,\n    /// where `contents` is the bytes32 struct hash of the original struct.\n    ///\n    /// The `APP_DOMAIN_SEPARATOR` and `contents` will be used to verify if `hash` is indeed correct.\n    /// __________________________________________________________________________________________\n    ///\n    /// `PersonalSign` is not supported.\n    /// __________________________________________________________________________________________\n    ///\n    /// For demo and typescript code, see:\n    /// - https://github.com/junomonster/nested-eip-712\n    /// - https://github.com/frangio/eip712-wrapper-for-eip1271\n    ///\n    /// Their nomenclature may differ from ours, although the high-level idea is similar.\n    ///\n    /// Of course, if you have control over the codebase of the wallet client(s) too,\n    /// you can choose a more minimalistic signature scheme like\n    /// `keccak256(abi.encode(address(this), hash))` instead of all these acrobatics.\n    /// All these are just for widespread out-of-the-box compatibility with other wallet clients.\n    /// We want to create bazaars, not walled castles.\n    /// And we'll use push the Turing Completeness of the EVM to the limits to do so.\n\n    function _erc1271IsValidSignatureViaNestedEIP712(\n        address sender,\n        bytes32 hash,\n        bytes calldata signature\n    )\n        internal\n        view\n        virtual\n        returns (bool result)\n    {\n        bytes calldata contents = signature;\n        bytes32 appDomainSeparator;\n        uint256 t = uint256(uint160(address(this)));\n        // Forces the compiler to pop the variables after the scope, avoiding stack-too-deep.\n        if (t != uint256(0)) {\n            (, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt,) =\n                EIP712(msg.sender).eip712Domain();\n            /// @solidity memory-safe-assembly\n            assembly {\n                t := mload(0x40) // Grab the free memory pointer.\n                // Skip 2 words for the `typedDataSignTypehash` and `contents` struct hash.\n                mstore(add(t, 0x40), keccak256(add(name, 0x20), mload(name)))\n                mstore(add(t, 0x60), keccak256(add(version, 0x20), mload(version)))\n                mstore(add(t, 0x80), chainId)\n                mstore(add(t, 0xa0), shr(96, shl(96, verifyingContract)))\n                mstore(add(t, 0xc0), salt)\n                mstore(0x40, add(t, 0xe0)) // Allocate the memory.\n            }\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            // `c` is `contentsDescription.length`, which is stored in the last 2 bytes of the signature.\n            let c := shr(240, calldataload(add(signature.offset, sub(signature.length, 2))))\n            for { } 1 { } {\n                let l := add(0x42, c) // Total length of appended data (32 + 32 + c + 2).\n                let o := add(signature.offset, sub(signature.length, l)) // Offset of appended data.\n                mstore(0x00, 0x1901) // Store the \"\\x19\\x01\" prefix.\n                calldatacopy(0x20, o, 0x40) // Copy the `APP_DOMAIN_SEPARATOR` and `contents` struct hash.\n                // Only use the `TypedDataSign` workflow.\n                // `TypedDataSign({ContentsName} contents,string name,...){ContentsType}`.\n                mstore(m, \"TypedDataSign(\") // Store the start of `TypedDataSign`'s type encoding.\n                let p := add(m, 0x0e) // Advance 14 bytes to skip \"TypedDataSign(\".\n                calldatacopy(p, add(o, 0x40), c) // Copy `contentsName`, optimistically.\n\n                contents.offset := add(o, 0x40) // Set the offset of `contents`.\n                contents.length := c // Set the length of `contents`.\n                mstore(add(p, c), 40) // Store a '(' after the end.\n                if iszero(eq(byte(0, mload(sub(add(p, c), 1))), 41)) {\n                    let e := 0 // Length of `contentsName` in explicit mode.\n                    for { let q := sub(add(p, c), 1) } 1 { } {\n                        e := add(e, 1) // Scan backwards until we encounter a ')'.\n                        if iszero(gt(lt(e, c), eq(byte(0, mload(sub(q, e))), 41))) { break }\n                    }\n                    c := sub(c, e) // Truncate `contentsDescription` to `contentsType`.\n                    calldatacopy(p, add(add(o, 0x40), c), e) // Copy `contentsName`.\n                    mstore8(add(p, e), 40) // Store a '(' exactly right after the end.\n                }\n                // `d & 1 == 1` means that `contentsName` is invalid.\n                let d := shr(byte(0, mload(p)), 0x7fffffe000000000000010000000000) // Starts with `[a-z(]`.\n                // Advance `p` until we encounter '('.\n                for { } iszero(eq(byte(0, mload(p)), 40)) { p := add(p, 1) } {\n                    d := or(shr(byte(0, mload(p)), 0x120100000001), d) // Has a byte in \", )\\x00\".\n                }\n                mstore(p, \" contents,string name,string\") // Store the rest of the encoding.\n                mstore(add(p, 0x1c), \" version,uint256 chainId,address\")\n                mstore(add(p, 0x3c), \" verifyingContract,bytes32 salt)\")\n                p := add(p, 0x5c)\n                calldatacopy(p, add(o, 0x40), c) // Copy `contentsType`.\n                // Fill in the missing fields of the `TypedDataSign`.\n                calldatacopy(t, o, 0x40) // Copy the `contents` struct hash to `add(t, 0x20)`.\n                mstore(t, keccak256(m, sub(add(p, c), m))) // Store `typedDataSignTypehash`.\n                // The \"\\x19\\x01\" prefix is already at 0x00.\n                // `APP_DOMAIN_SEPARATOR` is already at 0x20.\n                appDomainSeparator := mload(0x20) // Load the `APP_DOMAIN_SEPARATOR`.\n                mstore(0x40, keccak256(t, 0xe0)) // `hashStruct(typedDataSign)`.\n                // Compute the final hash, corrupted if `contentsName` is invalid.\n                hash := keccak256(0x1e, add(0x42, and(1, d)))\n                signature.length := sub(signature.length, l) // Truncate the signature.\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n        result = _erc1271IsValidSignatureNowCalldata(sender, hash, signature, appDomainSeparator, contents);\n    }\n}\n"},"contracts/utils/EnumerableSet4337.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport \"./AssociatedArrayLib.sol\";\n\n/**\n * Fork of OZ's EnumerableSet that makes all storage access ERC-4337 compliant via associated storage\n * @author zeroknots.eth (rhinestone)\n */\nlibrary EnumerableSet {\n    using AssociatedArrayLib for AssociatedArrayLib.Bytes32Array;\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        AssociatedArrayLib.Bytes32Array _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => mapping(address account => uint256)) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, address account, bytes32 value) private returns (bool) {\n        if (!_contains(set, account, value)) {\n            set._values.push(account, value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value][account] = set._values.length(account);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, address account, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value][account];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length(account) - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values.get(account, lastIndex);\n\n                // Move the lastValue to the index where the value to delete is\n                set._values.set(account, valueIndex, lastValue);\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue][account] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop(account);\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value][account];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _removeAll(Set storage set, address account) internal {\n        // get length of the array\n        uint256 len = _length(set, account);\n        for (uint256 i = 1; i <= len; i++) {\n            // get last value\n            bytes32 value = _at(set, account, len - i);\n            _remove(set, account, value);\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, address account, bytes32 value) private view returns (bool) {\n        return set._positions[value][account] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set, address account) private view returns (uint256) {\n        return set._values.length(account);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, address account, uint256 index) private view returns (bytes32) {\n        return set._values.get(account, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set, address account) private view returns (bytes32[] memory) {\n        return set._values.getAll(account);\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, address account, bytes32 value) internal returns (bool) {\n        return _add(set._inner, account, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, address account, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, account, value);\n    }\n\n    function removeAll(Bytes32Set storage set, address account) internal {\n        return _removeAll(set._inner, account);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, address account, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, account, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set, address account) internal view returns (uint256) {\n        return _length(set._inner, account);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, address account, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, account, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set, address account) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner, account);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address account, address value) internal returns (bool) {\n        return _add(set._inner, account, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address account, address value) internal returns (bool) {\n        return _remove(set._inner, account, bytes32(uint256(uint160(value))));\n    }\n\n    function removeAll(AddressSet storage set, address account) internal {\n        return _removeAll(set._inner, account);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address account, address value) internal view returns (bool) {\n        return _contains(set._inner, account, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set, address account) internal view returns (uint256) {\n        return _length(set._inner, account);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, address account, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, account, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set, address account) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner, account);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, address account, uint256 value) internal returns (bool) {\n        return _add(set._inner, account, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, address account, uint256 value) internal returns (bool) {\n        return _remove(set._inner, account, bytes32(value));\n    }\n\n    function removeAll(UintSet storage set, address account) internal {\n        return _removeAll(set._inner, account);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, address account, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, account, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set, address account) internal view returns (uint256) {\n        return _length(set._inner, account);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, address account, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, account, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set, address account) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner, account);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"},"contracts/lib/ExecutionLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { Execution } from \"erc7579/interfaces/IERC7579Account.sol\";\nimport { CallType, ExecType, ModeCode as ExecutionMode } from \"erc7579/lib/ModeLib.sol\";\n\n/**\n * Helper Library for decoding Execution calldata\n * malloc for memory allocation is bad for gas. use this assembly instead\n */\nlibrary ExecutionLib {\n    error ERC7579DecodingError();\n\n    function decodeUserOpCallData(bytes calldata userOpCallData)\n        internal\n        pure\n        returns (bytes calldata erc7579ExecutionCalldata)\n    {\n        assembly {\n            if lt(userOpCallData.length, 68) { revert(0, 0) }\n            let baseOffset := add(userOpCallData.offset, 0x24) //skip 4 bytes of selector and 32 bytes of execution mode\n            let calldataLoadOffset := calldataload(baseOffset)\n            // check for potential overflow in calldataLoadOffset\n            if gt(calldataLoadOffset, 0xffffffffffffffff) { revert(0, 0) }\n            erc7579ExecutionCalldata.offset := add(baseOffset, calldataLoadOffset)\n            erc7579ExecutionCalldata.length := calldataload(sub(erc7579ExecutionCalldata.offset, 0x20))\n            if gt(erc7579ExecutionCalldata.length, 0xffffffffffffffff) { revert(0, 0) }\n\n            let calldataBound := add(userOpCallData.offset, userOpCallData.length)\n            // revert if erc7579ExecutionCalldata starts after userOp finishes and if erc7579ExecutionCalldata ends\n            // after userOp finishes\n            if gt(erc7579ExecutionCalldata.offset, calldataBound) { revert(0, 0) }\n            if gt(add(erc7579ExecutionCalldata.offset, erc7579ExecutionCalldata.length), calldataBound) { revert(0, 0) }\n        }\n    }\n\n    function get7579ExecutionMode(bytes calldata userOpCallData) internal pure returns (ExecutionMode mode) {\n        mode = ExecutionMode.wrap(bytes32(userOpCallData[4:36]));\n    }\n\n    function get7579ExecutionTypes(bytes calldata userOpCallData)\n        internal\n        pure\n        returns (CallType callType, ExecType execType)\n    {\n        ExecutionMode mode = ExecutionMode.wrap(bytes32(userOpCallData[4:36]));\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            callType := mode\n            execType := shl(8, mode)\n        }\n    }\n\n    /**\n     * @notice Decode a batch of `Execution` executionBatch from a `bytes` calldata.\n     * @dev code is copied from solady's LibERC7579.sol\n     * https://github.com/Vectorized/solady/blob/740812cedc9a1fc11e17cb3d4569744367dedf19/src/accounts/LibERC7579.sol#L146\n     *      Credits to Vectorized and the Solady Team\n     */\n    function decodeBatch(bytes calldata executionCalldata)\n        internal\n        pure\n        returns (Execution[] calldata executionBatch)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let u := calldataload(executionCalldata.offset)\n            let s := add(executionCalldata.offset, u)\n            let e := sub(add(executionCalldata.offset, executionCalldata.length), 0x20)\n            executionBatch.offset := add(s, 0x20)\n            executionBatch.length := calldataload(s)\n            if or(shr(64, u), gt(add(s, shl(5, executionBatch.length)), e)) {\n                mstore(0x00, 0xba597e7e) // `DecodingError()`.\n                revert(0x1c, 0x04)\n            }\n            if executionBatch.length {\n                // Perform bounds checks on the decoded `executionBatch`.\n                // Loop runs out-of-gas if `executionBatch.length` is big enough to cause overflows.\n                for { let i := executionBatch.length } 1 { } {\n                    i := sub(i, 1)\n                    let p := calldataload(add(executionBatch.offset, shl(5, i)))\n                    let c := add(executionBatch.offset, p)\n                    let q := calldataload(add(c, 0x40))\n                    let o := add(c, q)\n                    // forgefmt: disable-next-item\n                    if or(shr(64, or(calldataload(o), or(p, q))),\n                        or(gt(add(c, 0x40), e), gt(add(o, calldataload(o)), e))) {\n                        mstore(0x00, 0xba597e7e) // `DecodingError()`.\n                        revert(0x1c, 0x04)\n                    }\n                    if iszero(i) { break }\n                }\n            }\n        }\n    }\n\n    function encodeBatch(Execution[] memory executions) internal pure returns (bytes memory callData) {\n        callData = abi.encode(executions);\n    }\n\n    function decodeSingle(bytes calldata executionCalldata)\n        internal\n        pure\n        returns (address target, uint256 value, bytes calldata callData)\n    {\n        target = address(bytes20(executionCalldata[0:20]));\n        value = uint256(bytes32(executionCalldata[20:52]));\n        callData = executionCalldata[52:];\n    }\n\n    function encodeSingle(\n        address target,\n        uint256 value,\n        bytes memory callData\n    )\n        internal\n        pure\n        returns (bytes memory userOpCalldata)\n    {\n        userOpCalldata = abi.encodePacked(target, value, callData);\n    }\n}\n"},"contracts/interfaces/IPolicy.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.23;\n\nimport { PackedUserOperation, _packValidationData } from \"modulekit/external/ERC4337.sol\";\nimport { IModule as IERC7579Module, VALIDATION_SUCCESS, VALIDATION_FAILED } from \"erc7579/interfaces/IERC7579Module.sol\";\nimport \"../DataTypes.sol\";\nimport \"forge-std/interfaces/IERC165.sol\";\n\n/**\n * IPolicy are external contracts that enforce policies / permission on 4337/7579 executions\n * Since it's not the account calling into this contract, and check functions are called during the ERC4337 validation\n * phase, IPolicy implementations MUST follow ERC4337 storage and opcode restructions\n * A recommend storage layout to store policy related data:\n *      mapping(id   =>   msg.sender   =>   userOp.sender(account) => state)\n *                        ^ smartSession    ^ smart account (associated storage)\n */\ninterface IPolicy is IERC165 {\n    event PolicySet(ConfigId id, address multiplexer, address account);\n\n    error PolicyNotInitialized(ConfigId id, address multiplexer, address account);\n    /**\n     * This function may be called by the multiplexer (SmartSessions) without deinitializing first.\n     * Policies MUST overwrite the current state when this happens\n     * @notice ATTENTION: This method is called during permission installation as part of the enabling policies flow.\n     * A secure policy would minimize external calls from this method (ideally, to 0) to prevent passing control flow to\n     * external contracts.\n     */\n\n    function initializeWithMultiplexer(address account, ConfigId configId, bytes calldata initData) external;\n}\n\n/**\n * IUserOpPolicy is a policy that enforces restrictions on user operations. It is called during the validation phase\n * of the ERC4337 execution.\n * Use this policy to enforce restrictions on user operations (userOp.gas, Time based restrictions).\n * The checkUserOpPolicy function should return a uint256 value that represents the policy's decision.\n * The policy's decision should be one of the following:\n * - VALIDATION_SUCCESS: The user operation is allowed.\n * - VALIDATION_FAILED: The user operation is not allowed.\n * - While it is possible to return values that pack validUntil and validAfter timestamps,\n *   SmartSession Policies can not utilize aggregator addresses. (PolicyLib.isFailed() will prevent this)\n */\ninterface IUserOpPolicy is IPolicy {\n    function checkUserOpPolicy(ConfigId id, PackedUserOperation calldata userOp) external returns (uint256);\n}\n\n/**\n * IActionPolicy is a policy that enforces restrictions on actions. It is called during the validation phase\n * of the ERC4337 execution.\n * ERC7579 accounts natively support batched executions. So in one userOp, multiple actions can be executed.\n * SmartSession will destruct the execution batch, and call the policy for each action, if the policy is installed for\n * the actionId for the account.\n * Use this policy to enforce restrictions on individual actions (i.e. transfers, approvals, etc).\n * The checkAction function should return a uint256 value that represents the policy's decision.\n * The policy's decision should be one of the following:\n * - VALIDATION_SUCCESS: The action is allowed.\n * - VALIDATION_FAILED: The action is not allowed.\n */\ninterface IActionPolicy is IPolicy {\n    function checkAction(\n        ConfigId id,\n        address account,\n        address target,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns (uint256);\n}\n\n/**\n * I1271Policy is a policy that enforces restrictions on 1271 signed actions. It is called during an ERC1271 signature\n * validation\n */\ninterface I1271Policy is IPolicy {\n    // request sender is probably protocol, so can introduce policies based on it.\n    function check1271SignedAction(\n        ConfigId id,\n        address requestSender,\n        address account,\n        bytes32 hash,\n        bytes calldata signature\n    )\n        external\n        view\n        returns (bool);\n}\n"},"contracts/lib/PolicyLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.25;\n\nimport \"../DataTypes.sol\";\nimport { ISmartSession } from \"../ISmartSession.sol\";\nimport { IPolicy, IActionPolicy, I1271Policy } from \"../interfaces/IPolicy.sol\";\n\nimport { Execution, ExecutionLib as ExecutionLib } from \"./ExecutionLib.sol\";\nimport { ValidationDataLib } from \"./ValidationDataLib.sol\";\nimport { IdLib } from \"./IdLib.sol\";\nimport { EncodeLib } from \"./EncodeLib.sol\";\nimport { EnumerableSet } from \"../utils/EnumerableSet4337.sol\";\n\nimport { PackedUserOperation } from \"modulekit/external/ERC4337.sol\";\nimport { IERC7579Account } from \"erc7579/interfaces/IERC7579Account.sol\";\nimport { ExcessivelySafeCall } from \"excessively-safe-call/ExcessivelySafeCall.sol\";\n\nlibrary PolicyLib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using ExecutionLib for *;\n    using IdLib for *;\n    using PolicyLib for *;\n    using EncodeLib for *;\n    using ValidationDataLib for ValidationData;\n    using ExcessivelySafeCall for address;\n\n    /**\n     * Helper function to evaluate the ValidationData result of a policy check.\n     * To prevent Policies from returning a packed aggregator value, we use this bitmask.\n     */\n    function isFailed(ValidationData packedData) internal pure returns (bool sigFailed) {\n        sigFailed = (\n            ValidationData.unwrap(packedData) & 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff\n        ) != 0;\n    }\n\n    /**\n     * Multi-purpose helper function that interacts with external Policy Contracts.\n     * This function can be used to check different types of IPolicy functions.\n     * The specific function to be called on the policy is determined by the callDataOnIPolicy parameter.\n     *\n     * @dev This function iterates through all policies associated with the given permissionId and account,\n     *      calls each policy with the provided calldata, and intersects the resulting validation data.\n     *      It will revert if any policy check fails or if there are fewer policies than the specified minimum.\n     *\n     * @param $self The Policy storage struct containing the list of policies.\n     * @param permissionId The identifier for the permission being checked.\n     * @param callOnIPolicy The encoded function call data to be executed on each policy contract.\n     * @param minPolicies The minimum number of policies that must be present and checked.\n     *\n     * @return vd The intersected ValidationData result from all policy checks.\n     */\n    function check(\n        Policy storage $self,\n        PermissionId permissionId,\n        bytes memory callOnIPolicy,\n        uint256 minPolicies\n    )\n        internal\n        returns (ValidationData vd)\n    {\n        // Get the list of policies for the given permissionId and account\n        address[] memory policies = $self.policyList[permissionId].values({ account: msg.sender });\n        uint256 length = policies.length;\n\n        // Ensure the minimum number of policies is met.\n        // Revert otherwise. Current minPolicies for userOp policies is 0.\n        // Current minPolicies for action policies is 1.\n        // This ensures sudo (open) permissions can be created only by explicitly setting SudoPolicy/YesPolicy\n        // as the only action policies\n        if (minPolicies > length) revert ISmartSession.NoPoliciesSet(permissionId);\n\n        // Iterate over all policies and intersect the validation data\n        for (uint256 i; i < length; i++) {\n            // Intersect the validation data from this policy with the accumulated result\n            vd = vd.intersect(policies[i].callPolicy(permissionId, callOnIPolicy));\n        }\n    }\n\n    /**\n     * Same as check but will not revert if minimum number of policies is not met.\n     * This allows a second check with the FALLBACK_ACTIONID.\n     *\n     * @param $self The Policy storage struct containing the list of policies.\n     * @param permissionId The identifier for the permission being checked.\n     * @param callOnIPolicy The encoded function call data to be executed on each policy contract.\n     * @param minPolicies The minimum number of policies that must be present and checked.\n     *\n     * @return vd This value could either be:\n     *             - RETRY_WITH_FALLBACK if no adequate policies were set for this permissionId. Signaling the caller,\n     * that the Policy fallback procedure SHOULD be used\n     *             - Intersected Validation data of policies.\n     */\n    function tryCheck(\n        Policy storage $self,\n        PermissionId permissionId,\n        bytes memory callOnIPolicy,\n        uint256 minPolicies\n    )\n        internal\n        returns (ValidationData vd)\n    {\n        // Get the list of policies for the given permissionId and account\n        address[] memory policies = $self.policyList[permissionId].values({ account: msg.sender });\n        uint256 length = policies.length;\n\n        // Ensure the minimum number of policies is met. I.e. there are enough policies configured for given ActionId\n        // Current minPolicies is 1 for action policies. That means, if there is no policies at all confgured\n        // for a given ActionId (ActionId was not enabled), execution proceeds to the fallback flow.\n        // There can be any amount of fallback action policies configured, and those will be applied to all actionIds,\n        // that were not configured explicitly.\n        if (minPolicies > length) {\n            return RETRY_WITH_FALLBACK;\n        }\n\n        // Iterate over all policies and intersect the validation data\n        for (uint256 i; i < length; i++) {\n            // Intersect the validation data from this policy with the accumulated result\n            vd = vd.intersect(policies[i].callPolicy(permissionId, callOnIPolicy));\n        }\n\n        // Make sure policies can't alter the control flow\n        if (vd == RETRY_WITH_FALLBACK) revert ISmartSession.ForbiddenValidationData();\n    }\n\n    function callPolicy(\n        address policy,\n        PermissionId permissionId,\n        bytes memory callOnIPolicy\n    )\n        internal\n        returns (ValidationData _vd)\n    {\n        // Call the policy contract with the provided calldata\n        (bool success, bytes memory returnDataFromPolicy) = policy.excessivelySafeCall({\n            // To better align with the ERC-4337 validation rules, we replaced gasleft() with type(uint256).max.\n            // This will accomplish the same result of forwarding all remaining gas.\n            // Note that there is no error for attempting to use more gas than is currently available, as this has been\n            // allowed since https://eips.ethereum.org/EIPS/eip-150#specification\n            _gas: type(uint256).max,\n            _value: 0,\n            _maxCopy: 32,\n            _calldata: callOnIPolicy\n        });\n        uint256 validationDataFromPolicy;\n        assembly {\n            //if (!success) revert PolicyCheckReverted(bytes32);\n            if iszero(success) {\n                mstore(0, 0xf4270752) // `PolicyCheckReverted(bytes32)`\n                mstore(0x20, mload(add(returnDataFromPolicy, 0x20)))\n                revert(0x1c, 0x24)\n            }\n            validationDataFromPolicy := mload(add(returnDataFromPolicy, 0x20))\n        }\n        _vd = ValidationData.wrap(validationDataFromPolicy);\n        // Prevent a malfunctioning policy, to return the magic value RETRY_WITH_FALLBACK and change control flow\n        if (_vd.isFailed()) revert ISmartSession.PolicyViolation(permissionId, policy);\n    }\n\n    /**\n     * Checks policies for a single ERC7579 execution within a user operation.\n     * This function validates the execution against relevant action policies.\n     *\n     * @dev This function prevents potential bypass of policy checks through nested executions\n     *      by disallowing self-calls to the execute function.\n     *\n     * @param $policies The storage mapping of action policies.\n     * @param permissionId The identifier for the permission being checked.\n     * @param target The target address of the execution.\n     * @param value The ETH value being sent with the execution.\n     * @param callData The call data of the execution.\n     * @param minPolicies The minimum number of policies that must be checked.\n     *\n     * @return vd The validation data resulting from the policy checks.\n     */\n    function checkSingle7579Exec(\n        mapping(ActionId => Policy) storage $policies,\n        PermissionId permissionId,\n        address target,\n        uint256 value,\n        bytes calldata callData,\n        uint256 minPolicies\n    )\n        internal\n        returns (ValidationData vd)\n    {\n        // Extract the function selector from the call data\n        bytes4 targetSig;\n        if (callData.length < 4) {\n            targetSig = IdLib.VALUE_SELECTOR;\n        } else {\n            targetSig = bytes4(callData[0:4]);\n        }\n\n        // Prevent potential bypass of policy checks through nested self executions\n        if (targetSig == IERC7579Account.execute.selector && target == msg.sender) {\n            revert ISmartSession.InvalidSelfCall();\n        }\n\n        // Prevent fallback action from being used directly\n        if (target == FALLBACK_TARGET_FLAG) revert ISmartSession.InvalidTarget();\n\n        // malloc for actionId\n        ActionId actionId;\n\n        // should the target of this call be the smart session module itself, we will use the designated sentinel\n        // actionId for smartsession calls. The user has to explicitly set the smartsession call policy to allow this.\n        // @dev this is a special case, as a session key should normally not be utilized to configure other sessions\n        if (target == address(this)) {\n            actionId = FALLBACK_ACTIONID_SMARTSESSION_CALL;\n        }\n        // proceed with the normal flow\n        else {\n            // Generate the action ID based on the target and function selector\n            actionId = target.toActionId(targetSig);\n            // Check the relevant action policy\n            vd = $policies[actionId].tryCheck({\n                permissionId: permissionId,\n                callOnIPolicy: abi.encodeCall(\n                    IActionPolicy.checkAction, (permissionId.toConfigId(actionId), msg.sender, target, value, callData)\n                ),\n                minPolicies: minPolicies\n            });\n            // If tryCheck returns RETRY_WITH_FALLBACK magic value, that means not enough policies were configured\n            // for the actionId. Proceed with checking fallback action policies ($policies[FALLBACK_ACTIONID]).\n            if (vd == RETRY_WITH_FALLBACK) actionId = FALLBACK_ACTIONID;\n            // otherwise return the validation data\n            else return vd;\n        }\n        // call the fallback policy for either FALLBACK_ACTIONID or FALLBACK_ACTIONID_SMARTSESSION_CALL\n        // If no policies were configured for FALLBACK_ACTIONID or FALLBACK_ACTIONID_SMARTSESSION_CALL this call will\n        // revert\n        vd = $policies[actionId].check({\n            permissionId: permissionId,\n            callOnIPolicy: abi.encodeCall(\n                IActionPolicy.checkAction, (permissionId.toConfigId(actionId), msg.sender, target, value, callData)\n            ),\n            minPolicies: minPolicies\n        });\n        return vd;\n    }\n\n    /**\n     * Checks policies for a batch of ERC7579 executions within a user operation.\n     * This function iterates through each execution in the batch and validates them against relevant action policies.\n     *\n     * @dev This function decodes the batch of executions from the user operation's call data,\n     *      then applies policy checks to each execution individually.\n     *      The validation results are intersected to ensure all executions pass the policy checks.\n     *\n     * @param $policies The storage mapping of action policies.\n     * @param userOp The packed user operation being validated.\n     * @param permissionId The identifier for the permission being checked.\n     * @param minPolicies The minimum number of policies that must be checked for each execution.\n     *\n     * @return vd The final validation data resulting from intersecting all policy checks.\n     */\n    function checkBatch7579Exec(\n        mapping(ActionId => Policy) storage $policies,\n        PackedUserOperation calldata userOp,\n        PermissionId permissionId,\n        uint256 minPolicies\n    )\n        internal\n        returns (ValidationData vd)\n    {\n        // Decode the batch of 7579 executions from the user operation's call data\n        Execution[] calldata executions = userOp.callData.decodeUserOpCallData().decodeBatch();\n        uint256 length = executions.length;\n        // Revert if there are no executions in the batch\n        if (length == 0) revert ISmartSession.NoExecutionsInBatch();\n\n        // Iterate through each execution in the batch\n        for (uint256 i; i < length; i++) {\n            Execution calldata execution = executions[i];\n\n            // Check policies for the current execution and intersect the result with previous checks\n            ValidationData _vd = checkSingle7579Exec({\n                $policies: $policies,\n                permissionId: permissionId,\n                target: execution.target,\n                value: execution.value,\n                callData: execution.callData,\n                minPolicies: minPolicies\n            });\n\n            vd = vd.intersect(_vd);\n        }\n    }\n\n    /**\n     * Checks the validity of an ERC1271 signature against all relevant policies.\n     *\n     * @dev This function iterates through all policies for the given permission and checks\n     *      the signature validity using each policy's check1271SignedAction function.\n     *\n     * @param $self The storage reference to the Policy struct.\n     * @param account The address of the account associated with the signature.\n     * @param requestSender The address of the entity requesting the signature check.\n     * @param hash The hash of the signed data.\n     * @param signature The signature to be validated.\n     * @param permissionId The identifier of the permission being checked.\n     * @param configId The configuration identifier.\n     * @param minPoliciesToEnforce at least this number of policies should be enforced.\n     *\n     * @return valid Returns true if the signature is valid according to all policies, false otherwise.\n     */\n    function checkERC1271(\n        Policy storage $self,\n        address account,\n        address requestSender,\n        bytes32 hash,\n        bytes calldata signature,\n        PermissionId permissionId,\n        ConfigId configId,\n        uint256 minPoliciesToEnforce\n    )\n        internal\n        view\n        returns (bool valid)\n    {\n        address[] memory policies = $self.policyList[permissionId].values({ account: account });\n        uint256 length = policies.length;\n        if (minPoliciesToEnforce > length) revert ISmartSession.NoPoliciesSet(permissionId);\n\n        // iterate over all policies and intersect the validation data\n        for (uint256 i; i < length; i++) {\n            valid = I1271Policy(policies[i]).check1271SignedAction({\n                id: configId,\n                requestSender: requestSender,\n                account: account,\n                hash: hash,\n                signature: signature\n            });\n            // If any policy check fails, return false immediately\n            if (!valid) return valid;\n        }\n    }\n\n    /**\n     * Checks if the specified policies are enabled for a given permission and smart account.\n     *\n     * @dev This function verifies that all specified policies are both present in the policy list\n     *      and initialized for the given smart account and config.\n     *\n     * @param $policies The storage reference to the Policy struct.\n     * @param permissionId The identifier of the permission being checked.\n     * @param smartAccount The address of the smart account.\n     * @param policyDatas An array of PolicyData structs representing the policies to check.\n     *\n     * @return enabled Returns true if all policies are enabled, false if none are enabled.\n     *              Reverts if policies are partially enabled.\n     */\n    function areEnabled(\n        Policy storage $policies,\n        PermissionId permissionId,\n        address smartAccount,\n        PolicyData[] calldata policyDatas\n    )\n        internal\n        view\n        returns (bool enabled)\n    {\n        uint256 length = policyDatas.length;\n        enabled = true;\n        if (length == 0) return enabled; // 0 policies are always enabled lol\n        for (uint256 i; i < length; i++) {\n            PolicyData memory policyData = policyDatas[i];\n            IPolicy policy = IPolicy(policyData.policy);\n            // check if policy is enabled\n            if (!$policies.policyList[permissionId].contains(smartAccount, address(policy))) {\n                return false;\n            }\n        }\n    }\n\n    /**\n     * Checks if the specified action policies are enabled for a given permission and smart account.\n     *\n     * @dev This function verifies that all specified action policies are enabled.\n     *\n     * @param $self The storage reference to the EnumerableActionPolicy struct.\n     * @param permissionId The identifier of the permission being checked.\n     * @param smartAccount The address of the smart account.\n     * @param actionPolicyDatas An array of ActionData structs representing the action policies to check.\n     *\n     * @return enabled Returns true if all action policies are enabled, false if none are enabled.\n     *              Reverts if action policies are partially enabled.\n     */\n    function areEnabled(\n        EnumerableActionPolicy storage $self,\n        PermissionId permissionId,\n        address smartAccount,\n        ActionData[] calldata actionPolicyDatas\n    )\n        internal\n        view\n        returns (bool enabled)\n    {\n        uint256 length = actionPolicyDatas.length;\n        enabled = true;\n        if (length == 0) return enabled; // 0 actions are always enabled\n        for (uint256 i; i < length; i++) {\n            ActionData calldata actionPolicyData = actionPolicyDatas[i];\n            ActionId actionId = actionPolicyData.actionTarget.toActionId(actionPolicyData.actionTargetSelector);\n            // Check if the action policy is enabled\n            if (!$self.actionPolicies[actionId].areEnabled(permissionId, smartAccount, actionPolicyData.actionPolicies))\n            {\n                return false;\n            }\n        }\n    }\n}\n"},"contracts/lib/SignerLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.25;\n\nimport \"../DataTypes.sol\";\nimport { FlatBytesLib } from \"flatbytes/BytesLib.sol\";\nimport { ISessionValidator } from \"../interfaces/ISessionValidator.sol\";\n\nlibrary SignerLib {\n    using FlatBytesLib for *;\n\n    error SignerNotFound(PermissionId permissionId, address account);\n\n    function isValidISessionValidator(\n        mapping(PermissionId => mapping(address => SignerConf)) storage $sessionValidators,\n        bytes32 hash,\n        address account,\n        PermissionId permissionId,\n        bytes memory signature\n    )\n        internal\n        view\n        returns (bool)\n    {\n        ISessionValidator sessionValidator = $sessionValidators[permissionId][account].sessionValidator;\n        if (address(sessionValidator) == address(0)) revert SignerNotFound(permissionId, account);\n\n        // check signature of ISessionValidator first.\n        // policies only need to be processed if the signature is correct\n        return sessionValidator.validateSignatureWithData({\n            hash: hash,\n            sig: signature,\n            data: $sessionValidators[permissionId][account].config.load()\n        });\n    }\n}\n"},"contracts/lib/ConfigLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.25;\n\nimport \"../DataTypes.sol\";\nimport { IPolicy, IUserOpPolicy, IActionPolicy, I1271Policy } from \"../interfaces/IPolicy.sol\";\nimport { ISmartSession } from \"../ISmartSession.sol\";\nimport { ModuleType } from \"../interfaces/IRegistry.sol\";\nimport { EnumerableMap } from \"../utils/EnumerableMap4337.sol\";\nimport { IdLib } from \"./IdLib.sol\";\nimport { HashLib } from \"./HashLib.sol\";\nimport { EnumerableSet } from \"../utils/EnumerableSet4337.sol\";\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nlibrary ConfigLib {\n    using EnumerableMap for EnumerableMap.Bytes32ToBytes32Map;\n    using ERC165Checker for address;\n    using FlatBytesLib for FlatBytesLib.Bytes;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using HashLib for *;\n    using IdLib for *;\n    using ConfigLib for *;\n\n    function requirePolicyType(address policy, PolicyType policyType) internal view {\n        bool supportsInterface;\n        if (policyType == PolicyType.USER_OP) {\n            supportsInterface = policy.supportsInterface(type(IUserOpPolicy).interfaceId);\n        } else if (policyType == PolicyType.ACTION) {\n            supportsInterface = policy.supportsInterface(type(IActionPolicy).interfaceId);\n        } else if (policyType == PolicyType.ERC1271) {\n            supportsInterface = policy.supportsInterface(type(I1271Policy).interfaceId);\n        } else {\n            revert ISmartSession.UnsupportedPolicy(policy);\n        }\n\n        // Revert if the policy does not support the required interface\n        if (!supportsInterface) {\n            revert ISmartSession.UnsupportedPolicy(policy);\n        }\n    }\n\n    /**\n     * Helper function that ensures that the provided permission ID is enabled for the calling account.\n     */\n    function requirePermissionIdEnabled(\n        EnumerableSet.Bytes32Set storage set,\n        PermissionId permissionId\n    )\n        internal\n        view\n    {\n        if (!set.contains(msg.sender, PermissionId.unwrap(permissionId))) {\n            revert ISmartSession.InvalidPermissionId(permissionId);\n        }\n    }\n\n    /**\n     * Enables policies for a given permission ID.\n     *\n     * @dev This function iterates through the provided policy data and enables each policy.\n     *      It checks if the policy supports the IPolicy interface, verifies it with the registry if required,\n     *      adds it to the policy list, initializes it, and emits an event.\n     *\n     * @param $policy The storage reference to the Policy struct.\n     * @param policyType The type of policy being enabled defined as erc-7579 module type\n     * @param permissionId The identifier of the permission for which policies are being enabled.\n     * @param configId The configuration ID associated with the permission and policy type.\n     * @param policyDatas An array of PolicyData structs containing policy addresses and initialization data.\n     * @param useRegistry A boolean flag indicating whether to check policies against the registry.\n     */\n    function enable(\n        Policy storage $policy,\n        PolicyType policyType,\n        PermissionId permissionId,\n        ConfigId configId,\n        PolicyData[] memory policyDatas,\n        bool useRegistry\n    )\n        internal\n    {\n        // iterage over all policyData\n        uint256 lengthConfigs = policyDatas.length;\n        for (uint256 i; i < lengthConfigs; i++) {\n            address policy = policyDatas[i].policy;\n\n            policy.requirePolicyType(policyType);\n\n            // this will revert if the policy is not attested to\n            if (useRegistry) {\n                registry.checkForAccount({ smartAccount: msg.sender, module: policy });\n            }\n\n            // Add the policy to the list for the given permission and smart account\n            $policy.policyList[permissionId].add({ account: msg.sender, value: policy });\n\n            // Initialize the policy with the provided configuration\n            // overwrites the config\n            IPolicy(policy).initializeWithMultiplexer({\n                account: msg.sender,\n                configId: configId,\n                initData: policyDatas[i].initData\n            });\n\n            emit ISmartSession.PolicyEnabled(permissionId, policyType, policy, msg.sender);\n        }\n    }\n\n    /**\n     * Enables action policies for a given permission ID.\n     *\n     * @dev This function iterates through the provided action policy data and enables each action policy.\n     *      It records enabled action IDs and calls the enable function for each action policy.\n     *\n     * @param $self The storage reference to the EnumerableActionPolicy struct.\n     * @param permissionId The identifier of the permission for which action policies are being enabled.\n     * @param actionPolicyDatas An array of ActionData structs containing action policy information.\n     * @param useRegistry A boolean flag indicating whether to check policies against the registry.\n     */\n    function enable(\n        EnumerableActionPolicy storage $self,\n        PermissionId permissionId,\n        ActionData[] memory actionPolicyDatas,\n        bool useRegistry\n    )\n        internal\n    {\n        if (permissionId == EMPTY_PERMISSIONID) revert ISmartSession.InvalidPermissionId(permissionId);\n        uint256 length = actionPolicyDatas.length;\n        for (uint256 i; i < length; i++) {\n            // record every enabled actionId\n            ActionData memory actionPolicyData = actionPolicyDatas[i];\n\n            ActionId actionId = actionPolicyData.actionTarget.toActionId(actionPolicyData.actionTargetSelector);\n            {\n                address _cacheTarget = actionPolicyData.actionTarget;\n                // disallow actions to be set for address(0) or to the smartsession module itself\n                // sessionkeys that have access to smartsessions, may use this access to elevate their privileges\n                // forgefmt: disable-next-item\n                if (_cacheTarget == address(0) \n                 || _cacheTarget == address(this) \n                 || actionId == EMPTY_ACTIONID\n                ) revert ISmartSession.InvalidActionId();\n            }\n\n            // Record the enabled action ID\n            $self.actionPolicies[actionId].enable({\n                policyType: PolicyType.ACTION,\n                permissionId: permissionId,\n                configId: permissionId.toConfigId(actionId),\n                policyDatas: actionPolicyData.actionPolicies,\n                useRegistry: useRegistry\n            });\n\n            // Record the enabled action ID\n            $self.enabledActionIds[permissionId].add(msg.sender, ActionId.unwrap(actionId));\n        }\n    }\n\n    /**\n     * Enables ERC7739 content for a given configuration ID and smart account.\n     *\n     * @dev This function marks the provided content as enabled for the specified configuration and smart account.\n     *\n     * @param $enabledERC7739 The storage mapping for enabled ERC7739 content.\n     * @param contexts An array of ERC7739Contexts\n     * @param permissionId The configuration ID associated with the content.\n     */\n    function enable(\n        EnumerableERC7739Config storage $enabledERC7739,\n        ERC7739Context[] memory contexts,\n        PermissionId permissionId\n    )\n        internal\n    {\n        uint256 length = contexts.length;\n        for (uint256 i; i < length; i++) {\n            bytes32 appDomainSeparator = contexts[i].appDomainSeparator;\n\n            uint256 contentNamesLength = contexts[i].contentNames.length;\n            if (contentNamesLength != 0) {\n                $enabledERC7739.enabledDomainSeparators[permissionId].add(msg.sender, appDomainSeparator);\n            }\n            for (uint256 y; y < contentNamesLength; y++) {\n                bytes32 contentHash = contexts[i].contentNames[y].hashERC7739Content();\n                $enabledERC7739.enabledContentNames[permissionId][appDomainSeparator].add(msg.sender, contentHash);\n            }\n        }\n    }\n\n    /**\n     * @notice Enable and configure an ISessionValidator for a specific permission and account\n     * @dev This function sets up the session validator and stores its configuration\n     * @param permissionId The unique identifier for the permission\n     * @param sessionValidator The ISessionValidator contract to be enabled\n     * @param sessionValidatorConfig The configuration data for the session validator\n     */\n    function enable(\n        mapping(PermissionId permissionId => mapping(address smartAccount => SignerConf conf)) storage\n            $sessionValidators,\n        PermissionId permissionId,\n        ISessionValidator sessionValidator,\n        bytes memory sessionValidatorConfig,\n        bool useRegistry\n    )\n        internal\n    {\n        // Check if the sessionValidator is valid and supports the required interface\n        if (\n            address(sessionValidator) == address(0)\n                || !sessionValidator.isModuleType(ERC7579_MODULE_TYPE_STATELESS_VALIDATOR)\n        ) {\n            revert ISmartSession.InvalidISessionValidator(sessionValidator);\n        }\n\n        // this will revert if the policy is not attested to\n        if (useRegistry) {\n            registry.checkForAccount({\n                smartAccount: msg.sender,\n                module: address(sessionValidator),\n                moduleType: ModuleType.wrap(ERC7579_MODULE_TYPE_STATELESS_VALIDATOR)\n            });\n        }\n\n        // Get the storage reference for the signer configuration\n        SignerConf storage $conf = $sessionValidators[permissionId][msg.sender];\n        // Set the session validator\n        $conf.sessionValidator = sessionValidator;\n\n        // Store the signer configuration\n        $conf.config.store(sessionValidatorConfig);\n        emit ISmartSession.SessionValidatorEnabled(permissionId, address(sessionValidator), msg.sender);\n    }\n\n    /**\n     * Disables specified policies for a given permission ID and smart account.\n     *\n     * @dev This function removes the specified policies from the policy list and emits events for each disabled policy.\n     * @notice Cleaning state on policies is not required as on enable, initializeWithMultiplexer is called which MUST\n     *       overwrite the current state.\n     *\n     * @param $policy The storage reference to the Policy struct.\n     * @param policyType The type of policy being disabled defined as ERC-7579 module type\n     * @param smartAccount The address of the smart account for which policies are being disabled.\n     * @param permissionId The identifier of the permission for which policies are being disabled.\n     * @param policies An array of policy addresses to be disabled.\n     */\n    function disable(\n        Policy storage $policy,\n        PolicyType policyType,\n        address smartAccount,\n        PermissionId permissionId,\n        address[] calldata policies\n    )\n        internal\n    {\n        uint256 length = policies.length;\n        for (uint256 i; i < length; i++) {\n            address policy = policies[i];\n            if ($policy.policyList[permissionId].remove(smartAccount, policy)) {\n                emit ISmartSession.PolicyDisabled(permissionId, policyType, address(policy), smartAccount);\n            }\n        }\n    }\n\n    function disable(\n        mapping(PermissionId permissionId => mapping(address smartAccount => SignerConf conf)) storage\n            $sessionValidators,\n        PermissionId permissionId,\n        address smartAccount\n    )\n        internal\n    {\n        // Get the storage reference for the signer configuration\n        SignerConf storage $conf = $sessionValidators[permissionId][smartAccount];\n\n        //emit event\n        emit ISmartSession.SessionValidatorDisabled(permissionId, address($conf.sessionValidator), smartAccount);\n\n        // Clear the session validator\n        delete $conf.sessionValidator;\n\n        // clear the signer configuration\n        $conf.config.clear();\n    }\n\n    function disable(\n        EnumerableERC7739Config storage $enabledERC7739,\n        ERC7739Context[] memory contexts,\n        PermissionId permissionId,\n        address smartAccount\n    )\n        internal\n    {\n        uint256 length = contexts.length;\n        for (uint256 i; i < length; i++) {\n            bytes32 appDomainSeparator = contexts[i].appDomainSeparator;\n\n            uint256 contentNamesLength = contexts[i].contentNames.length;\n            for (uint256 y; y < contentNamesLength; y++) {\n                bytes32 contentHash = contexts[i].contentNames[y].hashERC7739Content();\n                $enabledERC7739.enabledContentNames[permissionId][appDomainSeparator].remove(smartAccount, contentHash);\n            }\n\n            if ($enabledERC7739.enabledContentNames[permissionId][appDomainSeparator].length(smartAccount) == 0) {\n                $enabledERC7739.enabledDomainSeparators[permissionId].remove(smartAccount, appDomainSeparator);\n            }\n        }\n    }\n\n    function removeAll(\n        EnumerableERC7739Config storage $enabledERC7739,\n        PermissionId permissionId,\n        address smartAccount\n    )\n        internal\n    {\n        bytes32[] memory domainSeparators = $enabledERC7739.enabledDomainSeparators[permissionId].values(smartAccount);\n        uint256 length = domainSeparators.length;\n        for (uint256 i; i < length; i++) {\n            bytes32 appDomainSeparator = domainSeparators[i];\n            $enabledERC7739.enabledContentNames[permissionId][appDomainSeparator].removeAll(smartAccount);\n        }\n\n        $enabledERC7739.enabledDomainSeparators[permissionId].removeAll(smartAccount);\n    }\n}\n"},"contracts/lib/EncodeLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.25;\n\nimport \"../DataTypes.sol\";\nimport { LibZip } from \"solady/utils/LibZip.sol\";\nimport { PackedUserOperation } from \"modulekit/external/ERC4337.sol\";\nimport { SmartSessionModeLib } from \"./SmartSessionModeLib.sol\";\n\nlibrary EncodeLib {\n    using LibZip for bytes;\n    using EncodeLib for *;\n    using SmartSessionModeLib for SmartSessionMode;\n\n    error ChainIdAndHashesLengthMismatch(uint256 chainIdsLength, uint256 hashesLength);\n\n    function getSender(PackedUserOperation calldata userOp) internal pure returns (address) {\n        address data;\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\n        assembly {\n            data := calldataload(userOp)\n        }\n        return address(uint160(data));\n    }\n\n    function unpackMode(bytes calldata packed)\n        internal\n        pure\n        returns (SmartSessionMode mode, PermissionId permissionId, bytes calldata data)\n    {\n        mode = SmartSessionMode(uint8(bytes1(packed[:1])));\n        if (mode.isEnableMode()) {\n            data = packed[1:];\n        } else {\n            permissionId = PermissionId.wrap(bytes32(packed[1:33]));\n            data = packed[33:];\n        }\n    }\n\n    function encodeUse(PermissionId permissionId, bytes memory sig) internal pure returns (bytes memory userOpSig) {\n        userOpSig = abi.encodePacked(SmartSessionMode.USE, permissionId, sig);\n    }\n\n    function encodeUnsafeEnable(\n        bytes memory sig,\n        EnableSession memory enableData\n    )\n        internal\n        pure\n        returns (bytes memory packedSig)\n    {\n        packedSig = abi.encodePacked(SmartSessionMode.UNSAFE_ENABLE, abi.encode(enableData, sig).flzCompress());\n    }\n\n    function decodeEnable(bytes calldata packedSig)\n        internal\n        pure\n        returns (EnableSession memory enableData, bytes memory signature)\n    {\n        (enableData, signature) = abi.decode(packedSig.flzDecompress(), (EnableSession, bytes));\n    }\n}\n"},"contracts/lib/HashLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.25;\n\nimport \"../DataTypes.sol\";\nimport { EfficientHashLib } from \"solady/utils/EfficientHashLib.sol\";\nimport { MessageHashUtils } from \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\n\n///////  Custom EIP712 types  ////\n//  to keep the documentation of nested EIP712 hashes readable, we trunkated the EIP712 definitions of nested structs.\n// If you want to reproduce the hashes, you can use the following alloy helper tool:\n// https://github.com/erc7579/smartsessions/blob/main/rust/main.rs\n// run cargo run to get the type hashes\n\n// PolicyData(address policy,bytes initData)\nbytes32 constant POLICY_DATA_TYPEHASH = 0xdddac12cd8b10a071bea04226e97ac9490698394e19224abc47a5cfeeeb6ee97;\n\n// ActionData(bytes4 actionTargetSelector,address actionTarget,PolicyData[] actionPolicies)\nbytes32 constant ACTION_DATA_TYPEHASH = 0x35809859dccf8877c407a59527c2f00fb81ca9c198ebcb0c832c3deaa38d3502;\n\n// ERC7739Context(bytes32 appDomainSeparator,string[] contentName)\nbytes32 constant ERC7739_CONTEXT_TYPEHASH = 0x006166b2b3a1edaf1da1ce02715d02d4979a4ab93755bff9ec054b0e6a96a1da;\n\n// ERC7739Data(ERC7739Context[] allowedERC7739Content,PolicyData[] erc1271Policies)\nbytes32 constant ERC7739_DATA_TYPEHASH = 0xdfd9b5718eebaa2484740b4ea6939e96189024c15848f16ccce901118114e152;\n\n/*\n * SignedSession(\n *     address account,                                  // User account address\n *     SignedPermissions permissions,                    // Signed permissions struct\n *     │   bool  permitGenericPolicy,                    // Allow policy fallback\n *     │   bool  permitAdminAccess,                      // Allow unsafe fallback (the action policy is permitted to\n *     │                                                 //   call administrative functions of smart session module). \n *     │                                                 //   @dev frontends must be handled with great care, as this\n *     │                                                 //   can be used for priviledge escalation\n *     │   bool ignoreSecurityAttestations               // Ignore Registry / Security Attestations\n *     │   bool permitERC4337Paymaster                   // Allow Session Key to use ERC4337 paymaster\n *     │   PolicyData[] userOpPolicies                   // UserOp policies array\n *     │   ├── address policy                            // Policy contract address\n *     │   └── bytes initData                            // Policy initialization data\n *     │   ERC7739Data erc7739Policies                   // ERC7739 policies struct\n *     │   ├── ERC7739Context[] allowedERC7739Content    // Allowed content array\n *     │   │   ├── bytes32 appDomainSeparator            // Domain separator\n *     │   │   └── string[] contentName                  // Content identifiers\n *     │   └── PolicyData[] erc1271Policies              // ERC1271 policies array\n *     │       ├── address policy                        // Policy address\n *     │       └── bytes initData                        // Init data\n *     │   ActionData[] actions                          // Actions array\n *     │   ├── bytes4 actionTargetSelector               // Function selector\n *     │   ├── address actionTarget                      // Target contract\n *     │   └── PolicyData[] actionPolicies               // Action policies array\n *     │       ├── address policy                        // Policy address\n *     │       └── bytes initData                        // Init data\n *     address sessionValidator,                         // Validator contract address\n *     bytes sessionValidatorInitData,                   // Validator initialization data\n *     bytes32 salt,                                     // Unique salt value\n *     address smartSession,                             // Smart session contract address\n *     uint256 nonce                                     // Nonce value\n * )\n */\nbytes32 constant SESSION_TYPEHASH = 0xd44896e3cb83d70abc949a38dd6f9f75e675dc329dfe958617f066f79ff88f05;\n\nbytes32 constant SIGNED_PERMISSIONS_TYPEHASH = 0x871289c05e426554eb0f843c9aa542f9c2bc4eba7742ada6a5c014d3568674d4;\n\n// ChainSession(uint64 chainId,SignedSession session)\nbytes32 constant CHAIN_SESSION_TYPEHASH = 0x1ea7e4bc398fa0ccd68d92b5d8931a3fd93eebe1cf0391b4ba28935801af7c80;\n\n// MultiChainSession(ChainSession[] sessionsAndChainIds)\nbytes32 constant MULTICHAIN_SESSION_TYPEHASH = 0x0c9d02fb89a1da34d66ea2088dc9ee6a58efee71cef6f1bb849ed74fc6003d98;\n\n// keccak256(\"EIP712Domain(string name,string version)\");\nbytes32 constant _MULTICHAIN_DOMAIN_TYPEHASH = 0xb03948446334eb9b2196d5eb166f69b9d49403eb4a12f36de8d3f9f3cb8e15c3;\n\n// One should use the domain separator below where possible\n// or provide the following EIP712Domain struct to the signTypedData() function\n// { Name: \"SmartSession\" (string),\n//   Version: \"1\" (string) }\n// Name and version are consistent with what is returned by _domainNameAndVersion()\n// Empty fields: version, chainId, verifyingContract are omitted as per EIP-712\n// it is introduced for compatibility with signTypedData()\n// all the critical data such as chainId and verifyingContract is included\n// in session hashes, so here the mock data compatible accross chains is used\n// see https://docs.metamask.io/wallet/reference/eth_signtypeddata_v4 for details\n\n// keccak256(abi.encode(_MULTICHAIN_DOMAIN_TYPEHASH, keccak256(\"SmartSession\"), keccak256(\"1\")));\nbytes32 constant _MULTICHAIN_DOMAIN_SEPARATOR = 0x057501e891776d1482927e5f094ae44049a4d893ba2d7b334dd7db8d38d3a0e1;\n\nlibrary HashLib {\n    error ChainIdMismatch(uint64 providedChainId);\n    error HashMismatch(bytes32 providedHash, bytes32 computedHash);\n\n    using EfficientHashLib for bytes32;\n    using HashLib for *;\n    using EfficientHashLib for *;\n\n    /**\n     * Mimics SignTypedData() behavior\n     * 1. hashStruct(Session)\n     * 2. hashStruct(ChainSession)\n     * 3. abi.encodePacked hashStruct's for 2) together\n     * 4. Hash it together with MULTI_CHAIN_SESSION_TYPEHASH\n     * as it was MultiChainSession struct\n     * 5. Add multichain domain separator\n     * This method doest same, just w/o 1. as it is already provided to us as a digest\n     */\n    function multichainDigest(ChainDigest[] memory hashesAndChainIds) internal pure returns (bytes32) {\n        bytes32 structHash =\n            keccak256(abi.encode(MULTICHAIN_SESSION_TYPEHASH, hashesAndChainIds.hashChainDigestArray()));\n\n        return MessageHashUtils.toTypedDataHash(_MULTICHAIN_DOMAIN_SEPARATOR, structHash);\n    }\n\n    /**\n     * Hash array of ChainDigest structs\n     */\n    function hashChainDigestArray(ChainDigest[] memory chainDigestArray) internal pure returns (bytes32) {\n        uint256 length = chainDigestArray.length;\n\n        bytes32[] memory a = EfficientHashLib.malloc(length);\n        for (uint256 i; i < length; i++) {\n            a.set(i, chainDigestArray[i].hashChainDigestMimicRPC());\n        }\n        return a.hash();\n    }\n\n    /**\n     * We have session digests, not full Session structs\n     * However to mimic signTypedData() behavior, we need to use CHAIN_SESSION_TYPEHASH\n     * not CHAIN_DIGEST_TYPEHASH. We just use the ready session digest instead of rebuilding it\n     */\n    function hashChainDigestMimicRPC(ChainDigest memory chainDigest) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                CHAIN_SESSION_TYPEHASH,\n                chainDigest.chainId,\n                chainDigest.sessionDigest // this is the digest obtained using sessionDigest()\n                    // we just do not rebuild it here for all sessions, but receive it from off-chain\n            )\n        );\n    }\n\n    /**\n     * Hashes the data from the Session struct with some security critical data\n     * such as nonce, account address, smart session address, and mode\n     */\n    function sessionDigest(\n        Session memory session,\n        address account,\n        SmartSessionMode mode,\n        uint256 nonce\n    )\n        internal\n        view\n        returns (bytes32)\n    {\n        return _sessionDigest(session, account, address(this), mode, nonce);\n    }\n\n    /**\n     * Should never be used directly on-chain, only via sessionDigest()\n     * Only for external use - to be able to pass smartSession when\n     * testing for different chains which may have different addresses for\n     * the Smart Session contract\n     * It is exactly how signTypedData will hash such an object\n     * when this object is an inner struct\n     * It won't use eip712 domain for it as it is inner struct\n     */\n    function _sessionDigest(\n        Session memory session,\n        address account,\n        address smartSession, // for testing purposes\n        SmartSessionMode mode,\n        uint256 nonce\n    )\n        internal\n        pure\n        returns (bytes32 _hash)\n    {\n        {\n            // chainId is not needed as it is in the ChainSession\n            _hash = keccak256(\n                abi.encode(\n                    SESSION_TYPEHASH,\n                    account,\n                    hashPermissions({\n                        session: session,\n                        ignoreSecurityAttestations: mode == SmartSessionMode.UNSAFE_ENABLE\n                    }),\n                    address(session.sessionValidator),\n                    keccak256(session.sessionValidatorInitData),\n                    session.salt,\n                    smartSession,\n                    nonce\n                )\n            );\n        }\n    }\n\n    function hashPermissions(Session memory session, bool ignoreSecurityAttestations) internal pure returns (bytes32) {\n        (bool permitFallback, bool permitUnsafeFallback, bytes32 actionDataArrayHash) =\n            session.actions.hashActionDataArray();\n        return keccak256(\n            abi.encode(\n                SIGNED_PERMISSIONS_TYPEHASH,\n                permitFallback, // permitGenericPolicy\n                permitUnsafeFallback, // permitAdminAccess\n                ignoreSecurityAttestations, // ignoreSecurityAttestations\n                session.permitERC4337Paymaster, // permitERC4337Paymaster\n                session.userOpPolicies.hashPolicyDataArray(), // userOpPolicies\n                session.erc7739Policies.hashERC7739Data(), // erc7739Policies\n                actionDataArrayHash // actions\n            )\n        );\n    }\n\n    function hashPolicyData(PolicyData memory policyData) internal pure returns (bytes32) {\n        return keccak256(abi.encode(POLICY_DATA_TYPEHASH, policyData.policy, keccak256(policyData.initData)));\n    }\n\n    function hashPolicyDataArray(PolicyData[] memory policyDataArray) internal pure returns (bytes32) {\n        uint256 length = policyDataArray.length;\n\n        bytes32[] memory a = EfficientHashLib.malloc(length);\n        for (uint256 i; i < length; i++) {\n            a.set(i, policyDataArray[i].hashPolicyData());\n        }\n        return a.hash();\n    }\n\n    function hashActionData(ActionData memory actionData) internal pure returns (bytes32 digest) {\n        digest = keccak256(\n            abi.encode(\n                ACTION_DATA_TYPEHASH,\n                actionData.actionTargetSelector,\n                actionData.actionTarget,\n                hashPolicyDataArray(actionData.actionPolicies)\n            )\n        );\n    }\n\n    function hashActionDataArray(ActionData[] memory actionDataArray)\n        internal\n        pure\n        returns (bool permitFallback, bool permitUnsafeFallback, bytes32 _hash)\n    {\n        uint256 length = actionDataArray.length;\n        bytes32[] memory a = EfficientHashLib.malloc(length);\n\n        for (uint256 i; i < length; i++) {\n            ActionData memory actionData = actionDataArray[i];\n            // if this action policy is a fallback action policy\n            if (actionData.actionTarget == FALLBACK_TARGET_FLAG) {\n                // only set the permitFallbackFlag if not previously set to true\n                permitFallback = permitFallback || (actionData.actionTargetSelector == FALLBACK_TARGET_SELECTOR_FLAG);\n\n                // only set the permitUnsafeFallbackFlag if not previously set to true\n                permitUnsafeFallback = permitUnsafeFallback\n                    || actionData.actionTargetSelector == FALLBACK_TARGET_SELECTOR_FLAG_PERMITTED_TO_CALL_SMARTSESSION;\n            }\n\n            a.set(i, actionData.hashActionData());\n        }\n        _hash = a.hash();\n    }\n\n    function hashERC7739Context(ERC7739Context memory erc7739Context) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                ERC7739_CONTEXT_TYPEHASH,\n                erc7739Context.appDomainSeparator,\n                hashStringArray(erc7739Context.contentNames)\n            )\n        );\n    }\n\n    function hashERC7739ContextArray(ERC7739Context[] memory erc7739Context) internal pure returns (bytes32) {\n        uint256 length = erc7739Context.length;\n        bytes32[] memory a = EfficientHashLib.malloc(length);\n\n        for (uint256 i; i < length; i++) {\n            a.set(i, erc7739Context[i].hashERC7739Context());\n        }\n        return a.hash();\n    }\n\n    function hashERC7739Data(ERC7739Data memory erc7739Data) internal pure returns (bytes32) {\n        bytes32[] memory a = EfficientHashLib.malloc(3);\n        a.set(0, ERC7739_DATA_TYPEHASH);\n        a.set(1, erc7739Data.allowedERC7739Content.hashERC7739ContextArray());\n        a.set(2, erc7739Data.erc1271Policies.hashPolicyDataArray());\n        return a.hash();\n    }\n\n    function hashStringArray(string[] memory stringArray) internal pure returns (bytes32) {\n        uint256 length = stringArray.length;\n        bytes32[] memory a = EfficientHashLib.malloc(length);\n        for (uint256 i; i < length; i++) {\n            a.set(i, keccak256(abi.encodePacked(stringArray[i])));\n        }\n        return a.hash();\n    }\n\n    function hashERC7739Content(string memory content) internal pure returns (bytes32) {\n        return keccak256(bytes(content));\n    }\n\n    function getAndVerifyDigest(\n        EnableSession memory enableData,\n        address account,\n        uint256 nonce,\n        SmartSessionMode mode\n    )\n        internal\n        view\n        returns (bytes32 digest)\n    {\n        bytes32 computedHash = enableData.sessionToEnable.sessionDigest(account, mode, nonce);\n\n        uint64 providedChainId = enableData.hashesAndChainIds[enableData.chainDigestIndex].chainId;\n        bytes32 providedHash = enableData.hashesAndChainIds[enableData.chainDigestIndex].sessionDigest;\n\n        if (providedChainId != block.chainid) {\n            revert ChainIdMismatch(providedChainId);\n        }\n\n        // ensure digest we've built from the sessionToEnable is included into\n        // the list of digests that were signed\n        if (providedHash != computedHash) {\n            revert HashMismatch(providedHash, computedHash);\n        }\n\n        digest = enableData.hashesAndChainIds.multichainDigest();\n    }\n}\n"},"contracts/lib/ValidationDataLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ValidationData } from \"../DataTypes.sol\";\n// @author zeroknots rhinestone\n\nlibrary ValidationDataLib {\n    function intersect(ValidationData a, ValidationData b) internal pure returns (ValidationData validationData) {\n        assembly {\n            // xor(a,b) == shows only matching bits\n            // and(xor(a,b), 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff) ==\n            // filters out the validAfter and validUntil bits\n            // if the result is not zero, then aggregator part is not matching\n            // validCase :\n            // a == 0 || b == 0 || xor(a,b) == 0\n            // invalidCase :\n            // a mul b != 0 && xor(a,b) != 0\n            let sum := shl(96, add(a, b))\n            switch or(\n                iszero(and(xor(a, b), 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff)),\n                or(eq(sum, shl(96, a)), eq(sum, shl(96, b)))\n            )\n            case 1 {\n                validationData := and(or(a, b), 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff)\n                // validAfter\n                let a_vd := and(0xffffffffffff0000000000000000000000000000000000000000000000000000, a)\n                let b_vd := and(0xffffffffffff0000000000000000000000000000000000000000000000000000, b)\n                validationData := or(validationData, xor(a_vd, mul(xor(a_vd, b_vd), gt(b_vd, a_vd))))\n                // validUntil\n                a_vd := and(0x000000000000ffffffffffff0000000000000000000000000000000000000000, a)\n                if iszero(a_vd) { a_vd := 0x000000000000ffffffffffff0000000000000000000000000000000000000000 }\n                b_vd := and(0x000000000000ffffffffffff0000000000000000000000000000000000000000, b)\n                if iszero(b_vd) { b_vd := 0x000000000000ffffffffffff0000000000000000000000000000000000000000 }\n                let until := xor(a_vd, mul(xor(a_vd, b_vd), lt(b_vd, a_vd)))\n                if iszero(until) { until := 0x000000000000ffffffffffff0000000000000000000000000000000000000000 }\n                validationData := or(validationData, until)\n            }\n            default { validationData := 1 }\n        }\n    }\n}\n"},"contracts/lib/IdLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.25;\n\nimport \"../DataTypes.sol\";\n\nlibrary IdLib {\n    bytes4 internal constant VALUE_SELECTOR = 0xFFFFFFFF;\n\n    function toUserOpPolicyId(PermissionId permissionId) internal pure returns (UserOpPolicyId userOpPolicyId) {\n        userOpPolicyId = UserOpPolicyId.wrap(PermissionId.unwrap(permissionId));\n    }\n\n    function toActionId(address target, bytes calldata callData) internal pure returns (ActionId actionId) {\n        if (callData.length < 4) return toActionId(target, VALUE_SELECTOR);\n        else return toActionId(target, callData[:4]);\n    }\n\n    function toActionId(address target, bytes4 functionSelector) internal pure returns (ActionId actionId) {\n        actionId = ActionId.wrap(keccak256(abi.encodePacked(target, functionSelector)));\n    }\n\n    function toActionPolicyId(\n        PermissionId permissionId,\n        ActionId actionId\n    )\n        internal\n        pure\n        returns (ActionPolicyId policyId)\n    {\n        policyId = ActionPolicyId.wrap(keccak256(abi.encodePacked(permissionId, actionId)));\n    }\n\n    function toErc1271PolicyId(PermissionId permissionId) internal pure returns (Erc1271PolicyId erc1271PolicyId) {\n        erc1271PolicyId = Erc1271PolicyId.wrap(keccak256(abi.encodePacked(\"ERC1271: \", permissionId)));\n    }\n\n    function toConfigId(UserOpPolicyId userOpPolicyId, address account) internal pure returns (ConfigId _id) {\n        _id = ConfigId.wrap(keccak256(abi.encodePacked(account, userOpPolicyId)));\n    }\n\n    function toConfigId(ActionPolicyId actionPolicyId, address account) internal pure returns (ConfigId _id) {\n        _id = ConfigId.wrap(keccak256(abi.encodePacked(account, actionPolicyId)));\n    }\n\n    function toConfigId(\n        PermissionId permissionId,\n        ActionId actionId,\n        address account\n    )\n        internal\n        pure\n        returns (ConfigId _id)\n    {\n        _id = toConfigId(toActionPolicyId(permissionId, actionId), account);\n    }\n\n    function toConfigId(Erc1271PolicyId erc1271PolicyId, address account) internal pure returns (ConfigId _id) {\n        _id = ConfigId.wrap(keccak256(abi.encodePacked(account, erc1271PolicyId)));\n    }\n\n    function toConfigId(UserOpPolicyId userOpPolicyId) internal view returns (ConfigId _id) {\n        _id = toConfigId(userOpPolicyId, msg.sender);\n    }\n\n    function toConfigId(PermissionId permissionId, ActionId actionId) internal view returns (ConfigId _id) {\n        _id = toConfigId(toActionPolicyId(permissionId, actionId), msg.sender);\n    }\n\n    function toConfigId(Erc1271PolicyId erc1271PolicyId) internal view returns (ConfigId _id) {\n        _id = toConfigId(erc1271PolicyId, msg.sender);\n    }\n\n    function toPermissionIdMemory(Session memory session) internal pure returns (PermissionId permissionId) {\n        permissionId = PermissionId.wrap(\n            keccak256(abi.encode(session.sessionValidator, session.sessionValidatorInitData, session.salt))\n        );\n    }\n\n    function toPermissionId(Session calldata session) internal pure returns (PermissionId permissionId) {\n        permissionId = PermissionId.wrap(\n            keccak256(abi.encode(session.sessionValidator, session.sessionValidatorInitData, session.salt))\n        );\n    }\n}\n"},"contracts/lib/SmartSessionModeLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.25;\n\nimport \"../DataTypes.sol\";\n\nlibrary SmartSessionModeLib {\n    function isUseMode(SmartSessionMode mode) internal pure returns (bool) {\n        return mode == SmartSessionMode.USE;\n    }\n\n    function isEnableMode(SmartSessionMode mode) internal pure returns (bool) {\n        return (mode == SmartSessionMode.ENABLE || mode == SmartSessionMode.UNSAFE_ENABLE);\n    }\n\n    function useRegistry(SmartSessionMode) internal pure returns (bool) {\n        return false;\n    }\n}\n"},"contracts/utils/AssociatedArrayLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * ERC-4337 / ERC-7562 Compatible array lib.\n *   This array can be used as mapping value in mappings such as (address account => Bytes32Array array)\n *   Array size should not exceed 128.\n */\nlibrary AssociatedArrayLib {\n    using AssociatedArrayLib for *;\n\n    error AssociatedArray_OutOfBounds(uint256 index);\n\n    struct Array {\n        uint256 _spacer;\n    }\n\n    function _slot(Array storage s, address account) private pure returns (bytes32 __slot) {\n        assembly {\n            mstore(0x00, account)\n            mstore(0x20, s.slot)\n            __slot := keccak256(0x00, 0x40)\n        }\n    }\n\n    function _length(Array storage s, address account) private view returns (uint256 __length) {\n        bytes32 slot = _slot(s, account);\n        assembly {\n            __length := sload(slot)\n        }\n    }\n\n    function _get(Array storage s, address account, uint256 index) private view returns (bytes32 value) {\n        return _get(_slot(s, account), index);\n    }\n\n    function _get(bytes32 slot, uint256 index) private view returns (bytes32 value) {\n        assembly {\n            //if (index >= _length(s, account)) revert AssociatedArray_OutOfBounds(index);\n            if iszero(lt(index, sload(slot))) {\n                mstore(0, 0x8277484f) // `AssociatedArray_OutOfBounds(uint256)`\n                mstore(0x20, index)\n                revert(0x1c, 0x24)\n            }\n            value := sload(add(slot, add(index, 1)))\n        }\n    }\n\n    function _getAll(Array storage s, address account) private view returns (bytes32[] memory values) {\n        bytes32 slot = _slot(s, account);\n        uint256 __length;\n        assembly {\n            __length := sload(slot)\n        }\n        values = new bytes32[](__length);\n        for (uint256 i; i < __length; i++) {\n            values[i] = _get(slot, i);\n        }\n    }\n\n    // inefficient. complexity = O(n)\n    // use with caution\n    // in case of large arrays, consider using EnumerableSet4337 instead\n    function _contains(Array storage s, address account, bytes32 value) private view returns (bool) {\n        bytes32 slot = _slot(s, account);\n        uint256 __length;\n        assembly {\n            __length := sload(slot)\n        }\n        for (uint256 i; i < __length; i++) {\n            if (_get(slot, i) == value) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _set(Array storage s, address account, uint256 index, bytes32 value) private {\n        _set(_slot(s, account), index, value);\n    }\n\n    function _set(bytes32 slot, uint256 index, bytes32 value) private {\n        assembly {\n            //if (index >= _length(s, account)) revert AssociatedArray_OutOfBounds(index);\n            if iszero(lt(index, sload(slot))) {\n                mstore(0, 0x8277484f) // `AssociatedArray_OutOfBounds(uint256)`\n                mstore(0x20, index)\n                revert(0x1c, 0x24)\n            }\n            sstore(add(slot, add(index, 1)), value)\n        }\n    }\n\n    function _push(Array storage s, address account, bytes32 value) private {\n        bytes32 slot = _slot(s, account);\n        assembly {\n            // load length (stored @ slot) => this would be the index of a new element\n            let index := sload(slot)\n            sstore(add(slot, add(index, 1)), value) // store at (slot+index+1) => 0th element is stored at slot+1\n            sstore(slot, add(index, 1)) // increment length by 1\n        }\n    }\n\n    function _pop(Array storage s, address account) private {\n        bytes32 slot = _slot(s, account);\n        uint256 __length;\n        assembly {\n            __length := sload(slot)\n        }\n        if (__length == 0) return;\n        _set(slot, __length - 1, 0);\n        assembly {\n            sstore(slot, sub(__length, 1))\n        }\n    }\n\n    function _remove(Array storage s, address account, uint256 index) private {\n        bytes32 slot = _slot(s, account);\n        uint256 __length;\n        assembly {\n            __length := sload(slot)\n            if iszero(lt(index, __length)) {\n                mstore(0, 0x8277484f) // `AssociatedArray_OutOfBounds(uint256)`\n                mstore(0x20, index)\n                revert(0x1c, 0x24)\n            }\n        }\n        _set(slot, index, _get(s, account, __length - 1));\n\n        assembly {\n            // clear the last slot\n            // this is the 'unchecked' version of _set(slot, __length - 1, 0)\n            // as we use length-1 as index, so the check is excessive.\n            // also removes extra -1 and +1 operations\n            sstore(add(slot, __length), 0)\n            // store new length\n            sstore(slot, sub(__length, 1))\n        }\n    }\n\n    struct Bytes32Array {\n        Array _inner;\n    }\n\n    function length(Bytes32Array storage s, address account) internal view returns (uint256) {\n        return _length(s._inner, account);\n    }\n\n    function get(Bytes32Array storage s, address account, uint256 index) internal view returns (bytes32) {\n        return _get(s._inner, account, index);\n    }\n\n    function getAll(Bytes32Array storage s, address account) internal view returns (bytes32[] memory) {\n        return _getAll(s._inner, account);\n    }\n\n    function contains(Bytes32Array storage s, address account, bytes32 value) internal view returns (bool) {\n        return _contains(s._inner, account, value);\n    }\n\n    function add(Bytes32Array storage s, address account, bytes32 value) internal {\n        if (!_contains(s._inner, account, value)) {\n            _push(s._inner, account, value);\n        }\n    }\n\n    function set(Bytes32Array storage s, address account, uint256 index, bytes32 value) internal {\n        _set(s._inner, account, index, value);\n    }\n\n    function push(Bytes32Array storage s, address account, bytes32 value) internal {\n        _push(s._inner, account, value);\n    }\n\n    function pop(Bytes32Array storage s, address account) internal {\n        _pop(s._inner, account);\n    }\n\n    function remove(Bytes32Array storage s, address account, uint256 index) internal {\n        _remove(s._inner, account, index);\n    }\n\n    struct AddressArray {\n        Array _inner;\n    }\n\n    function length(AddressArray storage s, address account) internal view returns (uint256) {\n        return _length(s._inner, account);\n    }\n\n    function get(AddressArray storage s, address account, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_get(s._inner, account, index))));\n    }\n\n    function getAll(AddressArray storage s, address account) internal view returns (address[] memory) {\n        bytes32[] memory bytes32Array = _getAll(s._inner, account);\n        address[] memory addressArray;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            addressArray := bytes32Array\n        }\n        return addressArray;\n    }\n\n    function contains(AddressArray storage s, address account, address value) internal view returns (bool) {\n        return _contains(s._inner, account, bytes32(uint256(uint160(value))));\n    }\n\n    function add(AddressArray storage s, address account, address value) internal {\n        if (!_contains(s._inner, account, bytes32(uint256(uint160(value))))) {\n            _push(s._inner, account, bytes32(uint256(uint160(value))));\n        }\n    }\n\n    function set(AddressArray storage s, address account, uint256 index, address value) internal {\n        _set(s._inner, account, index, bytes32(uint256(uint160(value))));\n    }\n\n    function push(AddressArray storage s, address account, address value) internal {\n        _push(s._inner, account, bytes32(uint256(uint160(value))));\n    }\n\n    function pop(AddressArray storage s, address account) internal {\n        _pop(s._inner, account);\n    }\n\n    function remove(AddressArray storage s, address account, uint256 index) internal {\n        _remove(s._inner, account, index);\n    }\n\n    struct UintArray {\n        Array _inner;\n    }\n\n    function length(UintArray storage s, address account) internal view returns (uint256) {\n        return _length(s._inner, account);\n    }\n\n    function get(UintArray storage s, address account, uint256 index) internal view returns (uint256) {\n        return uint256(_get(s._inner, account, index));\n    }\n\n    function getAll(UintArray storage s, address account) internal view returns (uint256[] memory) {\n        bytes32[] memory bytes32Array = _getAll(s._inner, account);\n        uint256[] memory uintArray;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            uintArray := bytes32Array\n        }\n        return uintArray;\n    }\n\n    function contains(UintArray storage s, address account, uint256 value) internal view returns (bool) {\n        return _contains(s._inner, account, bytes32(value));\n    }\n\n    function add(UintArray storage s, address account, uint256 value) internal {\n        if (!_contains(s._inner, account, bytes32(value))) {\n            _push(s._inner, account, bytes32(value));\n        }\n    }\n\n    function set(UintArray storage s, address account, uint256 index, uint256 value) internal {\n        _set(s._inner, account, index, bytes32(value));\n    }\n\n    function push(UintArray storage s, address account, uint256 value) internal {\n        _push(s._inner, account, bytes32(value));\n    }\n\n    function pop(UintArray storage s, address account) internal {\n        _pop(s._inner, account);\n    }\n\n    function remove(UintArray storage s, address account, uint256 index) internal {\n        _remove(s._inner, account, index);\n    }\n}\n"},"contracts/interfaces/IRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ntype ModuleType is uint256;\n\ninterface IRegistry {\n    event NewTrustedAttesters(address indexed smartAccount);\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          Check with Registry internal attesters            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module) external view;\n\n    function checkForAccount(address smartAccount, address module) external view;\n\n    function check(address module, ModuleType moduleType) external view;\n\n    function checkForAccount(address smartAccount, address module, ModuleType moduleType) external view;\n\n    /**\n     * Allows Smart Accounts - the end users of the registry - to appoint\n     * one or many attesters as trusted.\n     * @dev this function reverts, if address(0), or duplicates are provided in attesters[]\n     *\n     * @param threshold The minimum number of attestations required for a module\n     *                  to be considered secure.\n     * @param attesters The addresses of the attesters to be trusted.\n     */\n    function trustAttesters(uint8 threshold, address[] calldata attesters) external;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              Check with external attester(s)               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module, address[] calldata attesters, uint256 threshold) external view;\n\n    function check(\n        address module,\n        ModuleType moduleType,\n        address[] calldata attesters,\n        uint256 threshold\n    )\n        external\n        view;\n}\n"},"contracts/interfaces/ISessionValidator.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.23;\n\nimport { IModule } from \"erc7579/interfaces/IERC7579Module.sol\";\n\n/**\n * ISessionValidator is a contract that validates signatures for a given session.\n * this interface expects to validate the signature in a stateless way.\n * all parameters required to validate the signature are passed in the function call.\n * Only one ISessionValidator is responsible to validate a userOp.\n * if you want to use multiple validators, you can create a ISessionValidator that aggregates multiple signatures that\n * are packed into userOp.signature\n * It is used to validate the signature of a session.\n *  hash The userOp hash\n *  sig The signature of userOp\n *  data the config data that is used to validate the signature\n */\ninterface ISessionValidator is IModule {\n    function validateSignatureWithData(\n        bytes32 hash,\n        bytes calldata sig,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bool validSig);\n}\n"},"contracts/utils/EnumerableMap4337.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity ^0.8.20;\n\nimport { EnumerableSet } from \"./EnumerableSet4337.sol\";\n\n/**\n * Fork of OZ's EnumerableSet that makes all storage access ERC-4337 compliant via associated storage\n * @author zeroknots.eth (rhinestone)\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code repetition as possible, we write it in\n    // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\n    // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit in bytes32.\n\n    /**\n     * @dev Query for a nonexistent map key.\n     */\n    error EnumerableMapNonexistentKey(bytes32 key);\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 key => mapping(address account => bytes32)) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToBytes32Map storage map,\n        address account,\n        bytes32 key,\n        bytes32 value\n    )\n        internal\n        returns (bool)\n    {\n        map._values[key][account] = value;\n        return map._keys.add(account, key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, address account, bytes32 key) internal returns (bool) {\n        delete map._values[key][account];\n        return map._keys.remove(account, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, address account, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(account, key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map, address account) internal view returns (uint256) {\n        return map._keys.length(account);\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(\n        Bytes32ToBytes32Map storage map,\n        address account,\n        uint256 index\n    )\n        internal\n        view\n        returns (bytes32, bytes32)\n    {\n        bytes32 key = map._keys.at(account, index);\n        return (key, map._values[key][account]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(\n        Bytes32ToBytes32Map storage map,\n        address account,\n        bytes32 key\n    )\n        internal\n        view\n        returns (bool, bytes32)\n    {\n        bytes32 value = map._values[key][account];\n        if (value == bytes32(0)) {\n            return (contains(map, account, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, address account, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key][account];\n        if (value == 0 && !contains(map, account, key)) {\n            revert EnumerableMapNonexistentKey(key);\n        }\n        return value;\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToBytes32Map storage map, address account) internal view returns (bytes32[] memory) {\n        return map._keys.values(account);\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToUintMap storage map, address account, uint256 key, uint256 value) internal returns (bool) {\n        return set(map._inner, account, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, address account, uint256 key) internal returns (bool) {\n        return remove(map._inner, account, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, address account, uint256 key) internal view returns (bool) {\n        return contains(map._inner, account, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map, address account) internal view returns (uint256) {\n        return length(map._inner, account);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, address account, uint256 index) internal view returns (uint256, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, account, index);\n        return (uint256(key), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, address account, uint256 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, account, bytes32(key));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, address account, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, account, bytes32(key)));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToUintMap storage map, address account) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner, account);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, address account, uint256 key, address value) internal returns (bool) {\n        return set(map._inner, account, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, address account, uint256 key) internal returns (bool) {\n        return remove(map._inner, account, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, address account, uint256 key) internal view returns (bool) {\n        return contains(map._inner, account, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map, address account) internal view returns (uint256) {\n        return length(map._inner, account);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(\n        UintToAddressMap storage map,\n        address account,\n        uint256 index\n    )\n        internal\n        view\n        returns (uint256, address)\n    {\n        (bytes32 key, bytes32 value) = at(map._inner, account, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToAddressMap storage map, address account, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, account, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, address account, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, account, bytes32(key)))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToAddressMap storage map, address account) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner, account);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToUintMap storage map, address account, address key, uint256 value) internal returns (bool) {\n        return set(map._inner, account, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address account, address key) internal returns (bool) {\n        return remove(map._inner, account, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address account, address key) internal view returns (bool) {\n        return contains(map._inner, account, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map, address account) internal view returns (uint256) {\n        return length(map._inner, account);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(\n        AddressToUintMap storage map,\n        address account,\n        uint256 index\n    )\n        internal\n        view\n        returns (address, uint256)\n    {\n        (bytes32 key, bytes32 value) = at(map._inner, account, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address account, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, account, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address account, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, account, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToUintMap storage map, address account) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner, account);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToUintMap storage map, address account, bytes32 key, uint256 value) internal returns (bool) {\n        return set(map._inner, account, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, address account, bytes32 key) internal returns (bool) {\n        return remove(map._inner, account, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, address account, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, account, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map, address account) internal view returns (uint256) {\n        return length(map._inner, account);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(\n        Bytes32ToUintMap storage map,\n        address account,\n        uint256 index\n    )\n        internal\n        view\n        returns (bytes32, uint256)\n    {\n        (bytes32 key, bytes32 value) = at(map._inner, account, index);\n        return (key, uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, address account, bytes32 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, account, key);\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, address account, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, account, key));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToUintMap storage map, address account) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner, account);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"},"node_modules/@rhinestone/flatbytes/src/BytesLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\n/**\n * @title FlatBytesLib\n * @dev Library for storing bytes data in consecutive storage slots\n * @dev This is useful in the context of the ERC-4337 validation rules\n * @dev Be careful that this does not override existing data in the next slots and ideally use this\n * data as the value of a struct\n * @author Rhinestone\n */\nlibrary FlatBytesLib {\n    using FlatBytesLib for *;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    DATA STRUCTURES\n    //////////////////////////////////////////////////////////////////////////*/\n\n    // Data structure to store bytes in consecutive slots using an array\n    struct Data {\n        bytes32[10] slot1;\n    }\n\n    // Store the length of the data and the data itself in consecutive slots\n    struct Bytes {\n        uint256 totalLength;\n        Data data;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /**\n     * Store the data in storage\n     *\n     * @param self The storage to store the data in\n     * @param data The data to store\n     */\n    function store(Bytes storage self, bytes memory data) internal {\n        if (data.length > 32 * 10) revert();\n        bytes32[] memory entries;\n        (self.totalLength, entries) = data.toArray();\n\n        uint256 length = entries.length;\n\n        Data storage _data = self.data;\n\n        for (uint256 i; i < length; i++) {\n            bytes32 value = entries[i];\n            assembly {\n                sstore(add(_data.slot, i), value)\n            }\n        }\n    }\n\n    /**\n     * Clear the data in storage\n     *\n     * @param self The storage to clear the data in\n     */\n    function clear(Bytes storage self) internal {\n        self.totalLength = 0;\n        Data storage _data = self.data;\n        for (uint256 i; i < 10; i++) {\n            assembly {\n                sstore(add(_data.slot, i), 0)\n            }\n        }\n    }\n\n    /**\n     * Load the data from storage\n     *\n     * @param self The storage to load the data from\n     *\n     * @return data The data loaded from storage\n     */\n    function load(Bytes storage self) internal view returns (bytes memory data) {\n        return self.toBytes();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    INTERNAL\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /**\n     * Convert bytes to an array of bytes32\n     *\n     * @param data The data to convert\n     * @return totalLength The total length of the data\n     *\n     * @return dataList The data as an array of bytes32\n     */\n    function toArray(bytes memory data)\n        internal\n        pure\n        returns (uint256 totalLength, bytes32[] memory dataList)\n    {\n        // Find 32 bytes segments nb\n        totalLength = data.length;\n        if (totalLength > 32 * 10) revert();\n        uint256 dataNb = totalLength / 32 + 1;\n\n        // Create an array of dataNb elements\n        dataList = new bytes32[](dataNb);\n\n        // Loop all 32 bytes segments\n        for (uint256 i = 0; i < dataNb; i++) {\n            bytes32 temp;\n            // Get 32 bytes from data\n            assembly {\n                temp := mload(add(data, mul(add(i, 1), 32)))\n            }\n            // Add extracted 32 bytes to list\n            dataList[i] = temp;\n        }\n    }\n\n    /**\n     * Convert an array of bytes32 to bytes\n     *\n     * @param self The array of bytes32 to convert\n     *\n     * @return data The data as bytes\n     */\n    function toBytes(Bytes storage self) internal view returns (bytes memory data) {\n        uint256 totalLength = self.totalLength;\n        uint256 slotsCnt = totalLength / 32 + 1;\n\n        Data storage _data = self.data;\n\n        bytes32[] memory entries = new bytes32[](slotsCnt);\n        for (uint256 i; i < slotsCnt; i++) {\n            bytes32 tmp;\n            assembly {\n                tmp := sload(add(_data.slot, i))\n            }\n            entries[i] = tmp;\n        }\n\n        data = abi.encodePacked(entries);\n        assembly {\n            mstore(data, totalLength)\n        }\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/PackedUserOperation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor/\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    bytes32 accountGasLimits;\n    uint256 preVerificationGas;\n    bytes32 gasFees;\n    bytes paymasterAndData;\n    bytes signature;\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/UserOperationLib.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/* solhint-disable no-inline-assembly */\n\nimport \"../interfaces/PackedUserOperation.sol\";\nimport {calldataKeccak, min} from \"./Helpers.sol\";\n\n/**\n * Utility functions helpful when working with UserOperation structs.\n */\nlibrary UserOperationLib {\n\n    uint256 public constant PAYMASTER_VALIDATION_GAS_OFFSET = 20;\n    uint256 public constant PAYMASTER_POSTOP_GAS_OFFSET = 36;\n    uint256 public constant PAYMASTER_DATA_OFFSET = 52;\n    /**\n     * Get sender from user operation data.\n     * @param userOp - The user operation data.\n     */\n    function getSender(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (address) {\n        address data;\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\n        assembly {\n            data := calldataload(userOp)\n        }\n        return address(uint160(data));\n    }\n\n    /**\n     * Relayer/block builder might submit the TX with higher priorityFee,\n     * but the user should not pay above what he signed for.\n     * @param userOp - The user operation data.\n     */\n    function gasPrice(\n        PackedUserOperation calldata userOp\n    ) internal view returns (uint256) {\n        unchecked {\n            (uint256 maxPriorityFeePerGas, uint256 maxFeePerGas) = unpackUints(userOp.gasFees);\n            if (maxFeePerGas == maxPriorityFeePerGas) {\n                //legacy mode (for networks that don't support basefee opcode)\n                return maxFeePerGas;\n            }\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n        }\n    }\n\n    /**\n     * Pack the user operation data into bytes for hashing.\n     * @param userOp - The user operation data.\n     */\n    function encode(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (bytes memory ret) {\n        address sender = getSender(userOp);\n        uint256 nonce = userOp.nonce;\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\n        bytes32 accountGasLimits = userOp.accountGasLimits;\n        uint256 preVerificationGas = userOp.preVerificationGas;\n        bytes32 gasFees = userOp.gasFees;\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\n\n        return abi.encode(\n            sender, nonce,\n            hashInitCode, hashCallData,\n            accountGasLimits, preVerificationGas, gasFees,\n            hashPaymasterAndData\n        );\n    }\n\n    function unpackUints(\n        bytes32 packed\n    ) internal pure returns (uint256 high128, uint256 low128) {\n        return (uint128(bytes16(packed)), uint128(uint256(packed)));\n    }\n\n    //unpack just the high 128-bits from a packed value\n    function unpackHigh128(bytes32 packed) internal pure returns (uint256) {\n        return uint256(packed) >> 128;\n    }\n\n    // unpack just the low 128-bits from a packed value\n    function unpackLow128(bytes32 packed) internal pure returns (uint256) {\n        return uint128(uint256(packed));\n    }\n\n    function unpackMaxPriorityFeePerGas(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackHigh128(userOp.gasFees);\n    }\n\n    function unpackMaxFeePerGas(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackLow128(userOp.gasFees);\n    }\n\n    function unpackVerificationGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackHigh128(userOp.accountGasLimits);\n    }\n\n    function unpackCallGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackLow128(userOp.accountGasLimits);\n    }\n\n    function unpackPaymasterVerificationGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET]));\n    }\n\n    function unpackPostOpGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]));\n    }\n\n    function unpackPaymasterStaticFields(\n        bytes calldata paymasterAndData\n    ) internal pure returns (address paymaster, uint256 validationGasLimit, uint256 postOpGasLimit) {\n        return (\n            address(bytes20(paymasterAndData[: PAYMASTER_VALIDATION_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]))\n        );\n    }\n\n    /**\n     * Hash the user operation data.\n     * @param userOp - The user operation data.\n     */\n    function hash(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (bytes32) {\n        return keccak256(encode(userOp));\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IEntryPoint.sol":{"content":"/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"./PackedUserOperation.sol\";\nimport \"./IStakeManager.sol\";\nimport \"./IAggregator.sol\";\nimport \"./INonceManager.sol\";\n\ninterface IEntryPoint is IStakeManager, INonceManager {\n    /***\n     * An event emitted after each successful request.\n     * @param userOpHash    - Unique identifier for the request (hash its entire content, except signature).\n     * @param sender        - The account that generates this request.\n     * @param paymaster     - If non-null, the paymaster that pays for this request.\n     * @param nonce         - The nonce value from the request.\n     * @param success       - True if the sender transaction succeeded, false if reverted.\n     * @param actualGasCost - Actual amount paid (by account or paymaster) for this UserOperation.\n     * @param actualGasUsed - Total gas used by this UserOperation (including preVerification, creation,\n     *                        validation and execution).\n     */\n    event UserOperationEvent(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address indexed paymaster,\n        uint256 nonce,\n        bool success,\n        uint256 actualGasCost,\n        uint256 actualGasUsed\n    );\n\n    /**\n     * Account \"sender\" was deployed.\n     * @param userOpHash - The userOp that deployed this account. UserOperationEvent will follow.\n     * @param sender     - The account that is deployed\n     * @param factory    - The factory used to deploy this account (in the initCode)\n     * @param paymaster  - The paymaster used by this UserOp\n     */\n    event AccountDeployed(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address factory,\n        address paymaster\n    );\n\n    /**\n     * An event emitted if the UserOperation \"callData\" reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\n     */\n    event UserOperationRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * An event emitted if the UserOperation Paymaster's \"postOp\" call reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\n     */\n    event PostOpRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * UserOp consumed more than prefund. The UserOperation is reverted, and no refund is made.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     */\n    event UserOperationPrefundTooLow(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce\n    );\n\n    /**\n     * An event emitted by handleOps(), before starting the execution loop.\n     * Any event emitted before this event, is part of the validation.\n     */\n    event BeforeExecution();\n\n    /**\n     * Signature aggregator used by the following UserOperationEvents within this bundle.\n     * @param aggregator - The aggregator used for the following UserOperationEvents.\n     */\n    event SignatureAggregatorChanged(address indexed aggregator);\n\n    /**\n     * A custom revert error of handleOps, to identify the offending op.\n     * Should be caught in off-chain handleOps simulation and not happen on-chain.\n     * Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\n     * NOTE: If simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. The string starts with a unique code \"AAmn\",\n     *                  where \"m\" is \"1\" for factory, \"2\" for account and \"3\" for paymaster issues,\n     *                  so a failure can be attributed to the correct entity.\n     */\n    error FailedOp(uint256 opIndex, string reason);\n\n    /**\n     * A custom revert error of handleOps, to report a revert by account or paymaster.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. see FailedOp(uint256,string), above\n     * @param inner   - data from inner cought revert reason\n     * @dev note that inner is truncated to 2048 bytes\n     */\n    error FailedOpWithRevert(uint256 opIndex, string reason, bytes inner);\n\n    error PostOpReverted(bytes returnData);\n\n    /**\n     * Error case when a signature aggregator fails to verify the aggregated signature it had created.\n     * @param aggregator The aggregator that failed to verify the signature\n     */\n    error SignatureValidationFailed(address aggregator);\n\n    // Return value of getSenderAddress.\n    error SenderAddressResult(address sender);\n\n    // UserOps handled, per aggregator.\n    struct UserOpsPerAggregator {\n        PackedUserOperation[] userOps;\n        // Aggregator address\n        IAggregator aggregator;\n        // Aggregated signature\n        bytes signature;\n    }\n\n    /**\n     * Execute a batch of UserOperations.\n     * No signature aggregator is used.\n     * If any account requires an aggregator (that is, it returned an aggregator when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops         - The operations to execute.\n     * @param beneficiary - The address to receive the fees.\n     */\n    function handleOps(\n        PackedUserOperation[] calldata ops,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator - The operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts).\n     * @param beneficiary      - The address to receive the fees.\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Generate a request Id - unique identifier for this request.\n     * The request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     * @param userOp - The user operation to generate the request ID for.\n     * @return hash the hash of this UserOperation\n     */\n    function getUserOpHash(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes32);\n\n    /**\n     * Gas and return values during simulation.\n     * @param preOpGas         - The gas used for validation (including preValidationGas)\n     * @param prefund          - The required prefund for this operation\n     * @param accountValidationData   - returned validationData from account.\n     * @param paymasterValidationData - return validationData from paymaster.\n     * @param paymasterContext - Returned by validatePaymasterUserOp (to be passed into postOp)\n     */\n    struct ReturnInfo {\n        uint256 preOpGas;\n        uint256 prefund;\n        uint256 accountValidationData;\n        uint256 paymasterValidationData;\n        bytes paymasterContext;\n    }\n\n    /**\n     * Returned aggregated signature info:\n     * The aggregator returned by the account, and its current stake.\n     */\n    struct AggregatorStakeInfo {\n        address aggregator;\n        StakeInfo stakeInfo;\n    }\n\n    /**\n     * Get counterfactual sender address.\n     * Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * This method always revert, and returns the address in SenderAddressResult error\n     * @param initCode - The constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes memory initCode) external;\n\n    error DelegateAndRevert(bool success, bytes ret);\n\n    /**\n     * Helper method for dry-run testing.\n     * @dev calling this method, the EntryPoint will make a delegatecall to the given data, and report (via revert) the result.\n     *  The method always revert, so is only useful off-chain for dry run calls, in cases where state-override to replace\n     *  actual EntryPoint code is less convenient.\n     * @param target a target contract to make a delegatecall from entrypoint\n     * @param data data to pass to target in a delegatecall\n     */\n    function delegateAndRevert(address target, bytes calldata data) external;\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/EntryPointSimulations.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n\nimport \"./EntryPoint.sol\";\nimport \"../interfaces/IEntryPointSimulations.sol\";\n\n/*\n * This contract inherits the EntryPoint and extends it with the view-only methods that are executed by\n * the bundler in order to check UserOperation validity and estimate its gas consumption.\n * This contract should never be deployed on-chain and is only used as a parameter for the \"eth_call\" request.\n */\ncontract EntryPointSimulations is EntryPoint, IEntryPointSimulations {\n    // solhint-disable-next-line var-name-mixedcase\n    AggregatorStakeInfo private NOT_AGGREGATED = AggregatorStakeInfo(address(0), StakeInfo(0, 0));\n\n    SenderCreator private _senderCreator;\n\n    function initSenderCreator() internal virtual {\n        //this is the address of the first contract created with CREATE by this address.\n        address createdObj = address(uint160(uint256(keccak256(abi.encodePacked(hex\"d694\", address(this), hex\"01\")))));\n        _senderCreator = SenderCreator(createdObj);\n    }\n\n    function senderCreator() internal view virtual override returns (SenderCreator) {\n        // return the same senderCreator as real EntryPoint.\n        // this call is slightly (100) more expensive than EntryPoint's access to immutable member\n        return _senderCreator;\n    }\n\n    /**\n     * simulation contract should not be deployed, and specifically, accounts should not trust\n     * it as entrypoint, since the simulation functions don't check the signatures\n     */\n    constructor() {\n        // THIS CONTRACT SHOULD NOT BE DEPLOYED\n        // however, the line of code below is commented to allow this entryPoint to be used in fork tests\n        // require(block.number < 100, \"should not be deployed\");\n    }\n\n    /// @inheritdoc IEntryPointSimulations\n    function simulateValidation(\n        PackedUserOperation calldata userOp\n    )\n    external\n    returns (\n        ValidationResult memory\n    ){\n        UserOpInfo memory outOpInfo;\n\n        _simulationOnlyValidations(userOp);\n        (\n            uint256 validationData,\n            uint256 paymasterValidationData\n        ) = _validatePrepayment(0, userOp, outOpInfo);\n        StakeInfo memory paymasterInfo = _getStakeInfo(\n            outOpInfo.mUserOp.paymaster\n        );\n        StakeInfo memory senderInfo = _getStakeInfo(outOpInfo.mUserOp.sender);\n        StakeInfo memory factoryInfo;\n        {\n            bytes calldata initCode = userOp.initCode;\n            address factory = initCode.length >= 20\n                ? address(bytes20(initCode[0 : 20]))\n                : address(0);\n            factoryInfo = _getStakeInfo(factory);\n        }\n\n        address aggregator = address(uint160(validationData));\n        ReturnInfo memory returnInfo = ReturnInfo(\n            outOpInfo.preOpGas,\n            outOpInfo.prefund,\n            validationData,\n            paymasterValidationData,\n            getMemoryBytesFromOffset(outOpInfo.contextOffset)\n        );\n\n        AggregatorStakeInfo memory aggregatorInfo = NOT_AGGREGATED;\n        if (uint160(aggregator) != SIG_VALIDATION_SUCCESS && uint160(aggregator) != SIG_VALIDATION_FAILED) {\n            aggregatorInfo = AggregatorStakeInfo(\n                aggregator,\n                _getStakeInfo(aggregator)\n            );\n        }\n        return ValidationResult(\n            returnInfo,\n            senderInfo,\n            factoryInfo,\n            paymasterInfo,\n            aggregatorInfo\n        );\n    }\n\n    /// @inheritdoc IEntryPointSimulations\n    function simulateHandleOp(\n        PackedUserOperation calldata op,\n        address target,\n        bytes calldata targetCallData\n    )\n    external nonReentrant\n    returns (\n        ExecutionResult memory\n    ){\n        UserOpInfo memory opInfo;\n        _simulationOnlyValidations(op);\n        (\n            uint256 validationData,\n            uint256 paymasterValidationData\n        ) = _validatePrepayment(0, op, opInfo);\n\n        uint256 paid = _executeUserOp(0, op, opInfo);\n        bool targetSuccess;\n        bytes memory targetResult;\n        if (target != address(0)) {\n            (targetSuccess, targetResult) = target.call(targetCallData);\n        }\n        return ExecutionResult(\n            opInfo.preOpGas,\n            paid,\n            validationData,\n            paymasterValidationData,\n            targetSuccess,\n            targetResult\n        );\n    }\n\n    function _simulationOnlyValidations(\n        PackedUserOperation calldata userOp\n    )\n    internal\n    {\n        //initialize senderCreator(). we can't rely on constructor\n        initSenderCreator();\n\n        try\n        this._validateSenderAndPaymaster(\n            userOp.initCode,\n            userOp.sender,\n            userOp.paymasterAndData\n        )\n        // solhint-disable-next-line no-empty-blocks\n        {} catch Error(string memory revertReason) {\n            if (bytes(revertReason).length != 0) {\n                revert FailedOp(0, revertReason);\n            }\n        }\n    }\n\n    /**\n     * Called only during simulation.\n     * This function always reverts to prevent warm/cold storage differentiation in simulation vs execution.\n     * @param initCode         - The smart account constructor code.\n     * @param sender           - The sender address.\n     * @param paymasterAndData - The paymaster address (followed by other params, ignored by this method)\n     */\n    function _validateSenderAndPaymaster(\n        bytes calldata initCode,\n        address sender,\n        bytes calldata paymasterAndData\n    ) external view {\n        if (initCode.length == 0 && sender.code.length == 0) {\n            // it would revert anyway. but give a meaningful message\n            revert(\"AA20 account not deployed\");\n        }\n        if (paymasterAndData.length >= 20) {\n            address paymaster = address(bytes20(paymasterAndData[0 : 20]));\n            if (paymaster.code.length == 0) {\n                // It would revert anyway. but give a meaningful message.\n                revert(\"AA30 paymaster not deployed\");\n            }\n        }\n        // always revert\n        revert(\"\");\n    }\n\n    //make sure depositTo cost is more than normal EntryPoint's cost,\n    // to mitigate DoS vector on the bundler\n    // empiric test showed that without this wrapper, simulation depositTo costs less..\n    function depositTo(address account) public override(IStakeManager, StakeManager) payable {\n        unchecked{\n        // silly code, to waste some gas to make sure depositTo is always little more\n        // expensive than on-chain call\n            uint256 x = 1;\n            while (x < 5) {\n                x++;\n            }\n            StakeManager.depositTo(account);\n        }\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IEntryPointSimulations.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\nimport \"./IEntryPoint.sol\";\n\ninterface IEntryPointSimulations is IEntryPoint {\n    // Return value of simulateHandleOp.\n    struct ExecutionResult {\n        uint256 preOpGas;\n        uint256 paid;\n        uint256 accountValidationData;\n        uint256 paymasterValidationData;\n        bool targetSuccess;\n        bytes targetResult;\n    }\n\n    /**\n     * Successful result from simulateValidation.\n     * If the account returns a signature aggregator the \"aggregatorInfo\" struct is filled in as well.\n     * @param returnInfo     Gas and time-range returned values\n     * @param senderInfo     Stake information about the sender\n     * @param factoryInfo    Stake information about the factory (if any)\n     * @param paymasterInfo  Stake information about the paymaster (if any)\n     * @param aggregatorInfo Signature aggregation info (if the account requires signature aggregator)\n     *                       Bundler MUST use it to verify the signature, or reject the UserOperation.\n     */\n    struct ValidationResult {\n        ReturnInfo returnInfo;\n        StakeInfo senderInfo;\n        StakeInfo factoryInfo;\n        StakeInfo paymasterInfo;\n        AggregatorStakeInfo aggregatorInfo;\n    }\n\n    /**\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage\n     *      outside the account's data.\n     * @param userOp - The user operation to validate.\n     * @return the validation result structure\n     */\n    function simulateValidation(\n        PackedUserOperation calldata userOp\n    )\n    external\n    returns (\n        ValidationResult memory\n    );\n\n    /**\n     * Simulate full execution of a UserOperation (including both validation and target execution)\n     * It performs full validation of the UserOperation, but ignores signature error.\n     * An optional target address is called after the userop succeeds,\n     * and its value is returned (before the entire call is reverted).\n     * Note that in order to collect the the success/failure of the target call, it must be executed\n     * with trace enabled to track the emitted events.\n     * @param op The UserOperation to simulate.\n     * @param target         - If nonzero, a target address to call after userop simulation. If called,\n     *                         the targetSuccess and targetResult are set to the return from that call.\n     * @param targetCallData - CallData to pass to target address.\n     * @return the execution result structure\n     */\n    function simulateHandleOp(\n        PackedUserOperation calldata op,\n        address target,\n        bytes calldata targetCallData\n    )\n    external\n    returns (\n        ExecutionResult memory\n    );\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/Helpers.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/* solhint-disable no-inline-assembly */\n\n\n /*\n  * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\n  * must return this value in case of signature failure, instead of revert.\n  */\nuint256 constant SIG_VALIDATION_FAILED = 1;\n\n\n/*\n * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\n * return this value on success.\n */\nuint256 constant SIG_VALIDATION_SUCCESS = 0;\n\n\n/**\n * Returned data from validateUserOp.\n * validateUserOp returns a uint256, which is created by `_packedValidationData` and\n * parsed by `_parseValidationData`.\n * @param aggregator  - address(0) - The account validated the signature by itself.\n *                      address(1) - The account failed to validate the signature.\n *                      otherwise - This is an address of a signature aggregator that must\n *                                  be used to validate the signature.\n * @param validAfter  - This UserOp is valid only after this timestamp.\n * @param validaUntil - This UserOp is valid only up to this timestamp.\n */\nstruct ValidationData {\n    address aggregator;\n    uint48 validAfter;\n    uint48 validUntil;\n}\n\n/**\n * Extract sigFailed, validAfter, validUntil.\n * Also convert zero validUntil to type(uint48).max.\n * @param validationData - The packed validation data.\n */\nfunction _parseValidationData(\n    uint256 validationData\n) pure returns (ValidationData memory data) {\n    address aggregator = address(uint160(validationData));\n    uint48 validUntil = uint48(validationData >> 160);\n    if (validUntil == 0) {\n        validUntil = type(uint48).max;\n    }\n    uint48 validAfter = uint48(validationData >> (48 + 160));\n    return ValidationData(aggregator, validAfter, validUntil);\n}\n\n/**\n * Helper to pack the return value for validateUserOp.\n * @param data - The ValidationData to pack.\n */\nfunction _packValidationData(\n    ValidationData memory data\n) pure returns (uint256) {\n    return\n        uint160(data.aggregator) |\n        (uint256(data.validUntil) << 160) |\n        (uint256(data.validAfter) << (160 + 48));\n}\n\n/**\n * Helper to pack the return value for validateUserOp, when not using an aggregator.\n * @param sigFailed  - True for signature failure, false for success.\n * @param validUntil - Last timestamp this UserOperation is valid (or zero for infinite).\n * @param validAfter - First timestamp this UserOperation is valid.\n */\nfunction _packValidationData(\n    bool sigFailed,\n    uint48 validUntil,\n    uint48 validAfter\n) pure returns (uint256) {\n    return\n        (sigFailed ? 1 : 0) |\n        (uint256(validUntil) << 160) |\n        (uint256(validAfter) << (160 + 48));\n}\n\n/**\n * keccak function over calldata.\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\n */\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\n        assembly (\"memory-safe\") {\n            let mem := mload(0x40)\n            let len := data.length\n            calldatacopy(mem, data.offset, len)\n            ret := keccak256(mem, len)\n        }\n    }\n\n\n/**\n * The minimum of two numbers.\n * @param a - First number.\n * @param b - Second number.\n */\n    function min(uint256 a, uint256 b) pure returns (uint256) {\n        return a < b ? a : b;\n    }\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IStakeManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.5;\n\n/**\n * Manage deposits and stakes.\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\n * Stake is value locked for at least \"unstakeDelay\" by the staked entity.\n */\ninterface IStakeManager {\n    event Deposited(address indexed account, uint256 totalDeposit);\n\n    event Withdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    // Emitted when stake or unstake delay are modified.\n    event StakeLocked(\n        address indexed account,\n        uint256 totalStaked,\n        uint256 unstakeDelaySec\n    );\n\n    // Emitted once a stake is scheduled for withdrawal.\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\n\n    event StakeWithdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /**\n     * @param deposit         - The entity's deposit.\n     * @param staked          - True if this entity is staked.\n     * @param stake           - Actual amount of ether staked for this entity.\n     * @param unstakeDelaySec - Minimum delay to withdraw the stake.\n     * @param withdrawTime    - First block timestamp where 'withdrawStake' will be callable, or zero if already locked.\n     * @dev Sizes were chosen so that deposit fits into one cell (used during handleOp)\n     *      and the rest fit into a 2nd cell (used during stake/unstake)\n     *      - 112 bit allows for 10^15 eth\n     *      - 48 bit for full timestamp\n     *      - 32 bit allows 150 years for unstake delay\n     */\n    struct DepositInfo {\n        uint256 deposit;\n        bool staked;\n        uint112 stake;\n        uint32 unstakeDelaySec;\n        uint48 withdrawTime;\n    }\n\n    // API struct used by getStakeInfo and simulateValidation.\n    struct StakeInfo {\n        uint256 stake;\n        uint256 unstakeDelaySec;\n    }\n\n    /**\n     * Get deposit info.\n     * @param account - The account to query.\n     * @return info   - Full deposit information of given account.\n     */\n    function getDepositInfo(\n        address account\n    ) external view returns (DepositInfo memory info);\n\n    /**\n     * Get account balance.\n     * @param account - The account to query.\n     * @return        - The deposit (for gas payment) of the account.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * Add to the deposit of the given account.\n     * @param account - The account to add to.\n     */\n    function depositTo(address account) external payable;\n\n    /**\n     * Add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param _unstakeDelaySec - The new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 _unstakeDelaySec) external payable;\n\n    /**\n     * Attempt to unlock the stake.\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external;\n\n    /**\n     * Withdraw from the (unlocked) stake.\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external;\n\n    /**\n     * Withdraw from the deposit.\n     * @param withdrawAddress - The address to send withdrawn value.\n     * @param withdrawAmount  - The amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 withdrawAmount\n    ) external;\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IAccount.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\ninterface IAccount {\n    /**\n     * Validate user's signature and nonce\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\n     * This allows making a \"simulation call\" without a valid signature\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\n     *\n     * @dev Must validate caller is the entryPoint.\n     *      Must validate the signature and nonce\n     * @param userOp              - The operation that is about to be executed.\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for signature.\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\n     *                              This is the minimum amount to transfer to the sender(entryPoint) to be\n     *                              able to make the call. The excess is left as a deposit in the entrypoint\n     *                              for future calls. Can be withdrawn anytime using \"entryPoint.withdrawTo()\".\n     *                              In case there is a paymaster in the request (or the current deposit is high\n     *                              enough), this value will be zero.\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData` and\n     *                              `_unpackValidationData` to encode and decode.\n     *                              <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *                                 otherwise, an address of an \"authorizer\" contract.\n     *                              <6-byte> validUntil - Last timestamp this operation is valid. 0 for \"indefinite\"\n     *                              <6-byte> validAfter - First timestamp this operation is valid\n     *                                                    If an account doesn't use time-range, it is enough to\n     *                                                    return SIG_VALIDATION_FAILED value (1) for signature failure.\n     *                              Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external returns (uint256 validationData);\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IAccountExecute.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\ninterface IAccountExecute {\n    /**\n     * Account may implement this execute method.\n     * passing this methodSig at the beginning of callData will cause the entryPoint to pass the full UserOp (and hash)\n     * to the account.\n     * The account should skip the methodSig, and use the callData (and optionally, other UserOp fields)\n     *\n     * @param userOp              - The operation that was just validated.\n     * @param userOpHash          - Hash of the user's request data.\n     */\n    function executeUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external;\n}\n"},"contracts/core/NonceManager.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.25;\n\nimport { PermissionId } from \"../DataTypes.sol\";\nimport { ISmartSession } from \"../ISmartSession.sol\";\n/**\n * @title NonceManager\n * @dev Abstract contract for managing nonces for smart sessions\n */\n\nabstract contract NonceManager is ISmartSession {\n    /// @dev Mapping to store nonces for each permission ID and smart account\n    mapping(PermissionId permissionId => mapping(address smartAccount => uint256 nonce)) internal $signerNonce;\n\n    /**\n     * @notice Get the current nonce for a given permission ID and account\n     * @param permissionId The permission ID\n     * @param account The smart account address\n     * @return The current nonce value\n     */\n    function getNonce(PermissionId permissionId, address account) external view returns (uint256) {\n        return $signerNonce[permissionId][account];\n    }\n\n    /**\n     * @notice Revoke the current enable signature by incrementing the nonce\n     * @param permissionId The permission ID to revoke the signature for\n     */\n    function revokeEnableSignature(PermissionId permissionId) external {\n        // Increment the nonce and store the old value\n        uint256 nonce = $signerNonce[permissionId][msg.sender]++;\n        emit NonceIterated(permissionId, msg.sender, nonce + 1);\n    }\n}\n"},"node_modules/solady/src/utils/EIP712.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Contract for EIP-712 typed structured data hashing and signing.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)\n/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)\n///\n/// @dev Note, this implementation:\n/// - Uses `address(this)` for the `verifyingContract` field.\n/// - Does NOT use the optional EIP-712 salt.\n/// - Does NOT use any EIP-712 extensions.\n/// This is for simplicity and to save gas.\n/// If you need to customize, please fork / modify accordingly.\nabstract contract EIP712 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  CONSTANTS AND IMMUTABLES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 internal constant _DOMAIN_TYPEHASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    uint256 private immutable _cachedThis;\n    uint256 private immutable _cachedChainId;\n    bytes32 private immutable _cachedNameHash;\n    bytes32 private immutable _cachedVersionHash;\n    bytes32 private immutable _cachedDomainSeparator;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CONSTRUCTOR                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Cache the hashes for cheaper runtime gas costs.\n    /// In the case of upgradeable contracts (i.e. proxies),\n    /// or if the chain id changes due to a hard fork,\n    /// the domain separator will be seamlessly calculated on-the-fly.\n    constructor() {\n        _cachedThis = uint256(uint160(address(this)));\n        _cachedChainId = block.chainid;\n\n        string memory name;\n        string memory version;\n        if (!_domainNameAndVersionMayChange()) (name, version) = _domainNameAndVersion();\n        bytes32 nameHash = _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(name));\n        bytes32 versionHash =\n            _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(version));\n        _cachedNameHash = nameHash;\n        _cachedVersionHash = versionHash;\n\n        bytes32 separator;\n        if (!_domainNameAndVersionMayChange()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let m := mload(0x40) // Load the free memory pointer.\n                mstore(m, _DOMAIN_TYPEHASH)\n                mstore(add(m, 0x20), nameHash)\n                mstore(add(m, 0x40), versionHash)\n                mstore(add(m, 0x60), chainid())\n                mstore(add(m, 0x80), address())\n                separator := keccak256(m, 0xa0)\n            }\n        }\n        _cachedDomainSeparator = separator;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   FUNCTIONS TO OVERRIDE                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Please override this function to return the domain name and version.\n    /// ```\n    ///     function _domainNameAndVersion()\n    ///         internal\n    ///         pure\n    ///         virtual\n    ///         returns (string memory name, string memory version)\n    ///     {\n    ///         name = \"Solady\";\n    ///         version = \"1\";\n    ///     }\n    /// ```\n    ///\n    /// Note: If the returned result may change after the contract has been deployed,\n    /// you must override `_domainNameAndVersionMayChange()` to return true.\n    function _domainNameAndVersion()\n        internal\n        view\n        virtual\n        returns (string memory name, string memory version);\n\n    /// @dev Returns if `_domainNameAndVersion()` may change\n    /// after the contract has been deployed (i.e. after the constructor).\n    /// Default: false.\n    function _domainNameAndVersionMayChange() internal pure virtual returns (bool result) {}\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _domainSeparator() internal view virtual returns (bytes32 separator) {\n        if (_domainNameAndVersionMayChange()) {\n            separator = _buildDomainSeparator();\n        } else {\n            separator = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) separator = _buildDomainSeparator();\n        }\n    }\n\n    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,\n    /// given `structHash`, as defined in\n    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\n    ///\n    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:\n    /// ```\n    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(\n    ///         keccak256(\"Mail(address to,string contents)\"),\n    ///         mailTo,\n    ///         keccak256(bytes(mailContents))\n    ///     )));\n    ///     address signer = ECDSA.recover(digest, signature);\n    /// ```\n    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\n        // We will use `digest` to store the domain separator to save a bit of gas.\n        if (_domainNameAndVersionMayChange()) {\n            digest = _buildDomainSeparator();\n        } else {\n            digest = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) digest = _buildDomainSeparator();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the digest.\n            mstore(0x00, 0x1901000000000000) // Store \"\\x19\\x01\".\n            mstore(0x1a, digest) // Store the domain separator.\n            mstore(0x3a, structHash) // Store the struct hash.\n            digest := keccak256(0x18, 0x42)\n            // Restore the part of the free memory slot that was overwritten.\n            mstore(0x3a, 0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    EIP-5267 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        fields = hex\"0f\"; // `0b01111`.\n        (name, version) = _domainNameAndVersion();\n        chainId = block.chainid;\n        verifyingContract = address(this);\n        salt = salt; // `bytes32(0)`.\n        extensions = extensions; // `new uint256[](0)`.\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _buildDomainSeparator() private view returns (bytes32 separator) {\n        // We will use `separator` to store the name hash to save a bit of gas.\n        bytes32 versionHash;\n        if (_domainNameAndVersionMayChange()) {\n            (string memory name, string memory version) = _domainNameAndVersion();\n            separator = keccak256(bytes(name));\n            versionHash = keccak256(bytes(version));\n        } else {\n            separator = _cachedNameHash;\n            versionHash = _cachedVersionHash;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), separator) // Name hash.\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            separator := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns if the cached domain separator has been invalidated.\n    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\n        uint256 cachedChainId = _cachedChainId;\n        uint256 cachedThis = _cachedThis;\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\n        }\n    }\n}\n"},"node_modules/erc7579/src/interfaces/IERC7579Module.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\nuint256 constant VALIDATION_SUCCESS = 0;\nuint256 constant VALIDATION_FAILED = 1;\n\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\nuint256 constant MODULE_TYPE_FALLBACK = 3;\nuint256 constant MODULE_TYPE_HOOK = 4;\n\ninterface IModule {\n    error AlreadyInitialized(address smartAccount);\n    error NotInitialized(address smartAccount);\n\n    /**\n     * @dev This function is called by the smart account during installation of the module\n     * @param data arbitrary data that may be required on the module during `onInstall`\n     * initialization\n     *\n     * MUST revert on error (i.e. if module is already enabled)\n     */\n    function onInstall(bytes calldata data) external;\n\n    /**\n     * @dev This function is called by the smart account during uninstallation of the module\n     * @param data arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization\n     *\n     * MUST revert on error\n     */\n    function onUninstall(bytes calldata data) external;\n\n    /**\n     * @dev Returns boolean value if module is a certain type\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *\n     * MUST return true if the module is of the given type and false otherwise\n     */\n    function isModuleType(uint256 moduleTypeId) external view returns (bool);\n\n    /**\n     * @dev Returns if the module was already initialized for a provided smartaccount\n     */\n    function isInitialized(address smartAccount) external view returns (bool);\n}\n\ninterface IValidator is IModule {\n    error InvalidTargetAddress(address target);\n\n    /**\n     * @dev Validates a transaction on behalf of the account.\n     *         This function is intended to be called by the MSA during the ERC-4337 validaton phase\n     *         Note: solely relying on bytes32 hash and signature is not suffcient for some\n     * validation implementations (i.e. SessionKeys often need access to userOp.calldata)\n     * @param userOp The user operation to be validated. The userOp MUST NOT contain any metadata.\n     * The MSA MUST clean up the userOp before sending it to the validator.\n     * @param userOpHash The hash of the user operation to be validated\n     * @return return value according to ERC-4337\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        returns (uint256);\n\n    /**\n     * Validator can be used for ERC-1271 validation\n     */\n    function isValidSignatureWithSender(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes4);\n}\n\ninterface IExecutor is IModule { }\n\ninterface IHook is IModule {\n    function preCheck(\n        address msgSender,\n        uint256 msgValue,\n        bytes calldata msgData\n    )\n        external\n        returns (bytes memory hookData);\n\n    function postCheck(bytes calldata hookData) external;\n}\n\ninterface IFallback is IModule { }\n"},"node_modules/forge-std/src/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    /// uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"},"node_modules/excessively-safe-call/src/ExcessivelySafeCall.sol":{"content":"// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.7.6;\n\nlibrary ExcessivelySafeCall {\n    uint256 constant LOW_28_MASK =\n        0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _value The value in wei to send to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeCall(\n        address _target,\n        uint256 _gas,\n        uint256 _value,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeStaticCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n                _gas, // gas\n                _target, // recipient\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /**\n     * @notice Swaps function selectors in encoded contract calls\n     * @dev Allows reuse of encoded calldata for functions with identical\n     * argument types but different names. It simply swaps out the first 4 bytes\n     * for the new selector. This function modifies memory in place, and should\n     * only be used with caution.\n     * @param _newSelector The new 4-byte selector\n     * @param _buf The encoded contract args\n     */\n    function swapSelector(bytes4 _newSelector, bytes memory _buf)\n        internal\n        pure\n    {\n        require(_buf.length >= 4);\n        uint256 _mask = LOW_28_MASK;\n        assembly {\n            // load the first word of\n            let _word := mload(add(_buf, 0x20))\n            // mask out the top 4 bytes\n            // /x\n            _word := and(_word, _mask)\n            _word := or(_newSelector, _word)\n            mstore(add(_buf, 0x20), _word)\n        }\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/introspection/ERC165Checker.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"},"node_modules/solady/src/utils/LibZip.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for compressing and decompressing bytes.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibZip.sol)\n/// @author Calldata compression by clabby (https://github.com/clabby/op-kompressor)\n/// @author FastLZ by ariya (https://github.com/ariya/FastLZ)\n///\n/// @dev Note:\n/// The accompanying solady.js library includes implementations of\n/// FastLZ and calldata operations for convenience.\nlibrary LibZip {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     FAST LZ OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // LZ77 implementation based on FastLZ.\n    // Equivalent to level 1 compression and decompression at the following commit:\n    // https://github.com/ariya/FastLZ/commit/344eb4025f9ae866ebf7a2ec48850f7113a97a42\n    // Decompression is backwards compatible.\n\n    /// @dev Returns the compressed `data`.\n    function flzCompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function ms8(d_, v_) -> _d {\n                mstore8(d_, v_)\n                _d := add(d_, 1)\n            }\n            function u24(p_) -> _u {\n                _u := mload(p_)\n                _u := or(shl(16, byte(2, _u)), or(shl(8, byte(1, _u)), byte(0, _u)))\n            }\n            function cmp(p_, q_, e_) -> _l {\n                for { e_ := sub(e_, q_) } lt(_l, e_) { _l := add(_l, 1) } {\n                    e_ := mul(iszero(byte(0, xor(mload(add(p_, _l)), mload(add(q_, _l))))), e_)\n                }\n            }\n            function literals(runs_, src_, dest_) -> _o {\n                for { _o := dest_ } iszero(lt(runs_, 0x20)) { runs_ := sub(runs_, 0x20) } {\n                    mstore(ms8(_o, 31), mload(src_))\n                    _o := add(_o, 0x21)\n                    src_ := add(src_, 0x20)\n                }\n                if iszero(runs_) { leave }\n                mstore(ms8(_o, sub(runs_, 1)), mload(src_))\n                _o := add(1, add(_o, runs_))\n            }\n            function mt(l_, d_, o_) -> _o {\n                for { d_ := sub(d_, 1) } iszero(lt(l_, 263)) { l_ := sub(l_, 262) } {\n                    o_ := ms8(ms8(ms8(o_, add(224, shr(8, d_))), 253), and(0xff, d_))\n                }\n                if iszero(lt(l_, 7)) {\n                    _o := ms8(ms8(ms8(o_, add(224, shr(8, d_))), sub(l_, 7)), and(0xff, d_))\n                    leave\n                }\n                _o := ms8(ms8(o_, add(shl(5, l_), shr(8, d_))), and(0xff, d_))\n            }\n            function setHash(i_, v_) {\n                let p_ := add(mload(0x40), shl(2, i_))\n                mstore(p_, xor(mload(p_), shl(224, xor(shr(224, mload(p_)), v_))))\n            }\n            function getHash(i_) -> _h {\n                _h := shr(224, mload(add(mload(0x40), shl(2, i_))))\n            }\n            function hash(v_) -> _r {\n                _r := and(shr(19, mul(2654435769, v_)), 0x1fff)\n            }\n            function setNextHash(ip_, ipStart_) -> _ip {\n                setHash(hash(u24(ip_)), sub(ip_, ipStart_))\n                _ip := add(ip_, 1)\n            }\n            result := mload(0x40)\n            codecopy(result, codesize(), 0x8000) // Zeroize the hashmap.\n            let op := add(result, 0x8000)\n            let a := add(data, 0x20)\n            let ipStart := a\n            let ipLimit := sub(add(ipStart, mload(data)), 13)\n            for { let ip := add(2, a) } lt(ip, ipLimit) {} {\n                let r := 0\n                let d := 0\n                for {} 1 {} {\n                    let s := u24(ip)\n                    let h := hash(s)\n                    r := add(ipStart, getHash(h))\n                    setHash(h, sub(ip, ipStart))\n                    d := sub(ip, r)\n                    if iszero(lt(ip, ipLimit)) { break }\n                    ip := add(ip, 1)\n                    if iszero(gt(d, 0x1fff)) { if eq(s, u24(r)) { break } }\n                }\n                if iszero(lt(ip, ipLimit)) { break }\n                ip := sub(ip, 1)\n                if gt(ip, a) { op := literals(sub(ip, a), a, op) }\n                let l := cmp(add(r, 3), add(ip, 3), add(ipLimit, 9))\n                op := mt(l, d, op)\n                ip := setNextHash(setNextHash(add(ip, l), ipStart), ipStart)\n                a := ip\n            }\n            // Copy the result to compact the memory, overwriting the hashmap.\n            let end := sub(literals(sub(add(ipStart, mload(data)), a), a, op), 0x7fe0)\n            let o := add(result, 0x20)\n            mstore(result, sub(end, o)) // Store the length.\n            for {} iszero(gt(o, end)) { o := add(o, 0x20) } { mstore(o, mload(add(o, 0x7fe0))) }\n            mstore(end, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(end, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Returns the decompressed `data`.\n    function flzDecompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let op := add(result, 0x20)\n            let end := add(add(data, 0x20), mload(data))\n            for { data := add(data, 0x20) } lt(data, end) {} {\n                let w := mload(data)\n                let c := byte(0, w)\n                let t := shr(5, c)\n                if iszero(t) {\n                    mstore(op, mload(add(data, 1)))\n                    data := add(data, add(2, c))\n                    op := add(op, add(1, c))\n                    continue\n                }\n                for {\n                    let g := eq(t, 7)\n                    let l := add(2, xor(t, mul(g, xor(t, add(7, byte(1, w)))))) // M\n                    let s := add(add(shl(8, and(0x1f, c)), byte(add(1, g), w)), 1) // R\n                    let r := sub(op, s)\n                    let f := xor(s, mul(gt(s, 0x20), xor(s, 0x20)))\n                    let j := 0\n                } 1 {} {\n                    mstore(add(op, j), mload(add(r, j)))\n                    j := add(j, f)\n                    if lt(j, l) { continue }\n                    data := add(data, add(2, g))\n                    op := add(op, l)\n                    break\n                }\n            }\n            mstore(result, sub(op, add(result, 0x20))) // Store the length.\n            mstore(op, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(op, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    CALLDATA OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Calldata compression and decompression using selective run length encoding:\n    // - Sequences of 0x00 (up to 128 consecutive).\n    // - Sequences of 0xff (up to 32 consecutive).\n    //\n    // A run length encoded block consists of two bytes:\n    // (0) 0x00\n    // (1) A control byte with the following bit layout:\n    //     - [7]     `0: 0x00, 1: 0xff`.\n    //     - [0..6]  `runLength - 1`.\n    //\n    // The first 4 bytes are bitwise negated so that the compressed calldata\n    // can be dispatched into the `fallback` and `receive` functions.\n\n    /// @dev Returns the compressed `data`.\n    function cdCompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function rle(v_, o_, d_) -> _o, _d {\n                mstore(o_, shl(240, or(and(0xff, add(d_, 0xff)), and(0x80, v_))))\n                _o := add(o_, 2)\n            }\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            let z := 0 // Number of consecutive 0x00.\n            let y := 0 // Number of consecutive 0xff.\n            for { let end := add(data, mload(data)) } iszero(eq(data, end)) {} {\n                data := add(data, 1)\n                let c := byte(31, mload(data))\n                if iszero(c) {\n                    if y { o, y := rle(0xff, o, y) }\n                    z := add(z, 1)\n                    if eq(z, 0x80) { o, z := rle(0x00, o, 0x80) }\n                    continue\n                }\n                if eq(c, 0xff) {\n                    if z { o, z := rle(0x00, o, z) }\n                    y := add(y, 1)\n                    if eq(y, 0x20) { o, y := rle(0xff, o, 0x20) }\n                    continue\n                }\n                if y { o, y := rle(0xff, o, y) }\n                if z { o, z := rle(0x00, o, z) }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            if y { o, y := rle(0xff, o, y) }\n            if z { o, z := rle(0x00, o, z) }\n            // Bitwise negate the first 4 bytes.\n            mstore(add(result, 4), not(mload(add(result, 4))))\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Returns the decompressed `data`.\n    function cdDecompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(data) {\n                result := mload(0x40)\n                let o := add(result, 0x20)\n                let s := add(data, 4)\n                let v := mload(s)\n                let end := add(data, mload(data))\n                mstore(s, not(v)) // Bitwise negate the first 4 bytes.\n                for {} lt(data, end) {} {\n                    data := add(data, 1)\n                    let c := byte(31, mload(data))\n                    if iszero(c) {\n                        data := add(data, 1)\n                        let d := byte(31, mload(data))\n                        // Fill with either 0xff or 0x00.\n                        mstore(o, not(0))\n                        if iszero(gt(d, 0x7f)) { codecopy(o, codesize(), add(d, 1)) }\n                        o := add(o, add(and(d, 0x7f), 1))\n                        continue\n                    }\n                    mstore8(o, c)\n                    o := add(o, 1)\n                }\n                mstore(s, v) // Restore the first 4 bytes.\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\n                mstore(o, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x20)) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev To be called in the `fallback` function.\n    /// ```\n    ///     fallback() external payable { LibZip.cdFallback(); }\n    ///     receive() external payable {} // Silence compiler warning to add a `receive` function.\n    /// ```\n    /// For efficiency, this function will directly return the results, terminating the context.\n    /// If called internally, it must be called at the end of the function.\n    function cdFallback() internal {\n        assembly {\n            if iszero(calldatasize()) { return(calldatasize(), calldatasize()) }\n            let o := 0\n            let f := not(3) // For negating the first 4 bytes.\n            for { let i := 0 } lt(i, calldatasize()) {} {\n                let c := byte(0, xor(add(i, f), calldataload(i)))\n                i := add(i, 1)\n                if iszero(c) {\n                    let d := byte(0, xor(add(i, f), calldataload(i)))\n                    i := add(i, 1)\n                    // Fill with either 0xff or 0x00.\n                    mstore(o, not(0))\n                    if iszero(gt(d, 0x7f)) { codecopy(o, codesize(), add(d, 1)) }\n                    o := add(o, add(and(d, 0x7f), 1))\n                    continue\n                }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            let success := delegatecall(gas(), address(), 0x00, o, codesize(), 0x00)\n            returndatacopy(0x00, 0x00, returndatasize())\n            if iszero(success) { revert(0x00, returndatasize()) }\n            return(0x00, returndatasize())\n        }\n    }\n}\n"},"node_modules/solady/src/utils/EfficientHashLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for efficiently performing keccak256 hashes.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EfficientHashLib.sol)\n/// @dev To avoid stack-too-deep, you can use:\n/// ```\n/// bytes32[] memory buffer = EfficientHashLib.malloc(10);\n/// EfficientHashLib.set(buffer, 0, value0);\n/// ..\n/// EfficientHashLib.set(buffer, 9, value9);\n/// bytes32 finalHash = EfficientHashLib.hash(buffer);\n/// ```\nlibrary EfficientHashLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*               MALLOC-LESS HASHING OPERATIONS               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `keccak256(abi.encode(value0))`.\n    function hash(bytes32 value0) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, value0)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(value0))`.\n    function hash(uint256 value0) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, value0)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(value0, value1))`.\n    function hash(bytes32 value0, bytes32 value1) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, value0)\n            mstore(0x20, value1)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(value0, value1))`.\n    function hash(uint256 value0, uint256 value1) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, value0)\n            mstore(0x20, value1)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(value0, value1, value2))`.\n    function hash(bytes32 value0, bytes32 value1, bytes32 value2)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, value0)\n            mstore(add(m, 0x20), value1)\n            mstore(add(m, 0x40), value2)\n            result := keccak256(m, 0x60)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(value0, value1, value2))`.\n    function hash(uint256 value0, uint256 value1, uint256 value2)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, value0)\n            mstore(add(m, 0x20), value1)\n            mstore(add(m, 0x40), value2)\n            result := keccak256(m, 0x60)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(value0, value1, value2, value3))`.\n    function hash(bytes32 value0, bytes32 value1, bytes32 value2, bytes32 value3)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, value0)\n            mstore(add(m, 0x20), value1)\n            mstore(add(m, 0x40), value2)\n            mstore(add(m, 0x60), value3)\n            result := keccak256(m, 0x80)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(value0, value1, value2, value3))`.\n    function hash(uint256 value0, uint256 value1, uint256 value2, uint256 value3)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, value0)\n            mstore(add(m, 0x20), value1)\n            mstore(add(m, 0x40), value2)\n            mstore(add(m, 0x60), value3)\n            result := keccak256(m, 0x80)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(value0, .., value4))`.\n    function hash(bytes32 value0, bytes32 value1, bytes32 value2, bytes32 value3, bytes32 value4)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, value0)\n            mstore(add(m, 0x20), value1)\n            mstore(add(m, 0x40), value2)\n            mstore(add(m, 0x60), value3)\n            mstore(add(m, 0x80), value4)\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(value0, .., value4))`.\n    function hash(uint256 value0, uint256 value1, uint256 value2, uint256 value3, uint256 value4)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, value0)\n            mstore(add(m, 0x20), value1)\n            mstore(add(m, 0x40), value2)\n            mstore(add(m, 0x60), value3)\n            mstore(add(m, 0x80), value4)\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(value0, .., value5))`.\n    function hash(\n        bytes32 value0,\n        bytes32 value1,\n        bytes32 value2,\n        bytes32 value3,\n        bytes32 value4,\n        bytes32 value5\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, value0)\n            mstore(add(m, 0x20), value1)\n            mstore(add(m, 0x40), value2)\n            mstore(add(m, 0x60), value3)\n            mstore(add(m, 0x80), value4)\n            mstore(add(m, 0xa0), value5)\n            result := keccak256(m, 0xc0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(value0, .., value5))`.\n    function hash(\n        uint256 value0,\n        uint256 value1,\n        uint256 value2,\n        uint256 value3,\n        uint256 value4,\n        uint256 value5\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, value0)\n            mstore(add(m, 0x20), value1)\n            mstore(add(m, 0x40), value2)\n            mstore(add(m, 0x60), value3)\n            mstore(add(m, 0x80), value4)\n            mstore(add(m, 0xa0), value5)\n            result := keccak256(m, 0xc0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(value0, .., value6))`.\n    function hash(\n        bytes32 value0,\n        bytes32 value1,\n        bytes32 value2,\n        bytes32 value3,\n        bytes32 value4,\n        bytes32 value5,\n        bytes32 value6\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, value0)\n            mstore(add(m, 0x20), value1)\n            mstore(add(m, 0x40), value2)\n            mstore(add(m, 0x60), value3)\n            mstore(add(m, 0x80), value4)\n            mstore(add(m, 0xa0), value5)\n            mstore(add(m, 0xc0), value6)\n            result := keccak256(m, 0xe0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(value0, .., value6))`.\n    function hash(\n        uint256 value0,\n        uint256 value1,\n        uint256 value2,\n        uint256 value3,\n        uint256 value4,\n        uint256 value5,\n        uint256 value6\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, value0)\n            mstore(add(m, 0x20), value1)\n            mstore(add(m, 0x40), value2)\n            mstore(add(m, 0x60), value3)\n            mstore(add(m, 0x80), value4)\n            mstore(add(m, 0xa0), value5)\n            mstore(add(m, 0xc0), value6)\n            result := keccak256(m, 0xe0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(value0, .., value7))`.\n    function hash(\n        bytes32 value0,\n        bytes32 value1,\n        bytes32 value2,\n        bytes32 value3,\n        bytes32 value4,\n        bytes32 value5,\n        bytes32 value6,\n        bytes32 value7\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, value0)\n            mstore(add(m, 0x20), value1)\n            mstore(add(m, 0x40), value2)\n            mstore(add(m, 0x60), value3)\n            mstore(add(m, 0x80), value4)\n            mstore(add(m, 0xa0), value5)\n            mstore(add(m, 0xc0), value6)\n            mstore(add(m, 0xe0), value7)\n            result := keccak256(m, 0x100)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(value0, .., value7))`.\n    function hash(\n        uint256 value0,\n        uint256 value1,\n        uint256 value2,\n        uint256 value3,\n        uint256 value4,\n        uint256 value5,\n        uint256 value6,\n        uint256 value7\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, value0)\n            mstore(add(m, 0x20), value1)\n            mstore(add(m, 0x40), value2)\n            mstore(add(m, 0x60), value3)\n            mstore(add(m, 0x80), value4)\n            mstore(add(m, 0xa0), value5)\n            mstore(add(m, 0xc0), value6)\n            mstore(add(m, 0xe0), value7)\n            result := keccak256(m, 0x100)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*             BYTES32 BUFFER HASHING OPERATIONS              */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `keccak256(abi.encode(buffer[0], .., value[buffer.length - 1]))`.\n    function hash(bytes32[] memory buffer) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(buffer, 0x20), shl(5, mload(buffer)))\n        }\n    }\n\n    /// @dev Sets `buffer[i]` to `value`, without a bounds check.\n    /// Returns the `buffer` for function chaining.\n    function set(bytes32[] memory buffer, uint256 i, bytes32 value)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(buffer, shl(5, add(1, i))), value)\n        }\n        return buffer;\n    }\n\n    /// @dev Sets `buffer[i]` to `value`, without a bounds check.\n    /// Returns the `buffer` for function chaining.\n    function set(bytes32[] memory buffer, uint256 i, uint256 value)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(buffer, shl(5, add(1, i))), value)\n        }\n        return buffer;\n    }\n\n    /// @dev Returns `new bytes32[](n)`, without zeroing out the memory.\n    function malloc(uint256 n) internal pure returns (bytes32[] memory buffer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            buffer := mload(0x40)\n            mstore(buffer, n)\n            mstore(0x40, add(shl(5, add(1, n)), buffer))\n        }\n    }\n\n    /// @dev Frees memory that has been allocated for `buffer`.\n    /// No-op if `buffer.length` is zero, or if new memory has been allocated after `buffer`.\n    function free(bytes32[] memory buffer) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(buffer)\n            mstore(shl(6, lt(iszero(n), eq(add(shl(5, add(1, n)), buffer), mload(0x40)))), buffer)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*               BYTE SLICE HASHING OPERATIONS                */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the keccak256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function hash(bytes memory b, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            end := xor(end, mul(xor(end, n), lt(n, end)))\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            result := keccak256(add(add(b, 0x20), start), mul(gt(end, start), sub(end, start)))\n        }\n    }\n\n    /// @dev Returns the keccak256 of the slice from `start` to the end of the bytes.\n    function hash(bytes memory b, uint256 start) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            result := keccak256(add(add(b, 0x20), start), mul(gt(n, start), sub(n, start)))\n        }\n    }\n\n    /// @dev Returns the keccak256 of the bytes.\n    function hash(bytes memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(b, 0x20), mload(b))\n        }\n    }\n\n    /// @dev Returns the keccak256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function hashCalldata(bytes calldata b, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, b.length), lt(b.length, end)))\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(end, start), sub(end, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := keccak256(mload(0x40), n)\n        }\n    }\n\n    /// @dev Returns the keccak256 of the slice from `start` to the end of the bytes.\n    function hashCalldata(bytes calldata b, uint256 start) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(b.length, start), sub(b.length, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := keccak256(mload(0x40), n)\n        }\n    }\n\n    /// @dev Returns the keccak256 of the bytes.\n    function hashCalldata(bytes calldata b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            calldatacopy(mload(0x40), b.offset, b.length)\n            result := keccak256(mload(0x40), b.length)\n        }\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IAggregator.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\n/**\n * Aggregated Signatures validator.\n */\ninterface IAggregator {\n    /**\n     * Validate aggregated signature.\n     * Revert if the aggregated signature does not match the given list of operations.\n     * @param userOps   - Array of UserOperations to validate the signature for.\n     * @param signature - The aggregated signature.\n     */\n    function validateSignatures(\n        PackedUserOperation[] calldata userOps,\n        bytes calldata signature\n    ) external view;\n\n    /**\n     * Validate signature of a single userOp.\n     * This method should be called by bundler after EntryPointSimulation.simulateValidation() returns\n     * the aggregator this account uses.\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\n     * @param userOp        - The userOperation received from the user.\n     * @return sigForUserOp - The value to put into the signature field of the userOp when calling handleOps.\n     *                        (usually empty, unless account and aggregator support some kind of \"multisig\".\n     */\n    function validateUserOpSignature(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes memory sigForUserOp);\n\n    /**\n     * Aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation.\n     * @param userOps              - Array of UserOperations to collect the signatures from.\n     * @return aggregatedSignature - The aggregated signature.\n     */\n    function aggregateSignatures(\n        PackedUserOperation[] calldata userOps\n    ) external view returns (bytes memory aggregatedSignature);\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/INonceManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\ninterface INonceManager {\n\n    /**\n     * Return the next nonce for this sender.\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\n     * But UserOp with different keys can come with arbitrary order.\n     *\n     * @param sender the account address\n     * @param key the high 192 bit of the nonce\n     * @return nonce a full nonce to pass for next UserOp with this sender.\n     */\n    function getNonce(address sender, uint192 key)\n    external view returns (uint256 nonce);\n\n    /**\n     * Manually increment the nonce of the sender.\n     * This method is exposed just for completeness..\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\n     * as the EntryPoint will update the nonce regardless.\n     * Possible use-case is call it with various keys to \"initialize\" their nonces to one, so that future\n     * UserOperations will not pay extra for the first transaction with a given key.\n     */\n    function incrementNonce(uint192 key) external;\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/EntryPoint.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IAccountExecute.sol\";\nimport \"../interfaces/IPaymaster.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\n\nimport \"../utils/Exec.sol\";\nimport \"./StakeManager.sol\";\nimport \"./SenderCreator.sol\";\nimport \"./Helpers.sol\";\nimport \"./NonceManager.sol\";\nimport \"./UserOperationLib.sol\";\nimport \"./GasDebug.sol\";\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/*\n * Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n * Only one instance required on each chain.\n */\n\n/// @custom:security-contact https://bounty.ethereum.org\ncontract EntryPoint is IEntryPoint, StakeManager, NonceManager, ReentrancyGuard, ERC165, GasDebug {\n    using UserOperationLib for PackedUserOperation;\n\n    SenderCreator private immutable _senderCreator = new SenderCreator();\n\n    function senderCreator() internal view virtual returns (SenderCreator) {\n        return _senderCreator;\n    }\n\n    //compensate for innerHandleOps' emit message and deposit refund.\n    // allow some slack for future gas price changes.\n    uint256 private constant INNER_GAS_OVERHEAD = 10000;\n\n    // Marker for inner call revert on out of gas\n    bytes32 private constant INNER_OUT_OF_GAS = hex\"deaddead\";\n    bytes32 private constant INNER_REVERT_LOW_PREFUND = hex\"deadaa51\";\n\n    uint256 private constant REVERT_REASON_MAX_LEN = 2048;\n    uint256 private constant PENALTY_PERCENT = 10;\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        // note: solidity \"type(IEntryPoint).interfaceId\" is without inherited methods but we want to check everything\n        return interfaceId\n            == (type(IEntryPoint).interfaceId ^ type(IStakeManager).interfaceId ^ type(INonceManager).interfaceId)\n            || interfaceId == type(IEntryPoint).interfaceId || interfaceId == type(IStakeManager).interfaceId\n            || interfaceId == type(INonceManager).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * Compensate the caller's beneficiary address with the collected fees of all UserOperations.\n     * @param beneficiary - The address to receive the fees.\n     * @param amount      - Amount to transfer.\n     */\n    function _compensate(address payable beneficiary, uint256 amount) internal {\n        require(beneficiary != address(0), \"AA90 invalid beneficiary\");\n        (bool success,) = beneficiary.call{value: amount}(\"\");\n        require(success, \"AA91 failed send to beneficiary\");\n    }\n\n    /**\n     * Execute a user operation.\n     * @param opIndex    - Index into the opInfo array.\n     * @param userOp     - The userOp to execute.\n     * @param opInfo     - The opInfo filled by validatePrepayment for this userOp.\n     * @return collected - The total amount this userOp paid.\n     */\n    function _executeUserOp(uint256 opIndex, PackedUserOperation calldata userOp, UserOpInfo memory opInfo)\n        internal\n        returns (uint256 collected)\n    {\n        uint256 preGas = gasleft();\n        bytes memory context = getMemoryBytesFromOffset(opInfo.contextOffset);\n        bool success;\n        {\n            uint256 saveFreePtr;\n            assembly (\"memory-safe\") {\n                saveFreePtr := mload(0x40)\n            }\n            bytes calldata callData = userOp.callData;\n            bytes memory innerCall;\n            bytes4 methodSig;\n            assembly {\n                let len := callData.length\n                if gt(len, 3) { methodSig := calldataload(callData.offset) }\n            }\n            if (methodSig == IAccountExecute.executeUserOp.selector) {\n                bytes memory executeUserOp = abi.encodeCall(IAccountExecute.executeUserOp, (userOp, opInfo.userOpHash));\n                innerCall = abi.encodeCall(this.innerHandleOp, (executeUserOp, opInfo, context));\n            } else {\n                innerCall = abi.encodeCall(this.innerHandleOp, (callData, opInfo, context));\n            }\n            assembly (\"memory-safe\") {\n                success := call(gas(), address(), 0, add(innerCall, 0x20), mload(innerCall), 0, 32)\n                collected := mload(0)\n                mstore(0x40, saveFreePtr)\n            }\n        }\n        if (!success) {\n            bytes32 innerRevertCode;\n            assembly (\"memory-safe\") {\n                let len := returndatasize()\n                if eq(32, len) {\n                    returndatacopy(0, 0, 32)\n                    innerRevertCode := mload(0)\n                }\n            }\n            if (innerRevertCode == INNER_OUT_OF_GAS) {\n                // handleOps was called with gas limit too low. abort entire bundle.\n                //can only be caused by bundler (leaving not enough gas for inner call)\n                revert FailedOp(opIndex, \"AA95 out of gas\");\n            } else if (innerRevertCode == INNER_REVERT_LOW_PREFUND) {\n                // innerCall reverted on prefund too low. treat entire prefund as \"gas cost\"\n                uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n                uint256 actualGasCost = opInfo.prefund;\n                emitPrefundTooLow(opInfo);\n                emitUserOperationEvent(opInfo, false, actualGasCost, actualGas);\n                collected = actualGasCost;\n            } else {\n                emit PostOpRevertReason(\n                    opInfo.userOpHash,\n                    opInfo.mUserOp.sender,\n                    opInfo.mUserOp.nonce,\n                    Exec.getReturnData(REVERT_REASON_MAX_LEN)\n                );\n\n                uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n                collected = _postExecution(IPaymaster.PostOpMode.postOpReverted, opInfo, context, actualGas);\n            }\n        }\n    }\n\n    function emitUserOperationEvent(UserOpInfo memory opInfo, bool success, uint256 actualGasCost, uint256 actualGas)\n        internal\n        virtual\n    {\n        emit UserOperationEvent(\n            opInfo.userOpHash,\n            opInfo.mUserOp.sender,\n            opInfo.mUserOp.paymaster,\n            opInfo.mUserOp.nonce,\n            success,\n            actualGasCost,\n            actualGas\n        );\n    }\n\n    function emitPrefundTooLow(UserOpInfo memory opInfo) internal virtual {\n        emit UserOperationPrefundTooLow(opInfo.userOpHash, opInfo.mUserOp.sender, opInfo.mUserOp.nonce);\n    }\n\n    /// @inheritdoc IEntryPoint\n    function handleOps(PackedUserOperation[] calldata ops, address payable beneficiary) public nonReentrant {\n        uint256 opslen = ops.length;\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\n\n        unchecked {\n            for (uint256 i = 0; i < opslen; i++) {\n                UserOpInfo memory opInfo = opInfos[i];\n                (uint256 validationData, uint256 pmValidationData) = _validatePrepayment(i, ops[i], opInfo);\n                _validateAccountAndPaymasterValidationData(i, validationData, pmValidationData, address(0));\n            }\n\n            uint256 collected = 0;\n            emit BeforeExecution();\n\n            for (uint256 i = 0; i < opslen; i++) {\n                collected += _executeUserOp(i, ops[i], opInfos[i]);\n            }\n\n            _compensate(beneficiary, collected);\n        }\n    }\n\n    /// @inheritdoc IEntryPoint\n    function handleAggregatedOps(UserOpsPerAggregator[] calldata opsPerAggregator, address payable beneficiary)\n        public\n        nonReentrant\n    {\n        uint256 opasLen = opsPerAggregator.length;\n        uint256 totalOps = 0;\n        for (uint256 i = 0; i < opasLen; i++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[i];\n            PackedUserOperation[] calldata ops = opa.userOps;\n            IAggregator aggregator = opa.aggregator;\n\n            //address(1) is special marker of \"signature error\"\n            require(address(aggregator) != address(1), \"AA96 invalid aggregator\");\n\n            if (address(aggregator) != address(0)) {\n                // solhint-disable-next-line no-empty-blocks\n                try aggregator.validateSignatures(ops, opa.signature) {}\n                catch {\n                    revert SignatureValidationFailed(address(aggregator));\n                }\n            }\n\n            totalOps += ops.length;\n        }\n\n        UserOpInfo[] memory opInfos = new UserOpInfo[](totalOps);\n\n        uint256 opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            PackedUserOperation[] calldata ops = opa.userOps;\n            IAggregator aggregator = opa.aggregator;\n\n            uint256 opslen = ops.length;\n            for (uint256 i = 0; i < opslen; i++) {\n                UserOpInfo memory opInfo = opInfos[opIndex];\n                (uint256 validationData, uint256 paymasterValidationData) = _validatePrepayment(opIndex, ops[i], opInfo);\n                _validateAccountAndPaymasterValidationData(\n                    i, validationData, paymasterValidationData, address(aggregator)\n                );\n                opIndex++;\n            }\n        }\n\n        emit BeforeExecution();\n\n        uint256 collected = 0;\n        opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            emit SignatureAggregatorChanged(address(opa.aggregator));\n            PackedUserOperation[] calldata ops = opa.userOps;\n            uint256 opslen = ops.length;\n\n            for (uint256 i = 0; i < opslen; i++) {\n                collected += _executeUserOp(opIndex, ops[i], opInfos[opIndex]);\n                opIndex++;\n            }\n        }\n        emit SignatureAggregatorChanged(address(0));\n\n        _compensate(beneficiary, collected);\n    }\n\n    /**\n     * A memory copy of UserOp static fields only.\n     * Excluding: callData, initCode and signature. Replacing paymasterAndData with paymaster.\n     */\n    struct MemoryUserOp {\n        address sender;\n        uint256 nonce;\n        uint256 verificationGasLimit;\n        uint256 callGasLimit;\n        uint256 paymasterVerificationGasLimit;\n        uint256 paymasterPostOpGasLimit;\n        uint256 preVerificationGas;\n        address paymaster;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n    }\n\n    struct UserOpInfo {\n        MemoryUserOp mUserOp;\n        bytes32 userOpHash;\n        uint256 prefund;\n        uint256 contextOffset;\n        uint256 preOpGas;\n    }\n\n    /**\n     * Inner function to handle a UserOperation.\n     * Must be declared \"external\" to open a call context, but it can only be called by handleOps.\n     * @param callData - The callData to execute.\n     * @param opInfo   - The UserOpInfo struct.\n     * @param context  - The context bytes.\n     * @return actualGasCost - the actual cost in eth this UserOperation paid for gas\n     */\n    function innerHandleOp(bytes memory callData, UserOpInfo memory opInfo, bytes calldata context)\n        external\n        returns (uint256 actualGasCost)\n    {\n        uint256 preGas = gasleft();\n        require(msg.sender == address(this), \"AA92 internal call only\");\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n\n        uint256 callGasLimit = mUserOp.callGasLimit;\n        unchecked {\n            // handleOps was called with gas limit too low. abort entire bundle.\n            if (gasleft() * 63 / 64 < callGasLimit + mUserOp.paymasterPostOpGasLimit + INNER_GAS_OVERHEAD) {\n                assembly (\"memory-safe\") {\n                    mstore(0, INNER_OUT_OF_GAS)\n                    revert(0, 32)\n                }\n            }\n        }\n\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\n        if (callData.length > 0) {\n            uint256 _execGas = gasleft();\n            bool success = Exec.call(mUserOp.sender, 0, callData, callGasLimit);\n            setGasConsumed(mUserOp.sender, 2, _execGas - gasleft());\n            if (!success) {\n                bytes memory result = Exec.getReturnData(REVERT_REASON_MAX_LEN);\n                if (result.length > 0) {\n                    emit UserOperationRevertReason(opInfo.userOpHash, mUserOp.sender, mUserOp.nonce, result);\n                }\n                mode = IPaymaster.PostOpMode.opReverted;\n            }\n        }\n\n        unchecked {\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n            return _postExecution(mode, opInfo, context, actualGas);\n        }\n    }\n\n    /// @inheritdoc IEntryPoint\n    function getUserOpHash(PackedUserOperation calldata userOp) public view returns (bytes32) {\n        return keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\n    }\n\n    /**\n     * Copy general fields from userOp into the memory opInfo structure.\n     * @param userOp  - The user operation.\n     * @param mUserOp - The memory user operation.\n     */\n    function _copyUserOpToMemory(PackedUserOperation calldata userOp, MemoryUserOp memory mUserOp) internal pure {\n        mUserOp.sender = userOp.sender;\n        mUserOp.nonce = userOp.nonce;\n        (mUserOp.verificationGasLimit, mUserOp.callGasLimit) = UserOperationLib.unpackUints(userOp.accountGasLimits);\n        mUserOp.preVerificationGas = userOp.preVerificationGas;\n        (mUserOp.maxPriorityFeePerGas, mUserOp.maxFeePerGas) = UserOperationLib.unpackUints(userOp.gasFees);\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\n        if (paymasterAndData.length > 0) {\n            require(paymasterAndData.length >= UserOperationLib.PAYMASTER_DATA_OFFSET, \"AA93 invalid paymasterAndData\");\n            (mUserOp.paymaster, mUserOp.paymasterVerificationGasLimit, mUserOp.paymasterPostOpGasLimit) =\n                UserOperationLib.unpackPaymasterStaticFields(paymasterAndData);\n        } else {\n            mUserOp.paymaster = address(0);\n            mUserOp.paymasterVerificationGasLimit = 0;\n            mUserOp.paymasterPostOpGasLimit = 0;\n        }\n    }\n\n    /**\n     * Get the required prefunded gas fee amount for an operation.\n     * @param mUserOp - The user operation in memory.\n     */\n    function _getRequiredPrefund(MemoryUserOp memory mUserOp) internal pure returns (uint256 requiredPrefund) {\n        unchecked {\n            uint256 requiredGas = mUserOp.verificationGasLimit + mUserOp.callGasLimit\n                + mUserOp.paymasterVerificationGasLimit + mUserOp.paymasterPostOpGasLimit + mUserOp.preVerificationGas;\n\n            requiredPrefund = requiredGas * mUserOp.maxFeePerGas;\n        }\n    }\n\n    /**\n     * Create sender smart contract account if init code is provided.\n     * @param opIndex  - The operation index.\n     * @param opInfo   - The operation info.\n     * @param initCode - The init code for the smart contract account.\n     */\n    function _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal {\n        if (initCode.length != 0) {\n            address sender = opInfo.mUserOp.sender;\n            if (sender.code.length != 0) {\n                revert FailedOp(opIndex, \"AA10 sender already constructed\");\n            }\n            uint256 _creationGas = gasleft();\n            address sender1 = senderCreator().createSender{gas: opInfo.mUserOp.verificationGasLimit}(initCode);\n            setGasConsumed(sender, 0, _creationGas - gasleft());\n            if (sender1 == address(0)) {\n                revert FailedOp(opIndex, \"AA13 initCode failed or OOG\");\n            }\n            if (sender1 != sender) {\n                revert FailedOp(opIndex, \"AA14 initCode must return sender\");\n            }\n            if (sender1.code.length == 0) {\n                revert FailedOp(opIndex, \"AA15 initCode must create sender\");\n            }\n            address factory = address(bytes20(initCode[0:20]));\n            emit AccountDeployed(opInfo.userOpHash, sender, factory, opInfo.mUserOp.paymaster);\n        }\n    }\n\n    /// @inheritdoc IEntryPoint\n    function getSenderAddress(bytes calldata initCode) public {\n        address sender = senderCreator().createSender(initCode);\n        revert SenderAddressResult(sender);\n    }\n\n    /**\n     * Call account.validateUserOp.\n     * Revert (with FailedOp) in case validateUserOp reverts, or account didn't send required prefund.\n     * Decrement account's deposit if needed.\n     * @param opIndex         - The operation index.\n     * @param op              - The user operation.\n     * @param opInfo          - The operation info.\n     * @param requiredPrefund - The required prefund amount.\n     */\n    function _validateAccountPrepayment(\n        uint256 opIndex,\n        PackedUserOperation calldata op,\n        UserOpInfo memory opInfo,\n        uint256 requiredPrefund,\n        uint256 verificationGasLimit\n    ) internal returns (uint256 validationData) {\n        unchecked {\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\n            address sender = mUserOp.sender;\n            _createSenderIfNeeded(opIndex, opInfo, op.initCode);\n            address paymaster = mUserOp.paymaster;\n            uint256 missingAccountFunds = 0;\n            if (paymaster == address(0)) {\n                uint256 bal = balanceOf(sender);\n                missingAccountFunds = bal > requiredPrefund ? 0 : requiredPrefund - bal;\n            }\n            uint256 _verificationGas = gasleft();\n            try IAccount(sender).validateUserOp{gas: verificationGasLimit}(op, opInfo.userOpHash, missingAccountFunds)\n            returns (uint256 _validationData) {\n                validationData = _validationData;\n                setGasConsumed(sender, 1, _verificationGas - gasleft());\n            } catch {\n                revert FailedOpWithRevert(opIndex, \"AA23 reverted\", Exec.getReturnData(REVERT_REASON_MAX_LEN));\n            }\n            if (paymaster == address(0)) {\n                DepositInfo storage senderInfo = deposits[sender];\n                uint256 deposit = senderInfo.deposit;\n                if (requiredPrefund > deposit) {\n                    revert FailedOp(opIndex, \"AA21 didn't pay prefund\");\n                }\n                senderInfo.deposit = deposit - requiredPrefund;\n            }\n        }\n    }\n\n    /**\n     * In case the request has a paymaster:\n     *  - Validate paymaster has enough deposit.\n     *  - Call paymaster.validatePaymasterUserOp.\n     *  - Revert with proper FailedOp in case paymaster reverts.\n     *  - Decrement paymaster's deposit.\n     * @param opIndex                            - The operation index.\n     * @param op                                 - The user operation.\n     * @param opInfo                             - The operation info.\n     * @param requiredPreFund                    - The required prefund amount.\n     */\n    function _validatePaymasterPrepayment(\n        uint256 opIndex,\n        PackedUserOperation calldata op,\n        UserOpInfo memory opInfo,\n        uint256 requiredPreFund\n    ) internal returns (bytes memory context, uint256 validationData) {\n        unchecked {\n            uint256 preGas = gasleft();\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\n            address paymaster = mUserOp.paymaster;\n            DepositInfo storage paymasterInfo = deposits[paymaster];\n            uint256 deposit = paymasterInfo.deposit;\n            if (deposit < requiredPreFund) {\n                revert FailedOp(opIndex, \"AA31 paymaster deposit too low\");\n            }\n            paymasterInfo.deposit = deposit - requiredPreFund;\n            uint256 pmVerificationGasLimit = mUserOp.paymasterVerificationGasLimit;\n            try IPaymaster(paymaster).validatePaymasterUserOp{gas: pmVerificationGasLimit}(\n                op, opInfo.userOpHash, requiredPreFund\n            ) returns (bytes memory _context, uint256 _validationData) {\n                context = _context;\n                validationData = _validationData;\n            } catch {\n                revert FailedOpWithRevert(opIndex, \"AA33 reverted\", Exec.getReturnData(REVERT_REASON_MAX_LEN));\n            }\n            if (preGas - gasleft() > pmVerificationGasLimit) {\n                revert FailedOp(opIndex, \"AA36 over paymasterVerificationGasLimit\");\n            }\n        }\n    }\n\n    /**\n     * Revert if either account validationData or paymaster validationData is expired.\n     * @param opIndex                 - The operation index.\n     * @param validationData          - The account validationData.\n     * @param paymasterValidationData - The paymaster validationData.\n     * @param expectedAggregator      - The expected aggregator.\n     */\n    function _validateAccountAndPaymasterValidationData(\n        uint256 opIndex,\n        uint256 validationData,\n        uint256 paymasterValidationData,\n        address expectedAggregator\n    ) internal view {\n        (address aggregator, bool outOfTimeRange) = _getValidationData(validationData);\n        if (expectedAggregator != aggregator) {\n            revert FailedOp(opIndex, \"AA24 signature error\");\n        }\n        if (outOfTimeRange) {\n            revert FailedOp(opIndex, \"AA22 expired or not due\");\n        }\n        // pmAggregator is not a real signature aggregator: we don't have logic to handle it as address.\n        // Non-zero address means that the paymaster fails due to some signature check (which is ok only during estimation).\n        address pmAggregator;\n        (pmAggregator, outOfTimeRange) = _getValidationData(paymasterValidationData);\n        if (pmAggregator != address(0)) {\n            revert FailedOp(opIndex, \"AA34 signature error\");\n        }\n        if (outOfTimeRange) {\n            revert FailedOp(opIndex, \"AA32 paymaster expired or not due\");\n        }\n    }\n\n    /**\n     * Parse validationData into its components.\n     * @param validationData - The packed validation data (sigFailed, validAfter, validUntil).\n     * @return aggregator the aggregator of the validationData\n     * @return outOfTimeRange true if current time is outside the time range of this validationData.\n     */\n    function _getValidationData(uint256 validationData)\n        internal\n        view\n        returns (address aggregator, bool outOfTimeRange)\n    {\n        if (validationData == 0) {\n            return (address(0), false);\n        }\n        ValidationData memory data = _parseValidationData(validationData);\n        // solhint-disable-next-line not-rely-on-time\n        outOfTimeRange = block.timestamp > data.validUntil || block.timestamp < data.validAfter;\n        aggregator = data.aggregator;\n    }\n\n    /**\n     * Validate account and paymaster (if defined) and\n     * also make sure total validation doesn't exceed verificationGasLimit.\n     * This method is called off-chain (simulateValidation()) and on-chain (from handleOps)\n     * @param opIndex - The index of this userOp into the \"opInfos\" array.\n     * @param userOp  - The userOp to validate.\n     */\n    function _validatePrepayment(uint256 opIndex, PackedUserOperation calldata userOp, UserOpInfo memory outOpInfo)\n        internal\n        returns (uint256 validationData, uint256 paymasterValidationData)\n    {\n        uint256 preGas = gasleft();\n        MemoryUserOp memory mUserOp = outOpInfo.mUserOp;\n        _copyUserOpToMemory(userOp, mUserOp);\n        outOpInfo.userOpHash = getUserOpHash(userOp);\n\n        // Validate all numeric values in userOp are well below 128 bit, so they can safely be added\n        // and multiplied without causing overflow.\n        uint256 verificationGasLimit = mUserOp.verificationGasLimit;\n        uint256 maxGasValues = mUserOp.preVerificationGas | verificationGasLimit | mUserOp.callGasLimit\n            | mUserOp.paymasterVerificationGasLimit | mUserOp.paymasterPostOpGasLimit | mUserOp.maxFeePerGas\n            | mUserOp.maxPriorityFeePerGas;\n        require(maxGasValues <= type(uint120).max, \"AA94 gas values overflow\");\n\n        uint256 requiredPreFund = _getRequiredPrefund(mUserOp);\n        validationData = _validateAccountPrepayment(opIndex, userOp, outOpInfo, requiredPreFund, verificationGasLimit);\n\n        if (!_validateAndUpdateNonce(mUserOp.sender, mUserOp.nonce)) {\n            revert FailedOp(opIndex, \"AA25 invalid account nonce\");\n        }\n\n        unchecked {\n            if (preGas - gasleft() > verificationGasLimit) {\n                revert FailedOp(opIndex, \"AA26 over verificationGasLimit\");\n            }\n        }\n\n        bytes memory context;\n        if (mUserOp.paymaster != address(0)) {\n            (context, paymasterValidationData) =\n                _validatePaymasterPrepayment(opIndex, userOp, outOpInfo, requiredPreFund);\n        }\n        unchecked {\n            outOpInfo.prefund = requiredPreFund;\n            outOpInfo.contextOffset = getOffsetOfMemoryBytes(context);\n            outOpInfo.preOpGas = preGas - gasleft() + userOp.preVerificationGas;\n        }\n    }\n\n    /**\n     * Process post-operation, called just after the callData is executed.\n     * If a paymaster is defined and its validation returned a non-empty context, its postOp is called.\n     * The excess amount is refunded to the account (or paymaster - if it was used in the request).\n     * @param mode      - Whether is called from innerHandleOp, or outside (postOpReverted).\n     * @param opInfo    - UserOp fields and info collected during validation.\n     * @param context   - The context returned in validatePaymasterUserOp.\n     * @param actualGas - The gas used so far by this user operation.\n     */\n    function _postExecution(\n        IPaymaster.PostOpMode mode,\n        UserOpInfo memory opInfo,\n        bytes memory context,\n        uint256 actualGas\n    ) private returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n        unchecked {\n            address refundAddress;\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\n            uint256 gasPrice = getUserOpGasPrice(mUserOp);\n\n            address paymaster = mUserOp.paymaster;\n            if (paymaster == address(0)) {\n                refundAddress = mUserOp.sender;\n            } else {\n                refundAddress = paymaster;\n                if (context.length > 0) {\n                    actualGasCost = actualGas * gasPrice;\n                    if (mode != IPaymaster.PostOpMode.postOpReverted) {\n                        try IPaymaster(paymaster).postOp{gas: mUserOp.paymasterPostOpGasLimit}(\n                            mode, context, actualGasCost, gasPrice\n                        ) {\n                            // solhint-disable-next-line no-empty-blocks\n                        } catch {\n                            bytes memory reason = Exec.getReturnData(REVERT_REASON_MAX_LEN);\n                            revert PostOpReverted(reason);\n                        }\n                    }\n                }\n            }\n            actualGas += preGas - gasleft();\n\n            // Calculating a penalty for unused execution gas\n            {\n                uint256 executionGasLimit = mUserOp.callGasLimit + mUserOp.paymasterPostOpGasLimit;\n                uint256 executionGasUsed = actualGas - opInfo.preOpGas;\n                // this check is required for the gas used within EntryPoint and not covered by explicit gas limits\n                if (executionGasLimit > executionGasUsed) {\n                    uint256 unusedGas = executionGasLimit - executionGasUsed;\n                    uint256 unusedGasPenalty = (unusedGas * PENALTY_PERCENT) / 100;\n                    actualGas += unusedGasPenalty;\n                }\n            }\n\n            actualGasCost = actualGas * gasPrice;\n            uint256 prefund = opInfo.prefund;\n            if (prefund < actualGasCost) {\n                if (mode == IPaymaster.PostOpMode.postOpReverted) {\n                    actualGasCost = prefund;\n                    emitPrefundTooLow(opInfo);\n                    emitUserOperationEvent(opInfo, false, actualGasCost, actualGas);\n                } else {\n                    assembly (\"memory-safe\") {\n                        mstore(0, INNER_REVERT_LOW_PREFUND)\n                        revert(0, 32)\n                    }\n                }\n            } else {\n                uint256 refund = prefund - actualGasCost;\n                _incrementDeposit(refundAddress, refund);\n                bool success = mode == IPaymaster.PostOpMode.opSucceeded;\n                emitUserOperationEvent(opInfo, success, actualGasCost, actualGas);\n            }\n        } // unchecked\n    }\n\n    /**\n     * The gas price this UserOp agrees to pay.\n     * Relayer/block builder might submit the TX with higher priorityFee, but the user should not.\n     * @param mUserOp - The userOp to get the gas price from.\n     */\n    function getUserOpGasPrice(MemoryUserOp memory mUserOp) internal view returns (uint256) {\n        unchecked {\n            uint256 maxFeePerGas = mUserOp.maxFeePerGas;\n            uint256 maxPriorityFeePerGas = mUserOp.maxPriorityFeePerGas;\n            if (maxFeePerGas == maxPriorityFeePerGas) {\n                //legacy mode (for networks that don't support basefee opcode)\n                return maxFeePerGas;\n            }\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n        }\n    }\n\n    /**\n     * The offset of the given bytes in memory.\n     * @param data - The bytes to get the offset of.\n     */\n    function getOffsetOfMemoryBytes(bytes memory data) internal pure returns (uint256 offset) {\n        assembly {\n            offset := data\n        }\n    }\n\n    /**\n     * The bytes in memory at the given offset.\n     * @param offset - The offset to get the bytes from.\n     */\n    function getMemoryBytesFromOffset(uint256 offset) internal pure returns (bytes memory data) {\n        assembly (\"memory-safe\") {\n            data := offset\n        }\n    }\n\n    /// @inheritdoc IEntryPoint\n    function delegateAndRevert(address target, bytes calldata data) external {\n        (bool success, bytes memory ret) = target.delegatecall(data);\n        revert DelegateAndRevert(success, ret);\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"node_modules/@openzeppelin/contracts/utils/Strings.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/interfaces/IPaymaster.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\n/**\n * The interface exposed by a paymaster contract, who agrees to pay the gas for user's operations.\n * A paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\n */\ninterface IPaymaster {\n    enum PostOpMode {\n        // User op succeeded.\n        opSucceeded,\n        // User op reverted. Still has to pay for gas.\n        opReverted,\n        // Only used internally in the EntryPoint (cleanup after postOp reverts). Never calling paymaster with this value\n        postOpReverted\n    }\n\n    /**\n     * Payment validation: check if paymaster agrees to pay.\n     * Must verify sender is the entryPoint.\n     * Revert to reject this request.\n     * Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted).\n     * The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\n     * @param userOp          - The user operation.\n     * @param userOpHash      - Hash of the user's request data.\n     * @param maxCost         - The maximum cost of this transaction (based on maximum gas and gas price from userOp).\n     * @return context        - Value to send to a postOp. Zero length to signify postOp is not required.\n     * @return validationData - Signature and time-range of this operation, encoded the same as the return\n     *                          value of validateUserOperation.\n     *                          <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *                                                    other values are invalid for paymaster.\n     *                          <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *                          <6-byte> validAfter - first timestamp this operation is valid\n     *                          Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validatePaymasterUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) external returns (bytes memory context, uint256 validationData);\n\n    /**\n     * Post-operation handler.\n     * Must verify sender is the entryPoint.\n     * @param mode          - Enum with the following options:\n     *                        opSucceeded - User operation succeeded.\n     *                        opReverted  - User op reverted. The paymaster still has to pay for gas.\n     *                        postOpReverted - never passed in a call to postOp().\n     * @param context       - The context value returned by validatePaymasterUserOp\n     * @param actualGasCost - Actual gas used so far (without this postOp call).\n     * @param actualUserOpFeePerGas - the gas price this UserOp pays. This value is based on the UserOp's maxFeePerGas\n     *                        and maxPriorityFee (and basefee)\n     *                        It is not the same as tx.gasprice, which is what the bundler pays.\n     */\n    function postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost,\n        uint256 actualUserOpFeePerGas\n    ) external;\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/utils/Exec.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.23;\n\n// solhint-disable no-inline-assembly\n\n/**\n * Utility functions helpful when making different kinds of contract calls in Solidity.\n */\nlibrary Exec {\n\n    function call(\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint256 txGas\n    ) internal returns (bool success) {\n        assembly (\"memory-safe\") {\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    function staticcall(\n        address to,\n        bytes memory data,\n        uint256 txGas\n    ) internal view returns (bool success) {\n        assembly (\"memory-safe\") {\n            success := staticcall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    function delegateCall(\n        address to,\n        bytes memory data,\n        uint256 txGas\n    ) internal returns (bool success) {\n        assembly (\"memory-safe\") {\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    // get returned data from last call or calldelegate\n    function getReturnData(uint256 maxLen) internal pure returns (bytes memory returnData) {\n        assembly (\"memory-safe\") {\n            let len := returndatasize()\n            if gt(len, maxLen) {\n                len := maxLen\n            }\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, add(len, 0x20)))\n            mstore(ptr, len)\n            returndatacopy(add(ptr, 0x20), 0, len)\n            returnData := ptr\n        }\n    }\n\n    // revert with explicit byte array (probably reverted info from call)\n    function revertWithData(bytes memory returnData) internal pure {\n        assembly (\"memory-safe\") {\n            revert(add(returnData, 32), mload(returnData))\n        }\n    }\n\n    function callAndRevert(address to, bytes memory data, uint256 maxLen) internal {\n        bool success = call(to,0,data,gasleft());\n        if (!success) {\n            revertWithData(getReturnData(maxLen));\n        }\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/StakeManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.23;\n\nimport \"../interfaces/IStakeManager.sol\";\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable not-rely-on-time */\n\n/**\n * Manage deposits and stakes.\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\n * Stake is value locked for at least \"unstakeDelay\" by a paymaster.\n */\nabstract contract StakeManager is IStakeManager {\n    /// maps paymaster to their deposits and stakes\n    mapping(address => DepositInfo) public deposits;\n\n    /// @inheritdoc IStakeManager\n    function getDepositInfo(\n        address account\n    ) public view returns (DepositInfo memory info) {\n        return deposits[account];\n    }\n\n    /**\n     * Internal method to return just the stake info.\n     * @param addr - The account to query.\n     */\n    function _getStakeInfo(\n        address addr\n    ) internal view returns (StakeInfo memory info) {\n        DepositInfo storage depositInfo = deposits[addr];\n        info.stake = depositInfo.stake;\n        info.unstakeDelaySec = depositInfo.unstakeDelaySec;\n    }\n\n    /// @inheritdoc IStakeManager\n    function balanceOf(address account) public view returns (uint256) {\n        return deposits[account].deposit;\n    }\n\n    receive() external payable {\n        depositTo(msg.sender);\n    }\n\n    /**\n     * Increments an account's deposit.\n     * @param account - The account to increment.\n     * @param amount  - The amount to increment by.\n     * @return the updated deposit of this account\n     */\n    function _incrementDeposit(address account, uint256 amount) internal returns (uint256) {\n        DepositInfo storage info = deposits[account];\n        uint256 newAmount = info.deposit + amount;\n        info.deposit = newAmount;\n        return newAmount;\n    }\n\n    /**\n     * Add to the deposit of the given account.\n     * @param account - The account to add to.\n     */\n    function depositTo(address account) public virtual payable {\n        uint256 newDeposit = _incrementDeposit(account, msg.value);\n        emit Deposited(account, newDeposit);\n    }\n\n    /**\n     * Add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param unstakeDelaySec The new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 unstakeDelaySec) public payable {\n        DepositInfo storage info = deposits[msg.sender];\n        require(unstakeDelaySec > 0, \"must specify unstake delay\");\n        require(\n            unstakeDelaySec >= info.unstakeDelaySec,\n            \"cannot decrease unstake time\"\n        );\n        uint256 stake = info.stake + msg.value;\n        require(stake > 0, \"no stake specified\");\n        require(stake <= type(uint112).max, \"stake overflow\");\n        deposits[msg.sender] = DepositInfo(\n            info.deposit,\n            true,\n            uint112(stake),\n            unstakeDelaySec,\n            0\n        );\n        emit StakeLocked(msg.sender, stake, unstakeDelaySec);\n    }\n\n    /**\n     * Attempt to unlock the stake.\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(info.unstakeDelaySec != 0, \"not staked\");\n        require(info.staked, \"already unstaking\");\n        uint48 withdrawTime = uint48(block.timestamp) + info.unstakeDelaySec;\n        info.withdrawTime = withdrawTime;\n        info.staked = false;\n        emit StakeUnlocked(msg.sender, withdrawTime);\n    }\n\n    /**\n     * Withdraw from the (unlocked) stake.\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external {\n        DepositInfo storage info = deposits[msg.sender];\n        uint256 stake = info.stake;\n        require(stake > 0, \"No stake to withdraw\");\n        require(info.withdrawTime > 0, \"must call unlockStake() first\");\n        require(\n            info.withdrawTime <= block.timestamp,\n            \"Stake withdrawal is not due\"\n        );\n        info.unstakeDelaySec = 0;\n        info.withdrawTime = 0;\n        info.stake = 0;\n        emit StakeWithdrawn(msg.sender, withdrawAddress, stake);\n        (bool success,) = withdrawAddress.call{value: stake}(\"\");\n        require(success, \"failed to withdraw stake\");\n    }\n\n    /**\n     * Withdraw from the deposit.\n     * @param withdrawAddress - The address to send withdrawn value.\n     * @param withdrawAmount  - The amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 withdrawAmount\n    ) external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(withdrawAmount <= info.deposit, \"Withdraw amount too large\");\n        info.deposit = info.deposit - withdrawAmount;\n        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\n        (bool success,) = withdrawAddress.call{value: withdrawAmount}(\"\");\n        require(success, \"failed to withdraw\");\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/SenderCreator.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/**\n * Helper contract for EntryPoint, to call userOp.initCode from a \"neutral\" address,\n * which is explicitly not the entryPoint itself.\n */\ncontract SenderCreator {\n    /**\n     * Call the \"initCode\" factory to create and return the sender account address.\n     * @param initCode - The initCode value from a UserOp. contains 20 bytes of factory address,\n     *                   followed by calldata.\n     * @return sender  - The returned address of the created account, or zero address on failure.\n     */\n    function createSender(\n        bytes calldata initCode\n    ) external returns (address sender) {\n        address factory = address(bytes20(initCode[0:20]));\n        bytes memory initCallData = initCode[20:];\n        bool success;\n        /* solhint-disable no-inline-assembly */\n        assembly (\"memory-safe\") {\n            success := call(\n                gas(),\n                factory,\n                0,\n                add(initCallData, 0x20),\n                mload(initCallData),\n                0,\n                32\n            )\n            sender := mload(0)\n        }\n        if (!success) {\n            sender = address(0);\n        }\n    }\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/NonceManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\nimport \"../interfaces/INonceManager.sol\";\n\n/**\n * nonce management functionality\n */\nabstract contract NonceManager is INonceManager {\n\n    /**\n     * The next valid sequence number for a given nonce key.\n     */\n    mapping(address => mapping(uint192 => uint256)) public nonceSequenceNumber;\n\n    /// @inheritdoc INonceManager\n    function getNonce(address sender, uint192 key)\n    public view override returns (uint256 nonce) {\n        return nonceSequenceNumber[sender][key] | (uint256(key) << 64);\n    }\n\n    // allow an account to manually increment its own nonce.\n    // (mainly so that during construction nonce can be made non-zero,\n    // to \"absorb\" the gas cost of first nonce increment to 1st transaction (construction),\n    // not to 2nd transaction)\n    function incrementNonce(uint192 key) public override {\n        nonceSequenceNumber[msg.sender][key]++;\n    }\n\n    /**\n     * validate nonce uniqueness for this account.\n     * called just after validateUserOp()\n     * @return true if the nonce was incremented successfully.\n     *         false if the current nonce doesn't match the given one.\n     */\n    function _validateAndUpdateNonce(address sender, uint256 nonce) internal returns (bool) {\n\n        uint192 key = uint192(nonce >> 64);\n        uint64 seq = uint64(nonce);\n        return nonceSequenceNumber[sender][key]++ == seq;\n    }\n\n}\n"},"node_modules/@ERC4337/account-abstraction/contracts/core/GasDebug.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\ncontract GasDebug {\n    // Phase 0: account creation\n    // Phase 1: validation\n    // Phase 2: execution\n    mapping(address account => mapping(uint256 phase => uint256 gas)) gasConsumed;\n\n    function setGasConsumed(address account, uint256 phase, uint256 gas) internal {\n        gasConsumed[account][phase] = gas;\n    }\n\n    function getGasConsumed(address account, uint256 phase) public view returns (uint256) {\n        return gasConsumed[account][phase];\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/math/Math.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"}},"settings":{"remappings":["@rhinestone/=node_modules/@rhinestone/","sentinellist/=node_modules/@rhinestone/sentinellist/src/","erc4337-validation/=node_modules/@rhinestone/erc4337-validation/src/","safe7579/=node_modules/@rhinestone/safe7579/src/","modulekit/=node_modules/@rhinestone/modulekit/src/","module-bases/=node_modules/@rhinestone/module-bases/src/","solmate/=node_modules/solmate/src/","@ERC4337/=node_modules/@ERC4337/","account-abstraction/=node_modules/@ERC4337/account-abstraction/contracts/","account-abstraction-v0.6/=node_modules/@ERC4337/account-abstraction-v0.6/contracts/","@openzeppelin/=node_modules/@openzeppelin/","@safe-global/=node_modules/@safe-global/","ds-test/=node_modules/ds-test/src/","erc7579/=node_modules/erc7579/src/","forge-std/=node_modules/forge-std/src/","solady/=node_modules/solady/src/","solarray/=node_modules/solarray/src/","@prb/math/=node_modules/@prb/math/src/","freshcryptolib/=node_modules/freshcryptolib/solidity/src/","kernel/=node_modules/@zerodev/kernel/src/","ExcessivelySafeCall/=node_modules/excessively-safe-call/src/","excessively-safe-call/=node_modules/excessively-safe-call/src/","flatbytes/=node_modules/@rhinestone/flatbytes/src/","stringutils/=node_modules/stringutils/src/","@gnosis.pm/=node_modules/@gnosis.pm/","@zerodev/=node_modules/@zerodev/","hardhat-deploy/=node_modules/hardhat-deploy/","hardhat/=node_modules/hardhat/"],"optimizer":{"enabled":true,"runs":833},"metadata":{"useLiteralContent":false,"bytecodeHash":"none","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":false,"libraries":{}}}
